var oe=Object.defineProperty;var re=(n,t,e)=>t in n?oe(n,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[t]=e;var dt=(n,t,e)=>(re(n,typeof t!="symbol"?t+"":t,e),e);/* empty css              */import{m as Mt}from"./Antdv.35288747.js";import{t as ce}from"./index.8b9e7665.js";import{d as Dt,aR as st,h as z,V as ft,bu as te,bv as q,bw as Ft,b3 as ae,t as Tt,bx as le,aS as ue,K as Y,a4 as Nt,aw as fe,al as de,am as pe,s as he,M as me}from"./three.a7f96461.js";var Qe=n=>(Mt.loading({content:"\u6B63\u5728\u52A0\u8F7D3D\u8D44\u6E90\uFF1A0%",key:"loading",duration:0}),n.loaderManager.addEventListener("loading",t=>{Mt.loading({content:`\u6B63\u5728\u52A0\u8F7D3D\u8D44\u6E90\uFF1A${parseInt((t.loadSuccess/t.loadTotal*100).toString())}
  %`,key:"loading",duration:0})}),n.loaderManager.addEventListener("loaded",t=>{Mt.success({content:"\u52A0\u8F7D\u5B8C\u6210\uFF01",key:"loading",duration:1})}),n);function ye(n,t=!1){const e=n[0].index!==null,s=new Set(Object.keys(n[0].attributes)),i=new Set(Object.keys(n[0].morphAttributes)),c={},r={},u=n[0].morphTargetsRelative,o=new Dt;let d=0;for(let a=0;a<n.length;++a){const f=n[a];let l=0;if(e!==(f.index!==null))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+a+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const p in f.attributes){if(!s.has(p))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+a+'. All geometries must have compatible attributes; make sure "'+p+'" attribute exists among all geometries, or in none of them.'),null;c[p]===void 0&&(c[p]=[]),c[p].push(f.attributes[p]),l++}if(l!==s.size)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+a+". Make sure all geometries have the same number of attributes."),null;if(u!==f.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+a+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const p in f.morphAttributes){if(!i.has(p))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+a+".  .morphAttributes must be consistent throughout all geometries."),null;r[p]===void 0&&(r[p]=[]),r[p].push(f.morphAttributes[p])}if(o.userData.mergedUserData=o.userData.mergedUserData||[],o.userData.mergedUserData.push(f.userData),t){let p;if(e)p=f.index.count;else if(f.attributes.position!==void 0)p=f.attributes.position.count;else return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+a+". The geometry must have either an index or a position attribute"),null;o.addGroup(d,p,a),d+=p}}if(e){let a=0;const f=[];for(let l=0;l<n.length;++l){const p=n[l].index;for(let y=0;y<p.count;++y)f.push(p.getX(y)+a);a+=n[l].attributes.position.count}o.setIndex(f)}for(const a in c){const f=qt(c[a]);if(!f)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+a+" attribute."),null;o.setAttribute(a,f)}for(const a in r){const f=r[a][0].length;if(f===0)break;o.morphAttributes=o.morphAttributes||{},o.morphAttributes[a]=[];for(let l=0;l<f;++l){const p=[];for(let B=0;B<r[a].length;++B)p.push(r[a][B][l]);const y=qt(p);if(!y)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+a+" morphAttribute."),null;o.morphAttributes[a].push(y)}}return o}function qt(n){let t,e,s,i=0;for(let u=0;u<n.length;++u){const o=n[u];if(o.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(t===void 0&&(t=o.array.constructor),t!==o.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(e===void 0&&(e=o.itemSize),e!==o.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(s===void 0&&(s=o.normalized),s!==o.normalized)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;i+=o.array.length}const c=new t(i);let r=0;for(let u=0;u<n.length;++u)c.set(n[u].array,r),r+=n[u].array.length;return new st(c,e,s)}const ee=0,xe=1,be=2,Gt=2,St=1.25,kt=1,At=6*4+4+4,Ct=65535,ge=Math.pow(2,-24);class pt{constructor(){}}function L(n,t,e){return e.min.x=t[n],e.min.y=t[n+1],e.min.z=t[n+2],e.max.x=t[n+3],e.max.y=t[n+4],e.max.z=t[n+5],e}function Ot(n){let t=-1,e=-1/0;for(let s=0;s<3;s++){const i=n[s+3]-n[s];i>e&&(e=i,t=s)}return t}function Xt(n,t){t.set(n)}function jt(n,t,e){let s,i;for(let c=0;c<3;c++){const r=c+3;s=n[c],i=t[c],e[c]=s<i?s:i,s=n[r],i=t[r],e[r]=s>i?s:i}}function ht(n,t,e){for(let s=0;s<3;s++){const i=t[n+2*s],c=t[n+2*s+1],r=i-c,u=i+c;r<e[s]&&(e[s]=r),u>e[s+3]&&(e[s+3]=u)}}function it(n){const t=n[3]-n[0],e=n[4]-n[1],s=n[5]-n[2];return 2*(t*e+e*s+s*t)}function we(n,t){if(!n.index){const e=n.attributes.position.count,s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;let i;e>65535?i=new Uint32Array(new s(4*e)):i=new Uint16Array(new s(2*e)),n.setIndex(new st(i,1));for(let c=0;c<e;c++)i[c]=c}}function Ae(n){if(!n.groups||!n.groups.length)return[{offset:0,count:n.index.count/3}];const t=[],e=new Set;for(const i of n.groups)e.add(i.start),e.add(i.start+i.count);const s=Array.from(e.values()).sort((i,c)=>i-c);for(let i=0;i<s.length-1;i++){const c=s[i],r=s[i+1];t.push({offset:c/3,count:(r-c)/3})}return t}function It(n,t,e,s,i=null){let c=1/0,r=1/0,u=1/0,o=-1/0,d=-1/0,a=-1/0,f=1/0,l=1/0,p=1/0,y=-1/0,B=-1/0,w=-1/0;const h=i!==null;for(let x=t*6,m=(t+e)*6;x<m;x+=6){const g=n[x+0],b=n[x+1],A=g-b,T=g+b;A<c&&(c=A),T>o&&(o=T),h&&g<f&&(f=g),h&&g>y&&(y=g);const P=n[x+2],v=n[x+3],M=P-v,S=P+v;M<r&&(r=M),S>d&&(d=S),h&&P<l&&(l=P),h&&P>B&&(B=P);const E=n[x+4],I=n[x+5],U=E-I,F=E+I;U<u&&(u=U),F>a&&(a=F),h&&E<p&&(p=E),h&&E>w&&(w=E)}s[0]=c,s[1]=r,s[2]=u,s[3]=o,s[4]=d,s[5]=a,h&&(i[0]=f,i[1]=l,i[2]=p,i[3]=y,i[4]=B,i[5]=w)}function Be(n,t,e,s){let i=1/0,c=1/0,r=1/0,u=-1/0,o=-1/0,d=-1/0;for(let a=t*6,f=(t+e)*6;a<f;a+=6){const l=n[a+0];l<i&&(i=l),l>u&&(u=l);const p=n[a+2];p<c&&(c=p),p>o&&(o=p);const y=n[a+4];y<r&&(r=y),y>d&&(d=y)}s[0]=i,s[1]=c,s[2]=r,s[3]=u,s[4]=o,s[5]=d}function Te(n,t,e,s,i){let c=e,r=e+s-1;const u=i.pos,o=i.axis*2;for(;;){for(;c<=r&&t[c*6+o]<u;)c++;for(;c<=r&&t[r*6+o]>=u;)r--;if(c<r){for(let d=0;d<3;d++){let a=n[c*3+d];n[c*3+d]=n[r*3+d],n[r*3+d]=a;let f=t[c*6+d*2+0];t[c*6+d*2+0]=t[r*6+d*2+0],t[r*6+d*2+0]=f;let l=t[c*6+d*2+1];t[c*6+d*2+1]=t[r*6+d*2+1],t[r*6+d*2+1]=l}c++,r--}else return c}}const N=32,Pe=(n,t)=>n.candidate-t.candidate,k=new Array(N).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),mt=new Float32Array(6);function ve(n,t,e,s,i,c){let r=-1,u=0;if(c===ee)r=Ot(t),r!==-1&&(u=(t[r]+t[r+3])/2);else if(c===xe)r=Ot(n),r!==-1&&(u=Me(e,s,i,r));else if(c===be){const o=it(n);let d=St*i;const a=s*6,f=(s+i)*6;for(let l=0;l<3;l++){const p=t[l],w=(t[l+3]-p)/N;if(i<N/4){const h=[...k];h.length=i;let x=0;for(let g=a;g<f;g+=6,x++){const b=h[x];b.candidate=e[g+2*l],b.count=0;const{bounds:A,leftCacheBounds:T,rightCacheBounds:P}=b;for(let v=0;v<3;v++)P[v]=1/0,P[v+3]=-1/0,T[v]=1/0,T[v+3]=-1/0,A[v]=1/0,A[v+3]=-1/0;ht(g,e,A)}h.sort(Pe);let m=i;for(let g=0;g<m;g++){const b=h[g];for(;g+1<m&&h[g+1].candidate===b.candidate;)h.splice(g+1,1),m--}for(let g=a;g<f;g+=6){const b=e[g+2*l];for(let A=0;A<m;A++){const T=h[A];b>=T.candidate?ht(g,e,T.rightCacheBounds):(ht(g,e,T.leftCacheBounds),T.count++)}}for(let g=0;g<m;g++){const b=h[g],A=b.count,T=i-b.count,P=b.leftCacheBounds,v=b.rightCacheBounds;let M=0;A!==0&&(M=it(P)/o);let S=0;T!==0&&(S=it(v)/o);const E=kt+St*(M*A+S*T);E<d&&(r=l,d=E,u=b.candidate)}}else{for(let m=0;m<N;m++){const g=k[m];g.count=0,g.candidate=p+w+m*w;const b=g.bounds;for(let A=0;A<3;A++)b[A]=1/0,b[A+3]=-1/0}for(let m=a;m<f;m+=6){let A=~~((e[m+2*l]-p)/w);A>=N&&(A=N-1);const T=k[A];T.count++,ht(m,e,T.bounds)}const h=k[N-1];Xt(h.bounds,h.rightCacheBounds);for(let m=N-2;m>=0;m--){const g=k[m],b=k[m+1];jt(g.bounds,b.rightCacheBounds,g.rightCacheBounds)}let x=0;for(let m=0;m<N-1;m++){const g=k[m],b=g.count,A=g.bounds,P=k[m+1].rightCacheBounds;b!==0&&(x===0?Xt(A,mt):jt(A,mt,mt)),x+=b;let v=0,M=0;x!==0&&(v=it(mt)/o);const S=i-x;S!==0&&(M=it(P)/o);const E=kt+St*(v*x+M*S);E<d&&(r=l,d=E,u=g.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${c} used.`);return{axis:r,pos:u}}function Me(n,t,e,s){let i=0;for(let c=t,r=t+e;c<r;c++)i+=n[c*6+s*2];return i/e}function Se(n,t){const e=n.attributes.position,s=n.index.array,i=s.length/3,c=new Float32Array(i*6),r=e.normalized,u=e.array,o=e.offset||0;let d=3;e.isInterleavedBufferAttribute&&(d=e.data.stride);const a=["getX","getY","getZ"];for(let f=0;f<i;f++){const l=f*3,p=f*6;let y,B,w;r?(y=s[l+0],B=s[l+1],w=s[l+2]):(y=s[l+0]*d+o,B=s[l+1]*d+o,w=s[l+2]*d+o);for(let h=0;h<3;h++){let x,m,g;r?(x=e[a[h]](y),m=e[a[h]](B),g=e[a[h]](w)):(x=u[y+h],m=u[B+h],g=u[w+h]);let b=x;m<b&&(b=m),g<b&&(b=g);let A=x;m>A&&(A=m),g>A&&(A=g);const T=(A-b)/2,P=h*2;c[p+P+0]=b+T,c[p+P+1]=T+(Math.abs(b)+T)*ge,b<t[h]&&(t[h]=b),A>t[h+3]&&(t[h+3]=A)}}return c}function Ie(n,t){function e(h){l&&l(h/p)}function s(h,x,m,g=null,b=0){if(!y&&b>=o&&(y=!0,d&&(console.warn(`MeshBVH: Max depth of ${o} reached when generating BVH. Consider increasing maxDepth.`),console.warn(n))),m<=a||b>=o)return e(x+m),h.offset=x,h.count=m,h;const A=ve(h.boundingData,g,r,x,m,f);if(A.axis===-1)return e(x+m),h.offset=x,h.count=m,h;const T=Te(u,r,x,m,A);if(T===x||T===x+m)e(x+m),h.offset=x,h.count=m;else{h.splitAxis=A.axis;const P=new pt,v=x,M=T-x;h.left=P,P.boundingData=new Float32Array(6),It(r,v,M,P.boundingData,c),s(P,v,M,c,b+1);const S=new pt,E=T,I=m-M;h.right=S,S.boundingData=new Float32Array(6),It(r,E,I,S.boundingData,c),s(S,E,I,c,b+1)}return h}we(n,t);const i=new Float32Array(6),c=new Float32Array(6),r=Se(n,i),u=n.index.array,o=t.maxDepth,d=t.verbose,a=t.maxLeafTris,f=t.strategy,l=t.onProgress,p=n.index.count/3;let y=!1;const B=[],w=Ae(n);if(w.length===1){const h=w[0],x=new pt;x.boundingData=i,Be(r,h.offset,h.count,c),s(x,h.offset,h.count,c),B.push(x)}else for(let h of w){const x=new pt;x.boundingData=new Float32Array(6),It(r,h.offset,h.count,x.boundingData,c),s(x,h.offset,h.count,c),B.push(x)}return B}function Ee(n,t){const e=Ie(n,t);let s,i,c;const r=[],u=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let a=0;a<e.length;a++){const f=e[a];let l=o(f);const p=new u(At*l);s=new Float32Array(p),i=new Uint32Array(p),c=new Uint16Array(p),d(0,f),r.push(p)}return r;function o(a){return a.count?1:1+o(a.left)+o(a.right)}function d(a,f){const l=a/4,p=a/2,y=!!f.count,B=f.boundingData;for(let w=0;w<6;w++)s[l+w]=B[w];if(y){const w=f.offset,h=f.count;return i[l+6]=w,c[p+14]=h,c[p+15]=Ct,a+At}else{const w=f.left,h=f.right,x=f.splitAxis;let m;if(m=d(a+At,w),m/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return i[l+6]=m/4,m=d(m,h),i[l+7]=x,m}}}class _{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let s=1/0,i=-1/0;for(let c=0,r=t.length;c<r;c++){const o=t[c][e];s=o<s?o:s,i=o>i?o:i}this.min=s,this.max=i}setFromPoints(t,e){let s=1/0,i=-1/0;for(let c=0,r=e.length;c<r;c++){const u=e[c],o=t.dot(u);s=o<s?o:s,i=o>i?o:i}this.min=s,this.max=i}isSeparated(t){return this.min>t.max||t.min>this.max}}_.prototype.setFromBox=function(){const n=new z;return function(e,s){const i=s.min,c=s.max;let r=1/0,u=-1/0;for(let o=0;o<=1;o++)for(let d=0;d<=1;d++)for(let a=0;a<=1;a++){n.x=i.x*o+c.x*(1-o),n.y=i.y*d+c.y*(1-d),n.z=i.z*a+c.z*(1-a);const f=e.dot(n);r=Math.min(f,r),u=Math.max(f,u)}this.min=r,this.max=u}}();(function(){const n=new _;return function(e,s){const i=e.points,c=e.satAxes,r=e.satBounds,u=s.points,o=s.satAxes,d=s.satBounds;for(let a=0;a<3;a++){const f=r[a],l=c[a];if(n.setFromPoints(l,u),f.isSeparated(n))return!1}for(let a=0;a<3;a++){const f=d[a],l=o[a];if(n.setFromPoints(l,i),f.isSeparated(n))return!1}}})();const ze=function(){const n=new z,t=new z,e=new z;return function(i,c,r){const u=i.start,o=n,d=c.start,a=t;e.subVectors(u,d),n.subVectors(i.end,i.start),t.subVectors(c.end,c.start);const f=e.dot(a),l=a.dot(o),p=a.dot(a),y=e.dot(o),w=o.dot(o)*p-l*l;let h,x;w!==0?h=(f*l-y*p)/w:h=0,x=(f+h*l)/p,r.x=h,r.y=x}}(),_t=function(){const n=new ft,t=new z,e=new z;return function(i,c,r,u){ze(i,c,n);let o=n.x,d=n.y;if(o>=0&&o<=1&&d>=0&&d<=1){i.at(o,r),c.at(d,u);return}else if(o>=0&&o<=1){d<0?c.at(0,u):c.at(1,u),i.closestPointToPoint(u,!0,r);return}else if(d>=0&&d<=1){o<0?i.at(0,r):i.at(1,r),c.closestPointToPoint(r,!0,u);return}else{let a;o<0?a=i.start:a=i.end;let f;d<0?f=c.start:f=c.end;const l=t,p=e;if(i.closestPointToPoint(f,!0,t),c.closestPointToPoint(a,!0,e),l.distanceToSquared(f)<=p.distanceToSquared(a)){r.copy(l),u.copy(f);return}else{r.copy(a),u.copy(p);return}}}}(),Ue=function(){const n=new z,t=new z,e=new te,s=new q;return function(c,r){const{radius:u,center:o}=c,{a:d,b:a,c:f}=r;if(s.start=d,s.end=a,s.closestPointToPoint(o,!0,n).distanceTo(o)<=u||(s.start=d,s.end=f,s.closestPointToPoint(o,!0,n).distanceTo(o)<=u)||(s.start=a,s.end=f,s.closestPointToPoint(o,!0,n).distanceTo(o)<=u))return!0;const B=r.getPlane(e);if(Math.abs(B.distanceToPoint(o))<=u){const h=B.projectPoint(o,t);if(r.containsPoint(h))return!0}return!1}}(),Fe=1e-15;function K(n){return Math.abs(n)<Fe}class G extends Ft{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new z),this.satBounds=new Array(4).fill().map(()=>new _),this.points=[this.a,this.b,this.c],this.sphere=new ae,this.plane=new te,this.needsUpdate=!0}intersectsSphere(t){return Ue(t,this)}update(){const t=this.a,e=this.b,s=this.c,i=this.points,c=this.satAxes,r=this.satBounds,u=c[0],o=r[0];this.getNormal(u),o.setFromPoints(u,i);const d=c[1],a=r[1];d.subVectors(t,e),a.setFromPoints(d,i);const f=c[2],l=r[2];f.subVectors(e,s),l.setFromPoints(f,i);const p=c[3],y=r[3];p.subVectors(s,t),y.setFromPoints(p,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(u,t),this.needsUpdate=!1}}G.prototype.closestPointToSegment=function(){const n=new z,t=new z,e=new q;return function(i,c=null,r=null){const{start:u,end:o}=i,d=this.points;let a,f=1/0;for(let l=0;l<3;l++){const p=(l+1)%3;e.start.copy(d[l]),e.end.copy(d[p]),_t(e,i,n,t),a=n.distanceToSquared(t),a<f&&(f=a,c&&c.copy(n),r&&r.copy(t))}return this.closestPointToPoint(u,n),a=u.distanceToSquared(n),a<f&&(f=a,c&&c.copy(n),r&&r.copy(u)),this.closestPointToPoint(o,n),a=o.distanceToSquared(n),a<f&&(f=a,c&&c.copy(n),r&&r.copy(o)),Math.sqrt(f)}}();G.prototype.intersectsTriangle=function(){const n=new G,t=new Array(3),e=new Array(3),s=new _,i=new _,c=new z,r=new z,u=new z,o=new z,d=new q,a=new q,f=new q;return function(p,y=null){this.needsUpdate&&this.update(),p.isExtendedTriangle?p.needsUpdate&&p.update():(n.copy(p),n.update(),p=n);const B=this.plane,w=p.plane;if(Math.abs(B.normal.dot(w.normal))>1-1e-10){const h=this.satBounds,x=this.satAxes;e[0]=p.a,e[1]=p.b,e[2]=p.c;for(let b=0;b<4;b++){const A=h[b],T=x[b];if(s.setFromPoints(T,e),A.isSeparated(s))return!1}const m=p.satBounds,g=p.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let b=0;b<4;b++){const A=m[b],T=g[b];if(s.setFromPoints(T,t),A.isSeparated(s))return!1}for(let b=0;b<4;b++){const A=x[b];for(let T=0;T<4;T++){const P=g[T];if(c.crossVectors(A,P),s.setFromPoints(c,t),i.setFromPoints(c,e),s.isSeparated(i))return!1}}return y&&(console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),y.start.set(0,0,0),y.end.set(0,0,0)),!0}else{const h=this.points;let x=!1,m=0;for(let I=0;I<3;I++){const U=h[I],F=h[(I+1)%3];d.start.copy(U),d.end.copy(F),d.delta(r);const V=x?a.start:a.end,C=K(w.distanceToPoint(U));if(K(w.normal.dot(r))&&C){a.copy(d),m=2;break}if((w.intersectLine(d,V)||C)&&!K(V.distanceTo(F))){if(m++,x)break;x=!0}}if(m===1&&p.containsPoint(a.end))return y&&(y.start.copy(a.end),y.end.copy(a.end)),!0;if(m!==2)return!1;const g=p.points;let b=!1,A=0;for(let I=0;I<3;I++){const U=g[I],F=g[(I+1)%3];d.start.copy(U),d.end.copy(F),d.delta(u);const V=b?f.start:f.end,C=K(B.distanceToPoint(U));if(K(B.normal.dot(u))&&C){f.copy(d),A=2;break}if((B.intersectLine(d,V)||C)&&!K(V.distanceTo(F))){if(A++,b)break;b=!0}}if(A===1&&this.containsPoint(f.end))return y&&(y.start.copy(f.end),y.end.copy(f.end)),!0;if(A!==2)return!1;if(a.delta(r),f.delta(u),r.dot(u)<0){let I=f.start;f.start=f.end,f.end=I}const T=a.start.dot(r),P=a.end.dot(r),v=f.start.dot(r),M=f.end.dot(r),S=P<v,E=T<M;return T!==M&&v!==P&&S===E?!1:(y&&(o.subVectors(a.start,f.start),o.dot(r)>0?y.start.copy(a.start):y.start.copy(f.start),o.subVectors(a.end,f.end),o.dot(r)<0?y.end.copy(a.end):y.end.copy(f.end)),!0)}}}();G.prototype.distanceToPoint=function(){const n=new z;return function(e){return this.closestPointToPoint(e,n),e.distanceTo(n)}}();G.prototype.distanceToTriangle=function(){const n=new z,t=new z,e=["a","b","c"],s=new q,i=new q;return function(r,u=null,o=null){const d=u||o?s:null;if(this.intersectsTriangle(r,d))return(u||o)&&(u&&d.getCenter(u),o&&d.getCenter(o)),0;let a=1/0;for(let f=0;f<3;f++){let l;const p=e[f],y=r[p];this.closestPointToPoint(y,n),l=y.distanceToSquared(n),l<a&&(a=l,u&&u.copy(n),o&&o.copy(y));const B=this[p];r.closestPointToPoint(B,n),l=B.distanceToSquared(n),l<a&&(a=l,u&&u.copy(B),o&&o.copy(n))}for(let f=0;f<3;f++){const l=e[f],p=e[(f+1)%3];s.set(this[l],this[p]);for(let y=0;y<3;y++){const B=e[y],w=e[(y+1)%3];i.set(r[B],r[w]),_t(s,i,n,t);const h=n.distanceToSquared(t);h<a&&(a=h,u&&u.copy(n),o&&o.copy(t))}}return Math.sqrt(a)}}();class H{constructor(t,e,s){this.isOrientedBox=!0,this.min=new z,this.max=new z,this.matrix=new Tt,this.invMatrix=new Tt,this.points=new Array(8).fill().map(()=>new z),this.satAxes=new Array(3).fill().map(()=>new z),this.satBounds=new Array(3).fill().map(()=>new _),this.alignedSatBounds=new Array(3).fill().map(()=>new _),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),s&&this.matrix.copy(s)}set(t,e,s){this.min.copy(t),this.max.copy(e),this.matrix.copy(s),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}H.prototype.update=function(){return function(){const t=this.matrix,e=this.min,s=this.max,i=this.points;for(let d=0;d<=1;d++)for(let a=0;a<=1;a++)for(let f=0;f<=1;f++){const l=1*d|2*a|4*f,p=i[l];p.x=d?s.x:e.x,p.y=a?s.y:e.y,p.z=f?s.z:e.z,p.applyMatrix4(t)}const c=this.satBounds,r=this.satAxes,u=i[0];for(let d=0;d<3;d++){const a=r[d],f=c[d],l=1<<d,p=i[l];a.subVectors(u,p),f.setFromPoints(a,i)}const o=this.alignedSatBounds;o[0].setFromPointsField(i,"x"),o[1].setFromPointsField(i,"y"),o[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();H.prototype.intersectsBox=function(){const n=new _;return function(e){this.needsUpdate&&this.update();const s=e.min,i=e.max,c=this.satBounds,r=this.satAxes,u=this.alignedSatBounds;if(n.min=s.x,n.max=i.x,u[0].isSeparated(n)||(n.min=s.y,n.max=i.y,u[1].isSeparated(n))||(n.min=s.z,n.max=i.z,u[2].isSeparated(n)))return!1;for(let o=0;o<3;o++){const d=r[o],a=c[o];if(n.setFromBox(d,e),a.isSeparated(n))return!1}return!0}}();H.prototype.intersectsTriangle=function(){const n=new G,t=new Array(3),e=new _,s=new _,i=new z;return function(r){this.needsUpdate&&this.update(),r.isExtendedTriangle?r.needsUpdate&&r.update():(n.copy(r),n.update(),r=n);const u=this.satBounds,o=this.satAxes;t[0]=r.a,t[1]=r.b,t[2]=r.c;for(let l=0;l<3;l++){const p=u[l],y=o[l];if(e.setFromPoints(y,t),p.isSeparated(e))return!1}const d=r.satBounds,a=r.satAxes,f=this.points;for(let l=0;l<3;l++){const p=d[l],y=a[l];if(e.setFromPoints(y,f),p.isSeparated(e))return!1}for(let l=0;l<3;l++){const p=o[l];for(let y=0;y<4;y++){const B=a[y];if(i.crossVectors(p,B),e.setFromPoints(i,t),s.setFromPoints(i,f),e.isSeparated(s))return!1}}return!0}}();H.prototype.closestPointToPoint=function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}();H.prototype.distanceToPoint=function(){const n=new z;return function(e){return this.closestPointToPoint(e,n),e.distanceTo(n)}}();H.prototype.distanceToBox=function(){const n=["x","y","z"],t=new Array(12).fill().map(()=>new q),e=new Array(12).fill().map(()=>new q),s=new z,i=new z;return function(r,u=0,o=null,d=null){if(this.needsUpdate&&this.update(),this.intersectsBox(r))return(o||d)&&(r.getCenter(i),this.closestPointToPoint(i,s),r.closestPointToPoint(s,i),o&&o.copy(s),d&&d.copy(i)),0;const a=u*u,f=r.min,l=r.max,p=this.points;let y=1/0;for(let w=0;w<8;w++){const h=p[w];i.copy(h).clamp(f,l);const x=h.distanceToSquared(i);if(x<y&&(y=x,o&&o.copy(h),d&&d.copy(i),x<a))return Math.sqrt(x)}let B=0;for(let w=0;w<3;w++)for(let h=0;h<=1;h++)for(let x=0;x<=1;x++){const m=(w+1)%3,g=(w+2)%3,b=h<<m|x<<g,A=1<<w|h<<m|x<<g,T=p[b],P=p[A];t[B].set(T,P);const M=n[w],S=n[m],E=n[g],I=e[B],U=I.start,F=I.end;U[M]=f[M],U[S]=h?f[S]:l[S],U[E]=x?f[E]:l[S],F[M]=l[M],F[S]=h?f[S]:l[S],F[E]=x?f[E]:l[S],B++}for(let w=0;w<=1;w++)for(let h=0;h<=1;h++)for(let x=0;x<=1;x++){i.x=w?l.x:f.x,i.y=h?l.y:f.y,i.z=x?l.z:f.z,this.closestPointToPoint(i,s);const m=i.distanceToSquared(s);if(m<y&&(y=m,o&&o.copy(s),d&&d.copy(i),m<a))return Math.sqrt(m)}for(let w=0;w<12;w++){const h=t[w];for(let x=0;x<12;x++){const m=e[x];_t(h,m,s,i);const g=s.distanceToSquared(i);if(g<y&&(y=g,o&&o.copy(s),d&&d.copy(i),g<a))return Math.sqrt(g)}}return Math.sqrt(y)}}();const yt=new z,xt=new z,bt=new z,Wt=new ft,Yt=new ft,Zt=new ft,$t=new z;function Ce(n,t,e,s,i,c){let r;return c===le?r=n.intersectTriangle(s,e,t,!0,i):r=n.intersectTriangle(t,e,s,c!==ue,i),r===null?null:{distance:n.origin.distanceTo(i),point:i.clone()}}function Ve(n,t,e,s,i,c,r){yt.fromBufferAttribute(t,s),xt.fromBufferAttribute(t,i),bt.fromBufferAttribute(t,c);const u=Ce(n,yt,xt,bt,$t,r);if(u){e&&(Wt.fromBufferAttribute(e,s),Yt.fromBufferAttribute(e,i),Zt.fromBufferAttribute(e,c),u.uv=Ft.getUV($t,yt,xt,bt,Wt,Yt,Zt,new ft));const o={a:s,b:i,c,normal:new z,materialIndex:0};Ft.getNormal(yt,xt,bt,o.normal),u.face=o,u.faceIndex=s}return u}function se(n,t,e,s,i){const c=s*3,r=n.index.getX(c),u=n.index.getX(c+1),o=n.index.getX(c+2),d=Ve(e,n.attributes.position,n.attributes.uv,r,u,o,t);return d?(d.faceIndex=s,i&&i.push(d),d):null}function Le(n,t,e,s,i,c){for(let r=s,u=s+i;r<u;r++)se(n,t,e,r,c)}function Re(n,t,e,s,i){let c=1/0,r=null;for(let u=s,o=s+i;u<o;u++){const d=se(n,t,e,u);d&&d.distance<c&&(r=d,c=d.distance)}return r}function D(n,t,e,s){const i=n.a,c=n.b,r=n.c;let u=t,o=t+1,d=t+2;e&&(u=e.getX(t),o=e.getX(t+1),d=e.getX(t+2)),i.x=s.getX(u),i.y=s.getY(u),i.z=s.getZ(u),c.x=s.getX(o),c.y=s.getY(o),c.z=s.getZ(o),r.x=s.getX(d),r.y=s.getY(d),r.z=s.getZ(d)}function Kt(n,t,e,s,i,c,r){const u=e.index,o=e.attributes.position;for(let d=n,a=t+n;d<a;d++)if(D(r,d*3,u,o),r.needsUpdate=!0,s(r,d,i,c))return!0;return!1}class ne{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}function O(n,t){return t[n+15]===65535}function tt(n,t){return t[n+6]}function at(n,t){return t[n+14]}function lt(n){return n+8}function ut(n,t){return t[n+6]}function De(n,t){return t[n+7]}const Q=new Y,Pt=new z,_e=["x","y","z"];function Vt(n,t,e,s,i){let c=n*2,r=nt,u=X,o=j;if(O(c,u)){const a=tt(n,o),f=at(c,u);Le(t,e,s,a,f,i)}else{const a=lt(n);vt(a,r,s,Pt)&&Vt(a,t,e,s,i);const f=ut(n,o);vt(f,r,s,Pt)&&Vt(f,t,e,s,i)}}function Lt(n,t,e,s){let i=n*2,c=nt,r=X,u=j;if(O(i,r)){const d=tt(n,u),a=at(i,r);return Re(t,e,s,d,a)}else{const d=De(n,u),a=_e[d],l=s.direction[a]>=0;let p,y;l?(p=lt(n),y=ut(n,u)):(p=ut(n,u),y=lt(n));const w=vt(p,c,s,Pt)?Lt(p,t,e,s):null;if(w){const m=w.point[a];if(l?m<=c[y+d]:m>=c[y+d+3])return w}const x=vt(y,c,s,Pt)?Lt(y,t,e,s):null;return w&&x?w.distance<=x.distance?w:x:w||x||null}}const He=function(){let n,t;const e=[],s=new ne(()=>new Y);return function(...r){n=s.getPrimitive(),t=s.getPrimitive(),e.push(n,t);const u=i(...r);s.releasePrimitive(n),s.releasePrimitive(t),e.pop(),e.pop();const o=e.length;return o>0&&(t=e[o-1],n=e[o-2]),u};function i(c,r,u,o,d=null,a=0,f=0){function l(m){let g=m*2,b=X,A=j;for(;!O(g,b);)m=lt(m),g=m*2;return tt(m,A)}function p(m){let g=m*2,b=X,A=j;for(;!O(g,b);)m=ut(m,A),g=m*2;return tt(m,A)+at(g,b)}let y=c*2,B=nt,w=X,h=j;if(O(y,w)){const m=tt(c,h),g=at(y,w);return L(c,B,n),o(m,g,!1,f,a+c,n)}else{const m=lt(c),g=ut(c,h);let b=m,A=g,T,P,v,M;if(d&&(v=n,M=t,L(b,B,v),L(A,B,M),T=d(v),P=d(M),P<T)){b=g,A=m;const C=T;T=P,P=C,v=M}v||(v=n,L(b,B,v));const S=O(b*2,w),E=u(v,S,T,f+1,a+b);let I;if(E===Gt){const C=l(b),$=p(b)-C;I=o(C,$,!0,f+1,a+b,v)}else I=E&&i(b,r,u,o,d,a,f+1);if(I)return!0;M=t,L(A,B,M);const U=O(A*2,w),F=u(M,U,P,f+1,a+A);let V;if(F===Gt){const C=l(A),$=p(A)-C;V=o(C,$,!0,f+1,a+A,M)}else V=F&&i(A,r,u,o,d,a,f+1);return!!V}}}(),Ne=function(){const n=new G,t=new G,e=new Tt,s=new H,i=new H;return function c(r,u,o,d,a=null){let f=r*2,l=nt,p=X,y=j;if(a===null&&(o.boundingBox||o.computeBoundingBox(),s.set(o.boundingBox.min,o.boundingBox.max,d),a=s),O(f,p)){const w=u,h=w.index,x=w.attributes.position,m=o.index,g=o.attributes.position,b=tt(r,y),A=at(f,p);if(e.copy(d).invert(),o.boundsTree)return L(r,l,i),i.matrix.copy(e),i.needsUpdate=!0,o.boundsTree.shapecast({intersectsBounds:P=>i.intersectsBox(P),intersectsTriangle:P=>{P.a.applyMatrix4(d),P.b.applyMatrix4(d),P.c.applyMatrix4(d),P.needsUpdate=!0;for(let v=b*3,M=(A+b)*3;v<M;v+=3)if(D(t,v,h,x),t.needsUpdate=!0,P.intersectsTriangle(t))return!0;return!1}});for(let T=b*3,P=A+b*3;T<P;T+=3){D(n,T,h,x),n.a.applyMatrix4(e),n.b.applyMatrix4(e),n.c.applyMatrix4(e),n.needsUpdate=!0;for(let v=0,M=m.count;v<M;v+=3)if(D(t,v,m,g),t.needsUpdate=!0,n.intersectsTriangle(t))return!0}}else{const w=r+8,h=y[r+6];return L(w,l,Q),!!(a.intersectsBox(Q)&&c(w,u,o,d,a)||(L(h,l,Q),a.intersectsBox(Q)&&c(h,u,o,d,a)))}}}();function vt(n,t,e,s){return L(n,t,Q),e.intersectBox(Q,s)}const Rt=[];let Bt,nt,X,j;function ct(n){Bt&&Rt.push(Bt),Bt=n,nt=new Float32Array(n),X=new Uint16Array(n),j=new Uint32Array(n)}function gt(){Bt=null,nt=null,X=null,j=null,Rt.length&&ct(Rt.pop())}const Et=Symbol("skip tree generation"),zt=new Y,Ut=new Y,J=new Tt,W=new H,ot=new H,rt=new z,wt=new z,qe=new z,Ge=new z,ke=new z,Jt=new Y,R=new ne(()=>new G);class et{static serialize(t,e={}){if(e.isBufferGeometry)return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."),et.serialize(arguments[0],{cloneBuffers:arguments[2]===void 0?!0:arguments[2]});e={cloneBuffers:!0,...e};const s=t.geometry,i=t._roots,c=s.getIndex();let r;return e.cloneBuffers?r={roots:i.map(u=>u.slice()),index:c.array.slice()}:r={roots:i,index:c.array},r}static deserialize(t,e,s={}){if(typeof s=="boolean")return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."),et.deserialize(arguments[0],arguments[1],{setIndex:arguments[2]===void 0?!0:arguments[2]});s={setIndex:!0,...s};const{index:i,roots:c}=t,r=new et(e,{...s,[Et]:!0});if(r._roots=c,s.setIndex){const u=e.getIndex();if(u===null){const o=new st(t.index,1,!1);e.setIndex(o)}else u.array!==i&&(u.array.set(i),u.needsUpdate=!0)}return r}constructor(t,e={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(e=Object.assign({strategy:ee,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,[Et]:!1},e),e.useSharedArrayBuffer&&typeof SharedArrayBuffer=="undefined")throw new Error("MeshBVH: SharedArrayBuffer is not available.");this._roots=null,e[Et]||(this._roots=Ee(t,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new Y))),this.geometry=t}refit(t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=this.geometry,s=e.index.array,i=e.attributes.position;let c,r,u,o,d=0;const a=this._roots;for(let l=0,p=a.length;l<p;l++)c=a[l],r=new Uint32Array(c),u=new Uint16Array(c),o=new Float32Array(c),f(0,d),d+=c.byteLength;function f(l,p,y=!1){const B=l*2;if(u[B+15]===Ct){const h=r[l+6],x=u[B+14];let m=1/0,g=1/0,b=1/0,A=-1/0,T=-1/0,P=-1/0;for(let v=3*h,M=3*(h+x);v<M;v++){const S=s[v],E=i.getX(S),I=i.getY(S),U=i.getZ(S);E<m&&(m=E),E>A&&(A=E),I<g&&(g=I),I>T&&(T=I),U<b&&(b=U),U>P&&(P=U)}return o[l+0]!==m||o[l+1]!==g||o[l+2]!==b||o[l+3]!==A||o[l+4]!==T||o[l+5]!==P?(o[l+0]=m,o[l+1]=g,o[l+2]=b,o[l+3]=A,o[l+4]=T,o[l+5]=P,!0):!1}else{const h=l+8,x=r[l+6],m=h+p,g=x+p;let b=y,A=!1,T=!1;t?b||(A=t.has(m),T=t.has(g),b=!A&&!T):(A=!0,T=!0);const P=b||A,v=b||T;let M=!1;P&&(M=f(h,p,b));let S=!1;v&&(S=f(x,p,b));const E=M||S;if(E)for(let I=0;I<3;I++){const U=h+I,F=x+I,V=o[U],C=o[U+3],Z=o[F],$=o[F+3];o[l+I]=V<Z?V:Z,o[l+I+3]=C>$?C:$}return E}}}traverse(t,e=0){const s=this._roots[e],i=new Uint32Array(s),c=new Uint16Array(s);r(0);function r(u,o=0){const d=u*2,a=c[d+15]===Ct;if(a){const f=i[u+6],l=c[d+14];t(o,a,new Float32Array(s,u*4,6),f,l)}else{const f=u+At/4,l=i[u+6],p=i[u+7];t(o,a,new Float32Array(s,u*4,6),p)||(r(f,o+1),r(l,o+1))}}}raycast(t,e=Nt){const s=this._roots,i=this.geometry,c=[],r=e.isMaterial,u=Array.isArray(e),o=i.groups,d=r?e.side:e;for(let a=0,f=s.length;a<f;a++){const l=u?e[o[a].materialIndex].side:d,p=c.length;if(ct(s[a]),Vt(0,i,l,t,c),gt(),u){const y=o[a].materialIndex;for(let B=p,w=c.length;B<w;B++)c[B].face.materialIndex=y}}return c}raycastFirst(t,e=Nt){const s=this._roots,i=this.geometry,c=e.isMaterial,r=Array.isArray(e);let u=null;const o=i.groups,d=c?e.side:e;for(let a=0,f=s.length;a<f;a++){const l=r?e[o[a].materialIndex].side:d;ct(s[a]);const p=Lt(0,i,l,t);gt(),p!=null&&(u==null||p.distance<u.distance)&&(u=p,r&&(p.face.materialIndex=o[a].materialIndex))}return u}intersectsGeometry(t,e){const s=this.geometry;let i=!1;for(const c of this._roots)if(ct(c),i=Ne(0,s,t,e),gt(),i)break;return i}shapecast(t,e,s){const i=this.geometry;if(t instanceof Function){if(e){const l=e;e=(p,y,B,w)=>{const h=y*3;return l(p,h,h+1,h+2,B,w)}}t={boundsTraverseOrder:s,intersectsBounds:t,intersectsTriangle:e,intersectsRange:null},console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.")}const c=R.getPrimitive();let{boundsTraverseOrder:r,intersectsBounds:u,intersectsRange:o,intersectsTriangle:d}=t;if(o&&d){const l=o;o=(p,y,B,w,h)=>l(p,y,B,w,h)?!0:Kt(p,y,i,d,B,w,c)}else o||(d?o=(l,p,y,B)=>Kt(l,p,i,d,y,B,c):o=(l,p,y)=>y);let a=!1,f=0;for(const l of this._roots){if(ct(l),a=He(0,i,u,o,r,f),gt(),a)break;f+=l.byteLength}return R.releasePrimitive(c),a}bvhcast(t,e,s){let{intersectsRanges:i,intersectsTriangles:c}=s;const r=this.geometry.index,u=this.geometry.attributes.position,o=t.geometry.index,d=t.geometry.attributes.position;J.copy(e).invert();const a=R.getPrimitive(),f=R.getPrimitive();if(c){let p=function(y,B,w,h,x,m,g,b){for(let A=w,T=w+h;A<T;A++){D(f,A*3,o,d),f.a.applyMatrix4(e),f.b.applyMatrix4(e),f.c.applyMatrix4(e),f.needsUpdate=!0;for(let P=y,v=y+B;P<v;P++)if(D(a,P*3,r,u),a.needsUpdate=!0,c(a,f,P,A,x,m,g,b))return!0}return!1};if(i){const y=i;i=function(B,w,h,x,m,g,b,A){return y(B,w,h,x,m,g,b,A)?!0:p(B,w,h,x,m,g,b,A)}}else i=p}t.getBoundingBox(Ut),Ut.applyMatrix4(e);const l=this.shapecast({intersectsBounds:p=>Ut.intersectsBox(p),intersectsRange:(p,y,B,w,h,x)=>(zt.copy(x),zt.applyMatrix4(J),t.shapecast({intersectsBounds:m=>zt.intersectsBox(m),intersectsRange:(m,g,b,A,T)=>i(p,y,m,g,w,h,A,T)}))});return R.releasePrimitive(a),R.releasePrimitive(f),l}intersectsBox(t,e){return W.set(t.min,t.max,e),W.needsUpdate=!0,this.shapecast({intersectsBounds:s=>W.intersectsBox(s),intersectsTriangle:s=>W.intersectsTriangle(s)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,s={},i={},c=0,r=1/0){t.boundingBox||t.computeBoundingBox(),W.set(t.boundingBox.min,t.boundingBox.max,e),W.needsUpdate=!0;const u=this.geometry,o=u.attributes.position,d=u.index,a=t.attributes.position,f=t.index,l=R.getPrimitive(),p=R.getPrimitive();let y=wt,B=qe,w=null,h=null;i&&(w=Ge,h=ke);let x=1/0,m=null,g=null;return J.copy(e).invert(),ot.matrix.copy(J),this.shapecast({boundsTraverseOrder:b=>W.distanceToBox(b),intersectsBounds:(b,A,T)=>T<x&&T<r?(A&&(ot.min.copy(b.min),ot.max.copy(b.max),ot.needsUpdate=!0),!0):!1,intersectsRange:(b,A)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:T=>ot.distanceToBox(T),intersectsBounds:(T,P,v)=>v<x&&v<r,intersectsRange:(T,P)=>{for(let v=T*3,M=(T+P)*3;v<M;v+=3){D(p,v,f,a),p.a.applyMatrix4(e),p.b.applyMatrix4(e),p.c.applyMatrix4(e),p.needsUpdate=!0;for(let S=b*3,E=(b+A)*3;S<E;S+=3){D(l,S,d,o),l.needsUpdate=!0;const I=l.distanceToTriangle(p,y,w);if(I<x&&(B.copy(y),h&&h.copy(w),x=I,m=S/3,g=v/3),I<c)return!0}}}});{const T=f?f.count:a.count;for(let P=0,v=T;P<v;P+=3){D(p,P,f,a),p.a.applyMatrix4(e),p.b.applyMatrix4(e),p.c.applyMatrix4(e),p.needsUpdate=!0;for(let M=b*3,S=(b+A)*3;M<S;M+=3){D(l,M,d,o),l.needsUpdate=!0;const E=l.distanceToTriangle(p,y,w);if(E<x&&(B.copy(y),h&&h.copy(w),x=E,m=M/3,g=P/3),E<c)return!0}}}}}),R.releasePrimitive(l),R.releasePrimitive(p),x===1/0?null:(s.point?s.point.copy(B):s.point=B.clone(),s.distance=x,s.faceIndex=m,i&&(i.point?i.point.copy(h):i.point=h.clone(),i.point.applyMatrix4(J),B.applyMatrix4(J),i.distance=B.sub(i.point).length(),i.faceIndex=g),s)}closestPointToPoint(t,e={},s=0,i=1/0){const c=s*s,r=i*i;let u=1/0,o=null;if(this.shapecast({boundsTraverseOrder:a=>(rt.copy(t).clamp(a.min,a.max),rt.distanceToSquared(t)),intersectsBounds:(a,f,l)=>l<u&&l<r,intersectsTriangle:(a,f)=>{a.closestPointToPoint(t,rt);const l=t.distanceToSquared(rt);return l<u&&(wt.copy(rt),u=l,o=f),l<c}}),u===1/0)return null;const d=Math.sqrt(u);return e.point?e.point.copy(wt):e.point=wt.clone(),e.distance=d,e.faceIndex=o,e}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(s=>{L(0,new Float32Array(s),Jt),t.union(Jt)}),t}}const Qt=new Y;class Oe extends he{get isMesh(){return!this.displayEdges}get isLineSegments(){return this.displayEdges}get isLine(){return this.displayEdges}constructor(t,e,s=10,i=0){super(),this.material=e,this.geometry=new Dt,this.name="MeshBVHRootVisualizer",this.depth=s,this.displayParents=!1,this.mesh=t,this.displayEdges=!0,this._group=i}raycast(){}update(){const t=this.geometry,e=this.mesh.geometry.boundsTree,s=this._group;if(t.dispose(),this.visible=!1,e){const i=this.depth-1,c=this.displayParents;let r=0;e.traverse((l,p)=>{if(l===i||p)return r++,!0;c&&r++},s);let u=0;const o=new Float32Array(8*3*r);e.traverse((l,p,y)=>{const B=l===i||p;if(B||c){L(0,y,Qt);const{min:w,max:h}=Qt;for(let x=-1;x<=1;x+=2){const m=x<0?w.x:h.x;for(let g=-1;g<=1;g+=2){const b=g<0?w.y:h.y;for(let A=-1;A<=1;A+=2){const T=A<0?w.z:h.z;o[u+0]=m,o[u+1]=b,o[u+2]=T,u+=3}}}return B}},s);let d,a;this.displayEdges?a=new Uint8Array([0,4,1,5,2,6,3,7,0,2,1,3,4,6,5,7,0,1,2,3,4,5,6,7]):a=new Uint8Array([0,1,2,2,1,3,4,6,5,6,7,5,1,4,5,0,4,1,2,3,6,3,7,6,0,2,4,2,6,4,1,5,3,3,5,7]),o.length>65535?d=new Uint32Array(a.length*r):d=new Uint16Array(a.length*r);const f=a.length;for(let l=0;l<r;l++){const p=l*8,y=l*f;for(let B=0;B<f;B++)d[y+B]=p+a[B]}t.setIndex(new st(d,1,!1)),t.setAttribute("position",new st(o,3,!1)),this.visible=!0}}}class Ht extends fe{get color(){return this.edgeMaterial.color}get opacity(){return this.edgeMaterial.opacity}set opacity(t){this.edgeMaterial.opacity=t,this.meshMaterial.opacity=t}constructor(t,e=10){super(),this.name="MeshBVHVisualizer",this.depth=e,this.mesh=t,this.displayParents=!1,this.displayEdges=!0,this._roots=[];const s=new de({color:65416,transparent:!0,opacity:.3,depthWrite:!1}),i=new pe({color:65416,transparent:!0,opacity:.3,depthWrite:!1});i.color=s.color,this.edgeMaterial=s,this.meshMaterial=i,this.update()}update(){const t=this.mesh.geometry.boundsTree,e=t?t._roots.length:0;for(;this._roots.length>e;){const s=this._roots.pop();s.geometry.dispose(),this.remove(s)}for(let s=0;s<e;s++){if(s>=this._roots.length){const c=new Oe(this.mesh,this.edgeMaterial,this.depth,s);this.add(c),this._roots.push(c)}const i=this._roots[s];i.depth=this.depth,i.mesh=this.mesh,i.displayParents=this.displayParents,i.displayEdges=this.displayEdges,i.material=this.displayEdges?this.edgeMaterial:this.meshMaterial,i.update()}}updateMatrixWorld(...t){this.position.copy(this.mesh.position),this.rotation.copy(this.mesh.rotation),this.scale.copy(this.mesh.scale),super.updateMatrixWorld(...t)}copy(t){this.depth=t.depth,this.mesh=t.mesh}clone(){return new Ht(this.mesh,this.depth)}dispose(){this.edgeMaterial.dispose(),this.meshMaterial.dispose();const t=this.children;for(let e=0,s=t.length;e<s;e++)t[e].geometry.dispose()}}const ie=new Dt;ie.setAttribute("position",new st(new Float32Array([0,0,0,0,0,0,0,0,0]),3));class Xe{constructor(){dt(this,"bvh",new et(ie));dt(this,"visualizer");dt(this,"castOptions",{intersectsBounds:t=>!1,intersectsTriangle:()=>{}})}addBVH(t){const e=t.geometry.clone();e.applyMatrix4(t.matrixWorld);for(const s in e.attributes)s!=="position"&&e.deleteAttribute(s);this.bvh=new et(ye([this.bvh.geometry,e])),this.bvh.geometry.boundsTree=this.bvh,this.visualizer&&(this.visualizer.mesh.geometry=this.bvh.geometry,this.visualizer.update())}createVisualizer(){return this.visualizer=new Ht(new me(this.bvh.geometry)),this}shapecast(t){return this.bvh.shapecast(t||this.castOptions)}dispose(){var t;(t=this.visualizer)==null||t.dispose(),this.bvh.geometry.dispose()}}const je="@vis-three/mesh-bvh-plugin",We=ce(je),ts=function(n={}){return{name:We,install(t){const e=new Xe;n.visualizer&&(e.createVisualizer(),t.scene.add(e.visualizer)),n.shapecast&&(e.castOptions=n.shapecast),t.meshBVHManager=e,t.addBVH=function(s){return e.addBVH(s),t}},dispose(t){t.meshBVHManager.dispose(),delete t.meshBVHManager,delete t.addBVH}}};export{ts as M,Qe as l,ye as m};
