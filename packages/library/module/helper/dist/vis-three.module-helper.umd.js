(function(l,h){typeof exports=="object"&&typeof module!="undefined"?h(exports,require("@vis-three/middleware"),require("uuid"),require("@vis-three/core"),require("three"),require("@vis-three/convenient")):typeof define=="function"&&define.amd?define(["exports","@vis-three/middleware","uuid","@vis-three/core","three","@vis-three/convenient"],h):(l=typeof globalThis!="undefined"?globalThis:l||self,h((l["vis-three"]=l["vis-three"]||{},l["vis-three"]["module-helper"]={}),l.middleware,l.uuid,l.core,l.three,l.convenient))})(this,function(l,h,y,R,t,b){"use strict";var he=Object.defineProperty;var pe=(l,h,y)=>h in l?he(l,h,{enumerable:!0,configurable:!0,writable:!0,value:y}):l[h]=y;var s=(l,h,y)=>(pe(l,typeof h!="symbol"?h+"":h,y),y);class H extends h.Compiler{constructor(){super()}}const F=function(n,a,e=y.validate){h.Rule(n,a,e)},D=function(){return Object.assign(h.getSymbolConfig(),{})},G=function(){return Object.assign(D(),{target:"",shape:!0,boundingBox:!1,geometricOrigin:!1,localAxes:!1})},g=()=>new t.LineBasicMaterial({color:"rgb(255, 255, 255)"});class O extends t.LineSegments{constructor(e){super();s(this,"shape");s(this,"target");s(this,"type","CameraHelper");s(this,"cachaData");const i=new t.BufferGeometry,r=[0,0,0,-1,1,-1,0,0,0,-1,1,1,0,0,0,-1,-1,-1,0,0,0,-1,-1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,1,1,-1,1,1,-1,-1,1,0,0,0,0,1,1,0,0,0,0,1,-1,0,0,0,0,-1,-1,0,0,0,0,-1,1,0,1,1,0,1,-1,0,1,-1,0,-1,-1,0,-1,-1,0,-1,1,0,-1,1,0,1,1,0,-1,1,2,-1,1,0,1,-1,2,1,-1,0,-1,-1,2,-1,-1,0,1,1,2,1,1,2,1,1,2,-1,1,2,-1,1,2,-1,-1,2,-1,-1,2,1,-1,2,1,-1,2,1,1];i.setAttribute("position",new t.Float32BufferAttribute(r,3)),i.rotateY(-90*Math.PI/180),i.computeBoundingBox();const o=new t.CameraHelper(e);o.matrix=new t.Matrix4,o.matrixAutoUpdate=!0,o.raycast=()=>{},this.add(o),this.shape=o,this.geometry=i,this.material=g(),this.target=e,this.matrixAutoUpdate=!1,this.matrix=e.matrix,e instanceof t.PerspectiveCamera?this.cachaData={fov:e.fov,aspect:e.aspect,near:e.near,far:e.far}:e instanceof t.OrthographicCamera?this.cachaData={left:e.left,right:e.right,top:e.top,bottom:e.bottom,near:e.near,far:e.far}:this.cachaData={},this.onBeforeRender=()=>{let c=!1;const p=this.cachaData;Object.keys(p).forEach(m=>{p[m]!==e[m]&&(p[m]=e[m],c=!0)}),c&&this.shape.update()}}raycast(e,i){const r=this.matrixWorld,o=this.geometry.boundingBox.clone();if(o.applyMatrix4(r),e.ray.intersectsBox(o)){const c=this.target;i.push({distance:e.ray.origin.distanceTo(c.position),object:c,point:c.position})}}dispose(){this.geometry.dispose(),this.material.dispose(),this.shape.dispose()}}class L extends t.LineSegments{constructor(e){super();s(this,"sphere");s(this,"target");s(this,"shape");s(this,"type","VisDirectionalLightHelper");s(this,"cacheColor");s(this,"cacheVector3");this.geometry=new t.BufferGeometry;const i=[-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1,0,0,1,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,0,0,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,-.707,0,-.707,.707,0,.707,.707,0,-.707,-.707,0,.707];this.geometry.setAttribute("position",new t.Float32BufferAttribute(i,3)),this.material=g(),this.geometry.boundingSphere;const r=new t.Color().copy(e.color).multiplyScalar(e.intensity),o=new t.PlaneBufferGeometry(20,20);o.dispose();const c=new t.LineSegments(new t.EdgesGeometry(o),new t.LineBasicMaterial({color:r}));c.raycast=()=>{},this.shape=c,this.target=e,this.sphere=new t.Sphere(new t.Vector3(0,0,0),1),this.cacheColor=e.color.getHex(),this.cacheVector3=new t.Vector3,this.add(this.shape),this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.onBeforeRender=()=>{const p=this.target,m=this.shape;p.color.getHex()!==this.cacheColor&&(m.material.color.copy(p.color).multiplyScalar(p.intensity),this.cacheColor=p.color.getHex()),m.lookAt(p.target.position)}}raycast(e,i){const r=this.target,o=r.matrixWorld,c=this.sphere;c.set(this.cacheVector3.set(0,0,0),1),c.applyMatrix4(o),e.ray.intersectsSphere(c)&&i.push({distance:e.ray.origin.distanceTo(r.position),object:r,point:r.position})}dispose(){this.shape.geometry.dispose(),this.shape.material.dispose(),this.geometry.dispose(),this.material.dispose()}}class N extends t.LineSegments{constructor(e){super();s(this,"sphere");s(this,"target");s(this,"shape");s(this,"type","VisPointLightHelper");s(this,"cacheColor");s(this,"cacheDistance");s(this,"cacheVector3");this.geometry=new t.BufferGeometry;const i=[-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1,0,0,1,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,0,0,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,-.707,0,-.707,.707,0,.707,.707,0,-.707,-.707,0,.707];this.geometry.setAttribute("position",new t.Float32BufferAttribute(i,3)),this.material=g(),this.geometry.boundingSphere;const r=new t.Color().copy(e.color).multiplyScalar(e.intensity),o=new t.Mesh(new t.OctahedronBufferGeometry(e.distance,0),new t.MeshBasicMaterial({color:r,wireframe:!0}));o.raycast=()=>{},o.matrixAutoUpdate=!1,this.shape=o,this.target=e,this.sphere=new t.Sphere(new t.Vector3(0,0,0),1),this.cacheColor=e.color.getHex(),this.cacheDistance=e.distance,this.cacheVector3=new t.Vector3,this.add(this.shape),this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.onBeforeRender=()=>{const c=this.target,p=this.shape;c.distance!==this.cacheDistance&&(p.geometry.dispose(),p.geometry=new t.OctahedronBufferGeometry(c.distance,0),this.cacheDistance=c.distance),c.color.getHex()!==this.cacheColor&&(p.material.color.copy(c.color).multiplyScalar(c.intensity),this.cacheColor=c.color.getHex())}}raycast(e,i){const r=this.target,o=r.matrixWorld,c=this.sphere;c.set(this.cacheVector3.set(0,0,0),1),c.applyMatrix4(o),e.ray.intersectsSphere(c)&&i.push({distance:e.ray.origin.distanceTo(r.position),object:r,point:r.position})}dispose(){this.shape.geometry.dispose(),this.shape.material.dispose(),this.geometry.dispose(),this.material.dispose()}}class I extends t.LineSegments{constructor(e){super();s(this,"target");s(this,"type","VisRectAreaLightHelper");s(this,"cacheBox",new t.Box3);s(this,"cacheVector3",new t.Vector3);s(this,"cacheColor");s(this,"cacheIntensity");this.target=e,this.generateShape();const i=g();i.color.copy(e.color).multiplyScalar(e.intensity),this.cacheColor=e.color.getHex(),this.cacheIntensity=e.intensity,this.material=i,this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.onBeforeRender=()=>{const r=this.target;(r.width!==this.geometry.parameters.width||r.height!==this.geometry.parameters.height)&&this.generateShape(),(r.color.getHex()!==this.cacheColor||this.cacheIntensity!==r.intensity)&&(this.material.color.copy(r.color).multiplyScalar(r.intensity),this.cacheColor=r.color.getHex())}}generateShape(){this.geometry.dispose(),this.geometry=new t.PlaneBufferGeometry(this.target.width,this.target.height,4,4),this.geometry.computeBoundingBox()}raycast(e,i){const r=this.target,o=this.cacheBox;o.copy(this.geometry.boundingBox),o.applyMatrix4(r.matrixWorld),e.ray.intersectBox(o,this.cacheVector3)&&i.push({distance:e.ray.origin.distanceTo(r.position),object:r,point:r.position})}dispose(){this.geometry.dispose(),this.material.dispose()}}class $ extends t.LineSegments{constructor(e){super();s(this,"sphere");s(this,"target");s(this,"shape");s(this,"type","VisSpotLightHelper");s(this,"cacheVector3");s(this,"cacheColor");s(this,"cacheAngle");s(this,"cacheDistance");this.geometry=new t.BufferGeometry;const i=[-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1,0,0,1,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,0,0,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,-.707,0,-.707,.707,0,.707,.707,0,-.707,-.707,0,.707];this.geometry.setAttribute("position",new t.Float32BufferAttribute(i,3)),this.material=g(),this.geometry.boundingSphere;const r=new t.BufferGeometry,o=[0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let d=0,x=1,f=32;d<f;d++,x++){const v=d/f*Math.PI*2,E=x/f*Math.PI*2;o.push(Math.cos(v),Math.sin(v),1,Math.cos(E),Math.sin(E),1)}r.setAttribute("position",new t.Float32BufferAttribute(o,3));const c=g(),p=new t.LineSegments(r,c);p.material.color.copy(e.color).multiplyScalar(e.intensity);const m=e.distance?e.distance:1e3,T=m*Math.tan(e.angle);p.scale.set(T,T,m),p.raycast=()=>{},this.add(p),this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.target=e,this.shape=p,this.sphere=new t.Sphere(new t.Vector3(0,0,0),1),this.cacheColor=e.color.getHex(),this.cacheDistance=e.distance,this.cacheAngle=e.angle,this.cacheVector3=new t.Vector3,this.onBeforeRender=()=>{const d=this.target,x=this.shape;let f=!1;if(d.distance!==this.cacheDistance&&(this.cacheDistance=d.distance,x.scale.z=d.distance,f=!0),d.angle!==this.cacheAngle&&(this.cacheAngle=d.angle,f=!0),f){const v=d.distance*Math.tan(d.angle);x.scale.set(v,v,d.distance)}d.color.getHex()!==this.cacheColor&&(x.material.color.copy(d.color).multiplyScalar(d.intensity),this.cacheColor=d.color.getHex()),x.lookAt(d.target.position)}}raycast(e,i){const r=this.target,o=r.matrixWorld,c=this.sphere;c.set(this.cacheVector3.set(0,0,0),1),c.applyMatrix4(o),e.ray.intersectsSphere(c)&&i.push({distance:e.ray.origin.distanceTo(r.position),object:r,point:r.position})}dispose(){this.shape.geometry.dispose(),this.shape.material.dispose(),this.geometry.dispose(),this.material.dispose()}}const A=class extends t.Points{constructor(e){super();s(this,"target");s(this,"type","GeometricOriginHelper");this.target=e,this.geometry=new t.BufferGeometry().setAttribute("position",new t.BufferAttribute(new Float32Array([0,0,0]),3)),this.material=new t.PointsMaterial({map:A.colorTexture,transparent:!0,alphaTest:.1,depthFunc:t.AlwaysDepth,size:10,sizeAttenuation:!1}),this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.renderOrder=100,this.raycast=()=>{}}dispose(){}};let w=A;s(w,"colorTexture",new t.CanvasTexture(new b.CanvasGenerator({width:32,height:32}).draw(e=>{e.beginPath(),e.fillStyle="rgba(0, 0, 0, 0)",e.fillRect(0,0,32,32),e.closePath(),e.beginPath(),e.fillStyle="rgb(255, 163, 0)",e.strokeStyle="black",e.lineWidth=1,e.arc(16,16,15,0,2*Math.PI),e.stroke(),e.fill(),e.closePath()}).get()));class _ extends t.LineSegments{constructor(e){const i=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),r=new Float32Array(8*3),o=new t.BufferGeometry;o.setIndex(new t.BufferAttribute(i,1)),o.setAttribute("position",new t.BufferAttribute(r,3));super(o,new t.LineBasicMaterial({color:15662848,toneMapped:!1}));s(this,"target");s(this,"type","BoundingBoxHelper");s(this,"cacheBox",new t.Box3);s(this,"compareBox",new t.Box3);this.matrixAutoUpdate=!1,this.raycast=()=>{},this.target=e,this.onBeforeRender=()=>{this.update()}}update(){if(this.cacheBox.setFromObject(this.target),this.cacheBox.isEmpty()||this.cacheBox.equals(this.compareBox))return;this.compareBox.copy(this.cacheBox);const e=this.cacheBox.min,i=this.cacheBox.max,r=this.geometry.attributes.position,o=r.array;o[0]=i.x,o[1]=i.y,o[2]=i.z,o[3]=e.x,o[4]=i.y,o[5]=i.z,o[6]=e.x,o[7]=e.y,o[8]=i.z,o[9]=i.x,o[10]=e.y,o[11]=i.z,o[12]=i.x,o[13]=i.y,o[14]=e.z,o[15]=e.x,o[16]=i.y,o[17]=e.z,o[18]=e.x,o[19]=e.y,o[20]=e.z,o[21]=i.x,o[22]=e.y,o[23]=e.z,r.needsUpdate=!0,this.geometry.computeBoundingSphere()}dispose(){}}class k extends t.LineSegments{constructor(e){let i=5;if(e.geometry){const m=e.geometry;!m.boundingSphere&&m.computeBoundingSphere(),i=m.boundingSphere.radius*.8}const r=[0,0,0,i,0,0,0,0,0,0,i,0,0,0,0,0,0,i],o=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],c=new t.BufferGeometry;c.setAttribute("position",new t.Float32BufferAttribute(r,3)),c.setAttribute("color",new t.Float32BufferAttribute(o,3));const p=new t.LineBasicMaterial({vertexColors:!0,toneMapped:!1,depthFunc:t.AlwaysDepth});super(c,p);s(this,"target");this.target=e,this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.renderOrder=100,this.raycast=()=>{}}dispose(){}}const q=`

#include <common>

void main() {
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

  bool isPerspective = isPerspectiveMatrix( projectionMatrix );

  if ( isPerspective ) scale *= - mvPosition.z;

	vec2 alignedPosition = position.xy * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( 0.0 ) * alignedPosition.x - sin( 0.0 ) * alignedPosition.y;
	rotatedPosition.y = sin( 0.0 ) * alignedPosition.x + cos( 0.0 ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

}

`,Y=`

uniform vec3 color;

void main() {
  gl_FragColor = vec4(color, 1.0);
}
`;class J extends t.ShaderMaterial{constructor(){super(),this.vertexShader=q,this.fragmentShader=Y,this.uniforms={color:{value:new t.Color("white")}}}}class K extends t.LineSegments{constructor(e){super();s(this,"target");s(this,"type","VisCSS2DPlaneHelper");s(this,"observer");this.geometry=new t.EdgesGeometry(new t.PlaneBufferGeometry(1,1)),this.geometry.computeBoundingBox(),this.material=new J,this.scale.copy(e.matrixScale),this.position.set(e.position.x,e.position.y,e.position.z),this.target=e;const i=new MutationObserver(()=>{this.scale.copy(e.matrixScale)});i.observe(e.element,{attributeFilter:["style"]}),this.observer=i,this.onBeforeRender=()=>{this.position.set(this.target.position.x,this.target.position.y,this.target.position.z)},this.raycast=()=>{}}dispose(){this.observer.disconnect()}}class Q extends t.LineSegments{constructor(e){super();s(this,"target");s(this,"type","VisCSS3DPlaneHelper");s(this,"observer");this.geometry=new t.EdgesGeometry(new t.PlaneBufferGeometry(e.width,e.height)),this.geometry.computeBoundingBox(),this.material=g(),this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.target=e;const i=new MutationObserver(()=>{this.geometry.dispose(),this.geometry=new t.EdgesGeometry(new t.PlaneBufferGeometry(e.width,e.height)),this.geometry.computeBoundingBox()});i.observe(e.element,{attributeFilter:["style"]}),this.observer=i,this.raycast=()=>{},this.updateMatrixWorld=()=>{}}dispose(){this.observer.disconnect()}}const X=`
uniform float rotation2D;

#include <common>

void main() {
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

	vec2 alignedPosition = position.xy * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation2D ) * alignedPosition.x - sin( rotation2D ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation2D ) * alignedPosition.x + cos( rotation2D ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

}

`,Z=`

uniform vec3 color;

void main() {
  gl_FragColor = vec4(color, 1.0);
}
`;class ee extends t.ShaderMaterial{constructor(){super(),this.vertexShader=X,this.fragmentShader=Z,this.uniforms={color:{value:new t.Color("white")},rotation2D:{value:0}}}}class te extends t.LineSegments{constructor(e){super();s(this,"target");s(this,"type","VisCSS3DSpriteHelper");s(this,"observer");this.geometry=new t.EdgesGeometry(new t.PlaneBufferGeometry(1,1)),this.geometry.computeBoundingBox(),this.material=new ee,this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.target=e;const i=new MutationObserver(()=>{this.geometry.dispose(),this.geometry=new t.EdgesGeometry(new t.PlaneBufferGeometry(e.width,e.height)),this.geometry.computeBoundingBox()});i.observe(e.element,{attributeFilter:["style"]}),this.observer=i,this.onBeforeRender=()=>{this.material.uniforms.rotation2D.value=this.target.rotation2D},this.raycast=()=>{},this.updateMatrixWorld=()=>{}}dispose(){this.observer.disconnect()}}const C=class extends t.Sprite{constructor(e){super();s(this,"target");s(this,"type","VisGroupHelper");this.target=e,this.geometry.computeBoundingBox(),this.material=new t.SpriteMaterial({map:C.colorTexture}),this.material.depthTest=!1,this.material.depthWrite=!1,this.scale.set(5,5,5);const i=this.updateMatrixWorld.bind(this);this.updateMatrixWorld=r=>{const o=this.position,c=this.target.position;o.x=c.x,o.y=c.y,o.z=c.z,i(r)}}raycast(e,i){const r=this.matrixWorld,o=this.geometry.boundingBox.clone();if(o.applyMatrix4(r),e.ray.intersectsBox(o)){const c=this.target;i.push({distance:e.ray.origin.distanceTo(c.position),object:c,point:c.position})}}dispose(){this.geometry.dispose(),this.material.dispose()}};let B=C;s(B,"colorTexture",new t.CanvasTexture(new b.CanvasGenerator({width:512,height:512}).draw(e=>{e.beginPath(),e.fillStyle="rgba(0, 0, 0, 0)",e.fillRect(0,0,512,512),e.closePath(),e.translate(256,200),e.beginPath(),e.fillStyle="yellow",e.fillRect(-200,0,400,200),e.closePath(),e.beginPath(),e.fillStyle="yellow",e.fillRect(-200,-70,200,70),e.closePath()}).get()));const W=class extends t.Points{constructor(e){super();s(this,"target");s(this,"cachaGeometryUUid");s(this,"type","VisLineHelper");this.target=e,this.geometry.dispose(),this.geometry.copy(e.geometry),this.cachaGeometryUUid=e.geometry.uuid,this.material=new t.PointsMaterial({color:"rgb(255, 255, 255)",alphaMap:W.alphaTexture,transparent:!0,size:5,sizeAttenuation:!1}),this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.renderOrder=-1,this.raycast=()=>{},this.onBeforeRender=()=>{const i=this.target;i.geometry.uuid!==this.cachaGeometryUUid&&(this.geometry.dispose(),this.geometry=i.geometry.clone(),this.cachaGeometryUUid=i.geometry.uuid)}}dispose(){this.geometry.dispose(),this.material.dispose()}};let P=W;s(P,"alphaTexture",new t.CanvasTexture(new b.CanvasGenerator({width:512,height:512,bgColor:"rgb(0, 0, 0)"}).draw(e=>{e.beginPath(),e.fillStyle="rgb(255, 255, 255)",e.arc(256,256,200,0,Math.PI*2),e.fill(),e.closePath()}).getDom()));class ie extends t.LineSegments{constructor(e){super();s(this,"target");s(this,"type","VisMeshHelper");s(this,"cachaGeometryUUid");const i=1;this.target=e,this.geometry=new t.EdgesGeometry(e.geometry,i),this.cachaGeometryUUid=e.geometry.uuid,this.material=g(),this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.updateMatrixWorld=()=>{},this.raycast=()=>{},this.onBeforeRender=()=>{const r=this.target;r.geometry.uuid!==this.cachaGeometryUUid&&(this.geometry.dispose(),this.geometry=new t.EdgesGeometry(r.geometry,i),this.cachaGeometryUUid=r.geometry.uuid)}}dispose(){this.geometry.dispose(),this.material.dispose()}}const U=class extends t.Points{constructor(e){super();s(this,"target");s(this,"type","VisPointsHelper");this.target=e,this.geometry.dispose(),this.geometry.copy(e.geometry),this.material.dispose(),this.material=new t.PointsMaterial({color:"rgb(255, 255, 255)",alphaMap:U.alphaTexture,transparent:!0});const i=Array.isArray(e.material)?e.material[0]:e.material;i instanceof t.PointsMaterial&&(this.material.size=i.size,this.material.sizeAttenuation=i.sizeAttenuation),this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.raycast=()=>{}}dispose(){this.geometry.dispose(),this.material.dispose()}};let S=U;s(S,"alphaTexture",new t.CanvasTexture(new b.CanvasGenerator({width:512,height:512,bgColor:"rgb(0, 0, 0)"}).draw(e=>{e.beginPath(),e.strokeStyle="rgb(255, 255, 255)",e.lineWidth=4,e.strokeRect(0,0,512,512),e.closePath()}).get()));const se=`

uniform float rotation;
uniform vec2 center;
uniform bool sizeAttenuation;

#include <common>

void main() {
  vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

	if (!sizeAttenuation) {
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );

		if ( isPerspective ) scale *= - mvPosition.z;
  }

	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

}

`,oe=`

uniform vec3 color;

void main() {
  gl_FragColor = vec4(color, 1.0);
}
`;class re extends t.ShaderMaterial{constructor(){super(),this.vertexShader=se,this.fragmentShader=oe,this.uniforms={color:{value:new t.Color("white")},center:{value:new t.Vector2(.5,.5)},rotation:{value:0},sizeAttenuation:{value:!1}}}}class ae extends t.LineSegments{constructor(e){super();s(this,"target");s(this,"type","VisSpriteHelper");this.geometry=new t.EdgesGeometry(new t.PlaneBufferGeometry(1,1)),this.geometry.computeBoundingBox(),this.material=new re,this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.target=e,this.onBeforeRender=()=>{this.material.uniforms.rotation.value=this.target.material.rotation,this.material.uniforms.sizeAttenuation.value=this.target.material.sizeAttenuation},this.raycast=()=>{}}dispose(){this.geometry.dispose(),this.material.dispose()}}const V=function(n){return n},z={add:{helper(){}},set:{helper(){}}};class ne extends R.EventDispatcher{constructor(){super();s(this,"target");s(this,"shape");s(this,"boundingBox");s(this,"geometricOrigin");s(this,"localAxes");s(this,"shapeMap",{PointLight:N,SpotLight:$,DirectionalLight:L,RectAreaLight:I,PerspectiveCamera:O,OrthographicCamera:O,Mesh:ie,Group:B,Sprite:ae,Points:S,Line:P,CSS3DPlane:Q,CSS3DSprite:te,CSS2DPlane:K})}generateShape(){if(this.target){if(!this.shapeMap[this.target.type]){console.warn(`object helper can not support ${this.target.type}`);return}const e=new this.shapeMap[this.target.type](this.target);this.shape=e}}generateBoundingBox(){if(this.target){const e=new _(this.target);this.boundingBox=e}}generateGeometricOrigin(){if(this.target){const e=new w(this.target);this.geometricOrigin=e}}generateLocalAxes(){if(this.target){const e=new k(this.target);this.localAxes=e}}dispose(e){if(e&&this[e]){this[e].dispose(),this[e]=void 0;return}this.target=void 0,this.shape&&(this.shape.dispose(),this.shape=void 0),this.boundingBox&&(this.boundingBox.dispose(),this.boundingBox=void 0),this.geometricOrigin&&(this.geometricOrigin.dispose(),this.geometricOrigin=void 0),this.localAxes&&(this.localAxes.dispose(),this.localAxes=void 0)}}const j=new WeakMap,u=function(n,a,e){const i=e.getObjectBySymbol(a.target);if(!i){console.warn(`object helper processor can not fund object: ${a.target}`);return}i.parent.add(n);const r=()=>{i.parent.add(n)};h.Bus.compilerEvent.on(i,`${h.COMPILER_EVENT.UPDATE}:parent`,r),j.set(i,r)},M=function(n,a,e,i){const r=i.getObjectBySymbol(a.target);if(!r){console.warn(`object helper processor can not fund object: ${a.target}`);return}e[n].removeFromParent();const o=j.get(r);o&&h.Bus.compilerEvent.off(r,`${h.COMPILER_EVENT.UPDATE}:parent`,o),e.dispose(n)};var ce=h.defineProcessor({type:"ObjectHelper",config:G,commands:{set:{shape({config:n,target:a,value:e,engine:i}){e&&!a.shape?(a.generateShape(),u(a.shape,n,i)):!e&&a.shape&&M("shape",n,a,i)},boundingBox({config:n,target:a,value:e,engine:i}){e&&!a.boundingBox?(a.generateBoundingBox(),u(a.boundingBox,n,i)):!e&&a.boundingBox&&M("boundingBox",n,a,i)},geometricOrigin({config:n,target:a,value:e,engine:i}){e&&!a.geometricOrigin?(a.generateGeometricOrigin(),u(a.geometricOrigin,n,i)):!e&&a.geometricOrigin&&M("geometricOrigin",n,a,i)},localAxes({config:n,target:a,value:e,engine:i}){e&&!a.localAxes?(a.generateLocalAxes(),u(a.localAxes,n,i)):!e&&a.localAxes&&M("localAxes",n,a,i)}}},create(n,a){const e=new ne;if(n.target){const i=a.getObjectBySymbol(n.target),r=V(a.getConfigBySymbol(n.target));r.helper=n.vid,i?(e.target=i,n.shape&&(e.generateShape(),u(e.shape,n,a)),n.boundingBox&&(e.generateBoundingBox(),u(e.boundingBox,n,a)),n.geometricOrigin&&(e.generateGeometricOrigin(),u(e.geometricOrigin,n,a)),n.localAxes&&(e.generateLocalAxes(),u(e.localAxes,n,a))):console.warn(`object helper processor can not found target in engine ${n.target}`)}return e},dispose(n){n.dispose()}}),le={type:"helper",compiler:H,rule:F,processors:[ce],lifeOrder:h.SUPPORT_LIFE_CYCLE.FOUR,expand:[{processors:new RegExp("Mesh|Light|Line|Points|Group|Object3D"),command:z}]};l.HelperCompiler=H,l.default=le,l.expandCommand=z,l.getHelperConfig=D,l.getHelperExpandConfig=V,l.getObjectHelperConfig=G,Object.defineProperties(l,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
