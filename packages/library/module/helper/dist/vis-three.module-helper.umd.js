(function(l,m){typeof exports=="object"&&typeof module!="undefined"?module.exports=m(require("@vis-three/middleware"),require("uuid"),require("@vis-three/core"),require("three"),require("@vis-three/convenient")):typeof define=="function"&&define.amd?define(["@vis-three/middleware","uuid","@vis-three/core","three","@vis-three/convenient"],m):(l=typeof globalThis!="undefined"?globalThis:l||self,l["vis-three"]=l["vis-three"]||{},l["vis-three"]["module-helper"]=m(l.middleware,l.uuid,l.core,l.three,l.convenient))})(this,function(l,m,y,t,v){"use strict";var ne=Object.defineProperty;var ce=(l,m,y)=>m in l?ne(l,m,{enumerable:!0,configurable:!0,writable:!0,value:y}):l[m]=y;var s=(l,m,y)=>(ce(l,typeof m!="symbol"?m+"":m,y),y);class V extends l.Compiler{constructor(){super()}}const z=function(n,a,e=m.validate){l.Rule(n,a,e)},j=function(){return Object.assign(l.getSymbolConfig(),{})},T=function(){return Object.assign(j(),{target:"",shape:!0,boundingBox:!1,geometricOrigin:!1,localAxes:!1})},g=()=>new t.LineBasicMaterial({color:"rgb(255, 255, 255)"});class H extends t.LineSegments{constructor(e){super();s(this,"shape");s(this,"target");s(this,"type","CameraHelper");s(this,"cachaData");const i=new t.BufferGeometry,r=[0,0,0,-1,1,-1,0,0,0,-1,1,1,0,0,0,-1,-1,-1,0,0,0,-1,-1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,1,1,-1,1,1,-1,-1,1,0,0,0,0,1,1,0,0,0,0,1,-1,0,0,0,0,-1,-1,0,0,0,0,-1,1,0,1,1,0,1,-1,0,1,-1,0,-1,-1,0,-1,-1,0,-1,1,0,-1,1,0,1,1,0,-1,1,2,-1,1,0,1,-1,2,1,-1,0,-1,-1,2,-1,-1,0,1,1,2,1,1,2,1,1,2,-1,1,2,-1,1,2,-1,-1,2,-1,-1,2,1,-1,2,1,-1,2,1,1];i.setAttribute("position",new t.Float32BufferAttribute(r,3)),i.rotateY(-90*Math.PI/180),i.computeBoundingBox();const o=new t.CameraHelper(e);o.matrix=new t.Matrix4,o.matrixAutoUpdate=!0,o.raycast=()=>{},this.add(o),this.shape=o,this.geometry=i,this.material=g(),this.target=e,this.matrixAutoUpdate=!1,this.matrix=e.matrix,e instanceof t.PerspectiveCamera?this.cachaData={fov:e.fov,aspect:e.aspect,near:e.near,far:e.far}:e instanceof t.OrthographicCamera?this.cachaData={left:e.left,right:e.right,top:e.top,bottom:e.bottom,near:e.near,far:e.far}:this.cachaData={},this.onBeforeRender=()=>{let c=!1;const h=this.cachaData;Object.keys(h).forEach(d=>{h[d]!==e[d]&&(h[d]=e[d],c=!0)}),c&&this.shape.update()}}raycast(e,i){const r=this.matrixWorld,o=this.geometry.boundingBox.clone();if(o.applyMatrix4(r),e.ray.intersectsBox(o)){const c=this.target;i.push({distance:e.ray.origin.distanceTo(c.position),object:c,point:c.position})}}dispose(){this.geometry.dispose(),this.material.dispose(),this.shape.dispose()}}class E extends t.LineSegments{constructor(e){super();s(this,"sphere");s(this,"target");s(this,"shape");s(this,"type","VisDirectionalLightHelper");s(this,"cacheColor");s(this,"cacheVector3");this.geometry=new t.BufferGeometry;const i=[-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1,0,0,1,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,0,0,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,-.707,0,-.707,.707,0,.707,.707,0,-.707,-.707,0,.707];this.geometry.setAttribute("position",new t.Float32BufferAttribute(i,3)),this.material=g(),this.geometry.boundingSphere;const r=new t.Color().copy(e.color).multiplyScalar(e.intensity),o=new t.PlaneBufferGeometry(20,20);o.dispose();const c=new t.LineSegments(new t.EdgesGeometry(o),new t.LineBasicMaterial({color:r}));c.raycast=()=>{},this.shape=c,this.target=e,this.sphere=new t.Sphere(new t.Vector3(0,0,0),1),this.cacheColor=e.color.getHex(),this.cacheVector3=new t.Vector3,this.add(this.shape),this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.onBeforeRender=()=>{const h=this.target,d=this.shape;h.color.getHex()!==this.cacheColor&&(d.material.color.copy(h.color).multiplyScalar(h.intensity),this.cacheColor=h.color.getHex()),d.lookAt(h.target.position)}}raycast(e,i){const r=this.target,o=r.matrixWorld,c=this.sphere;c.set(this.cacheVector3.set(0,0,0),1),c.applyMatrix4(o),e.ray.intersectsSphere(c)&&i.push({distance:e.ray.origin.distanceTo(r.position),object:r,point:r.position})}dispose(){this.shape.geometry.dispose(),this.shape.material.dispose(),this.geometry.dispose(),this.material.dispose()}}class R extends t.LineSegments{constructor(e){super();s(this,"sphere");s(this,"target");s(this,"shape");s(this,"type","VisPointLightHelper");s(this,"cacheColor");s(this,"cacheDistance");s(this,"cacheVector3");this.geometry=new t.BufferGeometry;const i=[-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1,0,0,1,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,0,0,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,-.707,0,-.707,.707,0,.707,.707,0,-.707,-.707,0,.707];this.geometry.setAttribute("position",new t.Float32BufferAttribute(i,3)),this.material=g(),this.geometry.boundingSphere;const r=new t.Color().copy(e.color).multiplyScalar(e.intensity),o=new t.Mesh(new t.OctahedronBufferGeometry(e.distance,0),new t.MeshBasicMaterial({color:r,wireframe:!0}));o.raycast=()=>{},o.matrixAutoUpdate=!1,this.shape=o,this.target=e,this.sphere=new t.Sphere(new t.Vector3(0,0,0),1),this.cacheColor=e.color.getHex(),this.cacheDistance=e.distance,this.cacheVector3=new t.Vector3,this.add(this.shape),this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.onBeforeRender=()=>{const c=this.target,h=this.shape;c.distance!==this.cacheDistance&&(h.geometry.dispose(),h.geometry=new t.OctahedronBufferGeometry(c.distance,0),this.cacheDistance=c.distance),c.color.getHex()!==this.cacheColor&&(h.material.color.copy(c.color).multiplyScalar(c.intensity),this.cacheColor=c.color.getHex())}}raycast(e,i){const r=this.target,o=r.matrixWorld,c=this.sphere;c.set(this.cacheVector3.set(0,0,0),1),c.applyMatrix4(o),e.ray.intersectsSphere(c)&&i.push({distance:e.ray.origin.distanceTo(r.position),object:r,point:r.position})}dispose(){this.shape.geometry.dispose(),this.shape.material.dispose(),this.geometry.dispose(),this.material.dispose()}}class F extends t.LineSegments{constructor(e){super();s(this,"target");s(this,"type","VisRectAreaLightHelper");s(this,"cacheBox",new t.Box3);s(this,"cacheVector3",new t.Vector3);s(this,"cacheColor");s(this,"cacheIntensity");this.target=e,this.generateShape();const i=g();i.color.copy(e.color).multiplyScalar(e.intensity),this.cacheColor=e.color.getHex(),this.cacheIntensity=e.intensity,this.material=i,this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.onBeforeRender=()=>{const r=this.target;(r.width!==this.geometry.parameters.width||r.height!==this.geometry.parameters.height)&&this.generateShape(),(r.color.getHex()!==this.cacheColor||this.cacheIntensity!==r.intensity)&&(this.material.color.copy(r.color).multiplyScalar(r.intensity),this.cacheColor=r.color.getHex())}}generateShape(){this.geometry.dispose(),this.geometry=new t.PlaneBufferGeometry(this.target.width,this.target.height,4,4),this.geometry.computeBoundingBox()}raycast(e,i){const r=this.target,o=this.cacheBox;o.copy(this.geometry.boundingBox),o.applyMatrix4(r.matrixWorld),e.ray.intersectBox(o,this.cacheVector3)&&i.push({distance:e.ray.origin.distanceTo(r.position),object:r,point:r.position})}dispose(){this.geometry.dispose(),this.material.dispose()}}class N extends t.LineSegments{constructor(e){super();s(this,"sphere");s(this,"target");s(this,"shape");s(this,"type","VisSpotLightHelper");s(this,"cacheVector3");s(this,"cacheColor");s(this,"cacheAngle");s(this,"cacheDistance");this.geometry=new t.BufferGeometry;const i=[-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1,0,0,1,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,0,0,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,-.707,0,-.707,.707,0,.707,.707,0,-.707,-.707,0,.707];this.geometry.setAttribute("position",new t.Float32BufferAttribute(i,3)),this.material=g(),this.geometry.boundingSphere;const r=new t.BufferGeometry,o=[0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let p=0,x=1,f=32;p<f;p++,x++){const w=p/f*Math.PI*2,O=x/f*Math.PI*2;o.push(Math.cos(w),Math.sin(w),1,Math.cos(O),Math.sin(O),1)}r.setAttribute("position",new t.Float32BufferAttribute(o,3));const c=g(),h=new t.LineSegments(r,c);h.material.color.copy(e.color).multiplyScalar(e.intensity);const d=e.distance?e.distance:1e3,G=d*Math.tan(e.angle);h.scale.set(G,G,d),h.raycast=()=>{},this.add(h),this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.target=e,this.shape=h,this.sphere=new t.Sphere(new t.Vector3(0,0,0),1),this.cacheColor=e.color.getHex(),this.cacheDistance=e.distance,this.cacheAngle=e.angle,this.cacheVector3=new t.Vector3,this.onBeforeRender=()=>{const p=this.target,x=this.shape;let f=!1;if(p.distance!==this.cacheDistance&&(this.cacheDistance=p.distance,x.scale.z=p.distance,f=!0),p.angle!==this.cacheAngle&&(this.cacheAngle=p.angle,f=!0),f){const w=p.distance*Math.tan(p.angle);x.scale.set(w,w,p.distance)}p.color.getHex()!==this.cacheColor&&(x.material.color.copy(p.color).multiplyScalar(p.intensity),this.cacheColor=p.color.getHex()),x.lookAt(p.target.position)}}raycast(e,i){const r=this.target,o=r.matrixWorld,c=this.sphere;c.set(this.cacheVector3.set(0,0,0),1),c.applyMatrix4(o),e.ray.intersectsSphere(c)&&i.push({distance:e.ray.origin.distanceTo(r.position),object:r,point:r.position})}dispose(){this.shape.geometry.dispose(),this.shape.material.dispose(),this.geometry.dispose(),this.material.dispose()}}const A=class extends t.Points{constructor(e){super();s(this,"target");s(this,"type","GeometricOriginHelper");this.target=e,this.geometry=new t.BufferGeometry().setAttribute("position",new t.BufferAttribute(new Float32Array([0,0,0]),3)),this.material=new t.PointsMaterial({map:A.colorTexture,transparent:!0,alphaTest:.1,depthFunc:t.AlwaysDepth}),this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.renderOrder=100,this.raycast=()=>{}}dispose(){}};let b=A;s(b,"colorTexture",new t.CanvasTexture(new v.CanvasGenerator({width:32,height:32}).draw(e=>{e.beginPath(),e.fillStyle="rgba(0, 0, 0, 0)",e.fillRect(0,0,32,32),e.closePath(),e.beginPath(),e.fillStyle="rgb(255, 163, 0)",e.strokeStyle="black",e.lineWidth=1,e.arc(16,16,15,0,2*Math.PI),e.stroke(),e.fill(),e.closePath()}).get()));class I extends t.LineSegments{constructor(e){const i=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),r=new Float32Array(8*3),o=new t.BufferGeometry;o.setIndex(new t.BufferAttribute(i,1)),o.setAttribute("position",new t.BufferAttribute(r,3));super(o,new t.LineBasicMaterial({color:15662848,toneMapped:!1}));s(this,"target");s(this,"type","BoundingBoxHelper");s(this,"cacheBox",new t.Box3);s(this,"compareBox",new t.Box3);this.matrixAutoUpdate=!1,this.raycast=()=>{},this.target=e,this.onBeforeRender=()=>{this.update()}}update(){if(this.cacheBox.setFromObject(this.target),this.cacheBox.isEmpty()||this.cacheBox.equals(this.compareBox))return;this.compareBox.copy(this.cacheBox);const e=this.cacheBox.min,i=this.cacheBox.max,r=this.geometry.attributes.position,o=r.array;o[0]=i.x,o[1]=i.y,o[2]=i.z,o[3]=e.x,o[4]=i.y,o[5]=i.z,o[6]=e.x,o[7]=e.y,o[8]=i.z,o[9]=i.x,o[10]=e.y,o[11]=i.z,o[12]=i.x,o[13]=i.y,o[14]=e.z,o[15]=e.x,o[16]=i.y,o[17]=e.z,o[18]=e.x,o[19]=e.y,o[20]=e.z,o[21]=i.x,o[22]=e.y,o[23]=e.z,r.needsUpdate=!0,this.geometry.computeBoundingSphere()}dispose(){}}class L extends t.LineSegments{constructor(e){let i=5;if(e.geometry){const d=e.geometry;!d.boundingSphere&&d.computeBoundingSphere(),i=d.boundingSphere.radius*.8}const r=[0,0,0,i,0,0,0,0,0,0,i,0,0,0,0,0,0,i],o=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],c=new t.BufferGeometry;c.setAttribute("position",new t.Float32BufferAttribute(r,3)),c.setAttribute("color",new t.Float32BufferAttribute(o,3));const h=new t.LineBasicMaterial({vertexColors:!0,toneMapped:!1,depthFunc:t.AlwaysDepth});super(c,h);s(this,"target");this.target=e,this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.renderOrder=100,this.raycast=()=>{}}dispose(){}}const $=`

#include <common>

void main() {
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

  bool isPerspective = isPerspectiveMatrix( projectionMatrix );

  if ( isPerspective ) scale *= - mvPosition.z;

	vec2 alignedPosition = position.xy * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( 0.0 ) * alignedPosition.x - sin( 0.0 ) * alignedPosition.y;
	rotatedPosition.y = sin( 0.0 ) * alignedPosition.x + cos( 0.0 ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

}

`,k=`

uniform vec3 color;

void main() {
  gl_FragColor = vec4(color, 1.0);
}
`;class q extends t.ShaderMaterial{constructor(){super(),this.vertexShader=$,this.fragmentShader=k,this.uniforms={color:{value:new t.Color("white")}}}}class _ extends t.LineSegments{constructor(e){super();s(this,"target");s(this,"type","VisCSS2DPlaneHelper");s(this,"observer");this.geometry=new t.EdgesGeometry(new t.PlaneBufferGeometry(1,1)),this.geometry.computeBoundingBox(),this.material=new q,this.scale.copy(e.matrixScale),this.position.set(e.position.x,e.position.y,e.position.z),this.target=e;const i=new MutationObserver(()=>{this.scale.copy(e.matrixScale)});i.observe(e.element,{attributeFilter:["style"]}),this.observer=i,this.onBeforeRender=()=>{this.position.set(this.target.position.x,this.target.position.y,this.target.position.z)},this.raycast=()=>{}}dispose(){this.observer.disconnect()}}class Y extends t.LineSegments{constructor(e){super();s(this,"target");s(this,"type","VisCSS3DPlaneHelper");s(this,"observer");this.geometry=new t.EdgesGeometry(new t.PlaneBufferGeometry(e.width,e.height)),this.geometry.computeBoundingBox(),this.material=g(),this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.target=e;const i=new MutationObserver(()=>{this.geometry.dispose(),this.geometry=new t.EdgesGeometry(new t.PlaneBufferGeometry(e.width,e.height)),this.geometry.computeBoundingBox()});i.observe(e.element,{attributeFilter:["style"]}),this.observer=i,this.raycast=()=>{},this.updateMatrixWorld=()=>{}}dispose(){this.observer.disconnect()}}const Z=`
uniform float rotation2D;

#include <common>

void main() {
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

	vec2 alignedPosition = position.xy * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation2D ) * alignedPosition.x - sin( rotation2D ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation2D ) * alignedPosition.x + cos( rotation2D ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

}

`,J=`

uniform vec3 color;

void main() {
  gl_FragColor = vec4(color, 1.0);
}
`;class K extends t.ShaderMaterial{constructor(){super(),this.vertexShader=Z,this.fragmentShader=J,this.uniforms={color:{value:new t.Color("white")},rotation2D:{value:0}}}}class Q extends t.LineSegments{constructor(e){super();s(this,"target");s(this,"type","VisCSS3DSpriteHelper");s(this,"observer");this.geometry=new t.EdgesGeometry(new t.PlaneBufferGeometry(1,1)),this.geometry.computeBoundingBox(),this.material=new K,this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.target=e;const i=new MutationObserver(()=>{this.geometry.dispose(),this.geometry=new t.EdgesGeometry(new t.PlaneBufferGeometry(e.width,e.height)),this.geometry.computeBoundingBox()});i.observe(e.element,{attributeFilter:["style"]}),this.observer=i,this.onBeforeRender=()=>{this.material.uniforms.rotation2D.value=this.target.rotation2D},this.raycast=()=>{},this.updateMatrixWorld=()=>{}}dispose(){this.observer.disconnect()}}const C=class extends t.Sprite{constructor(e){super();s(this,"target");s(this,"type","VisGroupHelper");this.target=e,this.geometry.computeBoundingBox(),this.material=new t.SpriteMaterial({map:C.colorTexture}),this.material.depthTest=!1,this.material.depthWrite=!1,this.scale.set(5,5,5);const i=this.updateMatrixWorld.bind(this);this.updateMatrixWorld=r=>{const o=this.position,c=this.target.position;o.x=c.x,o.y=c.y,o.z=c.z,i(r)}}raycast(e,i){const r=this.matrixWorld,o=this.geometry.boundingBox.clone();if(o.applyMatrix4(r),e.ray.intersectsBox(o)){const c=this.target;i.push({distance:e.ray.origin.distanceTo(c.position),object:c,point:c.position})}}dispose(){this.geometry.dispose(),this.material.dispose()}};let B=C;s(B,"colorTexture",new t.CanvasTexture(new v.CanvasGenerator({width:512,height:512}).draw(e=>{e.beginPath(),e.fillStyle="rgba(0, 0, 0, 0)",e.fillRect(0,0,512,512),e.closePath(),e.translate(256,200),e.beginPath(),e.fillStyle="yellow",e.fillRect(-200,0,400,200),e.closePath(),e.beginPath(),e.fillStyle="yellow",e.fillRect(-200,-70,200,70),e.closePath()}).get()));const W=class extends t.Points{constructor(e){super();s(this,"target");s(this,"cachaGeometryUUid");s(this,"type","VisLineHelper");this.target=e,this.geometry.dispose(),this.geometry.copy(e.geometry),this.cachaGeometryUUid=e.geometry.uuid,this.material=new t.PointsMaterial({color:"rgb(255, 255, 255)",alphaMap:W.alphaTexture,transparent:!0,size:5,sizeAttenuation:!1}),this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.renderOrder=-1,this.raycast=()=>{},this.onBeforeRender=()=>{const i=this.target;i.geometry.uuid!==this.cachaGeometryUUid&&(this.geometry.dispose(),this.geometry=i.geometry.clone(),this.cachaGeometryUUid=i.geometry.uuid)}}dispose(){this.geometry.dispose(),this.material.dispose()}};let P=W;s(P,"alphaTexture",new t.CanvasTexture(new v.CanvasGenerator({width:512,height:512,bgColor:"rgb(0, 0, 0)"}).draw(e=>{e.beginPath(),e.fillStyle="rgb(255, 255, 255)",e.arc(256,256,200,0,Math.PI*2),e.fill(),e.closePath()}).getDom()));class X extends t.LineSegments{constructor(e){super();s(this,"target");s(this,"type","VisMeshHelper");s(this,"cachaGeometryUUid");const i=1;this.target=e,this.geometry=new t.EdgesGeometry(e.geometry,i),this.cachaGeometryUUid=e.geometry.uuid,this.material=g(),this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.updateMatrixWorld=()=>{},this.raycast=()=>{},this.onBeforeRender=()=>{const r=this.target;r.geometry.uuid!==this.cachaGeometryUUid&&(this.geometry.dispose(),this.geometry=new t.EdgesGeometry(r.geometry,i),this.cachaGeometryUUid=r.geometry.uuid)}}dispose(){this.geometry.dispose(),this.material.dispose()}}const U=class extends t.Points{constructor(e){super();s(this,"target");s(this,"type","VisPointsHelper");this.target=e,this.geometry.dispose(),this.geometry.copy(e.geometry),this.material.dispose(),this.material=new t.PointsMaterial({color:"rgb(255, 255, 255)",alphaMap:U.alphaTexture,transparent:!0});const i=Array.isArray(e.material)?e.material[0]:e.material;i instanceof t.PointsMaterial&&(this.material.size=i.size,this.material.sizeAttenuation=i.sizeAttenuation),this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.raycast=()=>{}}dispose(){this.geometry.dispose(),this.material.dispose()}};let S=U;s(S,"alphaTexture",new t.CanvasTexture(new v.CanvasGenerator({width:512,height:512,bgColor:"rgb(0, 0, 0)"}).draw(e=>{e.beginPath(),e.strokeStyle="rgb(255, 255, 255)",e.lineWidth=4,e.strokeRect(0,0,512,512),e.closePath()}).get()));const ee=`

uniform float rotation;
uniform vec2 center;
uniform bool sizeAttenuation;

#include <common>

void main() {
  vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

	if (!sizeAttenuation) {
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );

		if ( isPerspective ) scale *= - mvPosition.z;
  }

	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

}

`,te=`

uniform vec3 color;

void main() {
  gl_FragColor = vec4(color, 1.0);
}
`;class ie extends t.ShaderMaterial{constructor(){super(),this.vertexShader=ee,this.fragmentShader=te,this.uniforms={color:{value:new t.Color("white")},center:{value:new t.Vector2(.5,.5)},rotation:{value:0},sizeAttenuation:{value:!1}}}}class se extends t.LineSegments{constructor(e){super();s(this,"target");s(this,"type","VisSpriteHelper");this.geometry=new t.EdgesGeometry(new t.PlaneBufferGeometry(1,1)),this.geometry.computeBoundingBox(),this.material=new ie,this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.target=e,this.onBeforeRender=()=>{this.material.uniforms.rotation.value=this.target.material.rotation,this.material.uniforms.sizeAttenuation.value=this.target.material.sizeAttenuation},this.raycast=()=>{}}dispose(){this.geometry.dispose(),this.material.dispose()}}class oe extends y.EventDispatcher{constructor(){super();s(this,"target");s(this,"shape");s(this,"boundingBox");s(this,"geometricOrigin");s(this,"localAxes");s(this,"shapeMap",{PointLight:R,SpotLight:N,DirectionalLight:E,RectAreaLight:F,PerspectiveCamera:H,OrthographicCamera:H,Mesh:X,Group:B,Sprite:se,Points:S,Line:P,CSS3DPlane:Y,CSS3DSprite:Q,CSS2DPlane:_})}generateShape(){if(this.target){if(!this.shapeMap[this.target.type]){console.warn(`object helper can not support ${this.target.type}`);return}const e=new this.shapeMap[this.target.type](this.target);this.shape=e}}generateBoundingBox(){if(this.target){const e=new I(this.target);this.boundingBox=e}}generateGeometricOrigin(){if(this.target){const e=new b(this.target);this.geometricOrigin=e}}generateLocalAxes(){if(this.target){const e=new L(this.target);this.localAxes=e}}dispose(e){if(e&&this[e]){this[e].dispose();return}this.target=void 0,this.shape&&this.shape.dispose(),this.boundingBox&&this.boundingBox.dispose(),this.geometricOrigin&&this.geometricOrigin.dispose(),this.localAxes&&this.localAxes.dispose()}}const D=new WeakMap,u=function(n,a,e){const i=e.getObjectBySymbol(a.target);if(!i){console.warn(`object helper processor can not fund object: ${a.target}`);return}i.parent.add(n);const r=()=>{i.parent.add(n)};l.Bus.compilerEvent.on(i,`${l.COMPILER_EVENT.UPDATE}:parent`,r),D.set(i,r)},M=function(n,a,e,i){const r=i.getObjectBySymbol(a.target);if(!r){console.warn(`object helper processor can not fund object: ${a.target}`);return}e[n].removeFromParent();const o=D.get(r);o&&l.Bus.compilerEvent.off(r,`${l.COMPILER_EVENT.UPDATE}:parent`,o),e.dispose(n)};var re=l.defineProcessor({type:"ObjectHelper",config:T,commands:{set:{shape({config:n,target:a,value:e,engine:i}){e&&!a.shape?(a.generateShape(),u(a.shape,n,i)):!e&&a.shape&&M("shape",n,a,i)},boundingBox({config:n,target:a,value:e,engine:i}){e&&!a.boundingBox?(a.generateBoundingBox(),u(a.boundingBox,n,i)):!e&&a.boundingBox&&M("boundingBox",n,a,i)},geometricOrigin({config:n,target:a,value:e,engine:i}){e&&!a.geometricOrigin?(a.generateGeometricOrigin(),u(a.geometricOrigin,n,i)):!e&&a.geometricOrigin&&M("geometricOrigin",n,a,i)},localAxes({config:n,target:a,value:e,engine:i}){e&&!a.localAxes?(a.generateLocalAxes(),u(a.localAxes,n,i)):!e&&a.localAxes&&M("localAxes",n,a,i)}}},create(n,a){const e=new oe;if(n.target){const i=a.getObjectBySymbol(n.target);i?(e.target=i,n.shape&&(e.generateShape(),u(e.shape,n,a)),n.boundingBox&&(e.generateBoundingBox(),u(e.boundingBox,n,a)),n.geometricOrigin&&(e.generateGeometricOrigin(),u(e.geometricOrigin,n,a)),n.localAxes&&(e.generateLocalAxes(),u(e.localAxes,n,a))):console.warn(`object helper processor can not found target in engine ${n.target}`)}return e},dispose(n){n.dispose()}}),ae={type:"helper",compiler:V,rule:z,processors:[re],lifeOrder:l.SUPPORT_LIFE_CYCLE.ZERO};return ae});
