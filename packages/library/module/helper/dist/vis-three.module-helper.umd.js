(function(h,p){typeof exports=="object"&&typeof module<"u"?p(exports,require("@vis-three/tdcm"),require("@vis-three/core"),require("three"),require("@vis-three/convenient")):typeof define=="function"&&define.amd?define(["exports","@vis-three/tdcm","@vis-three/core","three","@vis-three/convenient"],p):(h=typeof globalThis<"u"?globalThis:h||self,p((h["vis-three"]=h["vis-three"]||{},h["vis-three"]["module-helper"]={}),h.tdcm,h.core,h.three,h.convenient))})(this,function(h,p,O,i,y){"use strict";const d=()=>new i.LineBasicMaterial({color:"rgb(255, 255, 255)"});class A extends i.LineSegments{constructor(e){super(),this.type="CameraHelper";const t=new i.BufferGeometry,s=[0,0,0,-1,1,-1,0,0,0,-1,1,1,0,0,0,-1,-1,-1,0,0,0,-1,-1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,1,1,-1,1,1,-1,-1,1,0,0,0,0,1,1,0,0,0,0,1,-1,0,0,0,0,-1,-1,0,0,0,0,-1,1,0,1,1,0,1,-1,0,1,-1,0,-1,-1,0,-1,-1,0,-1,1,0,-1,1,0,1,1,0,-1,1,2,-1,1,0,1,-1,2,1,-1,0,-1,-1,2,-1,-1,0,1,1,2,1,1,2,1,1,2,-1,1,2,-1,1,2,-1,-1,2,-1,-1,2,1,-1,2,1,-1,2,1,1];t.setAttribute("position",new i.Float32BufferAttribute(s,3)),t.rotateY(-90*Math.PI/180),t.computeBoundingBox();const o=new i.CameraHelper(e);o.matrix=new i.Matrix4,o.matrixAutoUpdate=!0,o.raycast=()=>{},this.add(o),this.shape=o,this.geometry=t,this.material=d(),this.target=e,this.matrixAutoUpdate=!1,this.matrix=e.matrix,e instanceof i.PerspectiveCamera?this.cachaData={fov:e.fov,aspect:e.aspect,near:e.near,far:e.far}:e instanceof i.OrthographicCamera?this.cachaData={left:e.left,right:e.right,top:e.top,bottom:e.bottom,near:e.near,far:e.far}:this.cachaData={},this.onBeforeRender=()=>{let a=!1;const n=this.cachaData;Object.keys(n).forEach(l=>{n[l]!==e[l]&&(n[l]=e[l],a=!0)}),a&&this.shape.update()}}raycast(e,t){const s=this.matrixWorld,o=this.geometry.boundingBox.clone();if(o.applyMatrix4(s),e.ray.intersectsBox(o)){const a=this.target;t.push({distance:e.ray.origin.distanceTo(a.position),object:a,point:a.position})}}dispose(){this.geometry.dispose(),this.material.dispose(),this.shape.dispose()}}class U extends i.LineSegments{constructor(e){super(),this.type="VisDirectionalLightHelper",this.geometry=new i.BufferGeometry;const t=[-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1,0,0,1,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,0,0,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,-.707,0,-.707,.707,0,.707,.707,0,-.707,-.707,0,.707];this.geometry.setAttribute("position",new i.Float32BufferAttribute(t,3)),this.material=d(),this.geometry.boundingSphere;const s=new i.Color().copy(e.color).multiplyScalar(e.intensity),o=new i.PlaneGeometry(20,20);o.dispose();const a=new i.LineSegments(new i.EdgesGeometry(o),new i.LineBasicMaterial({color:s}));a.raycast=()=>{},this.shape=a,this.target=e,this.sphere=new i.Sphere(new i.Vector3(0,0,0),1),this.cacheColor=e.color.getHex(),this.cacheVector3=new i.Vector3,this.add(this.shape),this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.onBeforeRender=()=>{const n=this.target,l=this.shape;n.color.getHex()!==this.cacheColor&&(l.material.color.copy(n.color).multiplyScalar(n.intensity),this.cacheColor=n.color.getHex()),l.lookAt(n.target.position)}}raycast(e,t){const s=this.target,o=s.matrixWorld,a=this.sphere;a.set(this.cacheVector3.set(0,0,0),1),a.applyMatrix4(o),e.ray.intersectsSphere(a)&&t.push({distance:e.ray.origin.distanceTo(s.position),object:s,point:s.position})}dispose(){this.shape.geometry.dispose(),this.shape.material.dispose(),this.geometry.dispose(),this.material.dispose()}}class D extends i.LineSegments{constructor(e){super(),this.type="VisPointLightHelper",this.geometry=new i.BufferGeometry;const t=[-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1,0,0,1,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,0,0,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,-.707,0,-.707,.707,0,.707,.707,0,-.707,-.707,0,.707];this.geometry.setAttribute("position",new i.Float32BufferAttribute(t,3)),this.material=d(),this.geometry.boundingSphere;const s=new i.Color().copy(e.color).multiplyScalar(e.intensity),o=new i.Mesh(new i.OctahedronGeometry(e.distance,0),new i.MeshBasicMaterial({color:s,wireframe:!0}));o.raycast=()=>{},o.matrixAutoUpdate=!1,this.shape=o,this.target=e,this.sphere=new i.Sphere(new i.Vector3(0,0,0),1),this.cacheColor=e.color.getHex(),this.cacheDistance=e.distance,this.cacheVector3=new i.Vector3,this.add(this.shape),this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.onBeforeRender=()=>{const a=this.target,n=this.shape;a.distance!==this.cacheDistance&&(n.geometry.dispose(),n.geometry=new i.OctahedronGeometry(a.distance,0),this.cacheDistance=a.distance),a.color.getHex()!==this.cacheColor&&(n.material.color.copy(a.color).multiplyScalar(a.intensity),this.cacheColor=a.color.getHex())}}raycast(e,t){const s=this.target,o=s.matrixWorld,a=this.sphere;a.set(this.cacheVector3.set(0,0,0),1),a.applyMatrix4(o),e.ray.intersectsSphere(a)&&t.push({distance:e.ray.origin.distanceTo(s.position),object:s,point:s.position})}dispose(){this.shape.geometry.dispose(),this.shape.material.dispose(),this.geometry.dispose(),this.material.dispose()}}class G extends i.LineSegments{constructor(e){super(),this.type="VisRectAreaLightHelper",this.cacheBox=new i.Box3,this.cacheVector3=new i.Vector3,this.target=e,this.generateShape();const t=d();t.color.copy(e.color).multiplyScalar(e.intensity),this.cacheColor=e.color.getHex(),this.cacheIntensity=e.intensity,this.material=t,this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.onBeforeRender=()=>{const s=this.target;(s.width!==this.geometry.parameters.width||s.height!==this.geometry.parameters.height)&&this.generateShape(),(s.color.getHex()!==this.cacheColor||this.cacheIntensity!==s.intensity)&&(this.material.color.copy(s.color).multiplyScalar(s.intensity),this.cacheColor=s.color.getHex())}}generateShape(){this.geometry.dispose(),this.geometry=new i.PlaneGeometry(this.target.width,this.target.height,4,4),this.geometry.computeBoundingBox()}raycast(e,t){const s=this.target,o=this.cacheBox;o.copy(this.geometry.boundingBox),o.applyMatrix4(s.matrixWorld),e.ray.intersectBox(o,this.cacheVector3)&&t.push({distance:e.ray.origin.distanceTo(s.position),object:s,point:s.position})}dispose(){this.geometry.dispose(),this.material.dispose()}}class j extends i.LineSegments{constructor(e){super(),this.type="VisSpotLightHelper",this.geometry=new i.BufferGeometry;const t=[-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1,0,0,1,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,0,0,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,-.707,0,-.707,.707,0,.707,.707,0,-.707,-.707,0,.707];this.geometry.setAttribute("position",new i.Float32BufferAttribute(t,3)),this.material=d(),this.geometry.boundingSphere;const s=new i.BufferGeometry,o=[0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let c=0,m=1,g=32;c<g;c++,m++){const x=c/g*Math.PI*2,W=m/g*Math.PI*2;o.push(Math.cos(x),Math.sin(x),1,Math.cos(W),Math.sin(W),1)}s.setAttribute("position",new i.Float32BufferAttribute(o,3));const a=d(),n=new i.LineSegments(s,a);n.material.color.copy(e.color).multiplyScalar(e.intensity);const l=e.distance?e.distance:1e3,u=l*Math.tan(e.angle);n.scale.set(u,u,l),n.raycast=()=>{},this.add(n),this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.target=e,this.shape=n,this.sphere=new i.Sphere(new i.Vector3(0,0,0),1),this.cacheColor=e.color.getHex(),this.cacheDistance=e.distance,this.cacheAngle=e.angle,this.cacheVector3=new i.Vector3,this.onBeforeRender=()=>{const c=this.target,m=this.shape;let g=!1;if(c.distance!==this.cacheDistance&&(this.cacheDistance=c.distance,m.scale.z=c.distance,g=!0),c.angle!==this.cacheAngle&&(this.cacheAngle=c.angle,g=!0),g){const x=c.distance*Math.tan(c.angle);m.scale.set(x,x,c.distance)}c.color.getHex()!==this.cacheColor&&(m.material.color.copy(c.color).multiplyScalar(c.intensity),this.cacheColor=c.color.getHex()),m.lookAt(c.target.position)}}raycast(e,t){const s=this.target,o=s.matrixWorld,a=this.sphere;a.set(this.cacheVector3.set(0,0,0),1),a.applyMatrix4(o),e.ray.intersectsSphere(a)&&t.push({distance:e.ray.origin.distanceTo(s.position),object:s,point:s.position})}dispose(){this.shape.geometry.dispose(),this.shape.material.dispose(),this.geometry.dispose(),this.material.dispose()}}const f=class f extends i.Points{constructor(e){super(),this.type="GeometricOriginHelper",this.target=e,this.geometry=new i.BufferGeometry().setAttribute("position",new i.BufferAttribute(new Float32Array([0,0,0]),3)),this.material=new i.PointsMaterial({map:f.colorTexture,transparent:!0,alphaTest:.1,depthFunc:i.AlwaysDepth,size:10,sizeAttenuation:!1}),this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.renderOrder=100,this.raycast=()=>{}}dispose(){}};f.colorTexture=new i.CanvasTexture(new y.CanvasGenerator({width:32,height:32}).draw(e=>{e.beginPath(),e.fillStyle="rgba(0, 0, 0, 0)",e.fillRect(0,0,32,32),e.closePath(),e.beginPath(),e.fillStyle="rgb(255, 163, 0)",e.strokeStyle="black",e.lineWidth=1,e.arc(16,16,15,0,2*Math.PI),e.stroke(),e.fill(),e.closePath()}).get());let S=f;class z extends i.LineSegments{constructor(e){const t=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),s=new Float32Array(8*3),o=new i.BufferGeometry;o.setIndex(new i.BufferAttribute(t,1)),o.setAttribute("position",new i.BufferAttribute(s,3)),super(o,new i.LineBasicMaterial({color:15662848,toneMapped:!1})),this.type="BoundingBoxHelper",this.cacheBox=new i.Box3,this.compareBox=new i.Box3,this.matrixAutoUpdate=!1,this.raycast=()=>{},this.target=e,this.onBeforeRender=()=>{this.update()}}update(){if(this.cacheBox.setFromObject(this.target),this.cacheBox.isEmpty()||this.cacheBox.equals(this.compareBox))return;this.compareBox.copy(this.cacheBox);const e=this.cacheBox.min,t=this.cacheBox.max,s=this.geometry.attributes.position,o=s.array;o[0]=t.x,o[1]=t.y,o[2]=t.z,o[3]=e.x,o[4]=t.y,o[5]=t.z,o[6]=e.x,o[7]=e.y,o[8]=t.z,o[9]=t.x,o[10]=e.y,o[11]=t.z,o[12]=t.x,o[13]=t.y,o[14]=e.z,o[15]=e.x,o[16]=t.y,o[17]=e.z,o[18]=e.x,o[19]=e.y,o[20]=e.z,o[21]=t.x,o[22]=e.y,o[23]=e.z,s.needsUpdate=!0,this.geometry.computeBoundingSphere()}dispose(){}}class V extends i.LineSegments{constructor(e){let t=5;if(e.geometry){const l=e.geometry;!l.boundingSphere&&l.computeBoundingSphere(),t=l.boundingSphere.radius*.8}const s=[0,0,0,t,0,0,0,0,0,0,t,0,0,0,0,0,0,t],o=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],a=new i.BufferGeometry;a.setAttribute("position",new i.Float32BufferAttribute(s,3)),a.setAttribute("color",new i.Float32BufferAttribute(o,3));const n=new i.LineBasicMaterial({vertexColors:!0,toneMapped:!1,depthFunc:i.AlwaysDepth});super(a,n),this.target=e,this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.renderOrder=100,this.raycast=()=>{}}dispose(){}}const T=`

#include <common>

void main() {
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

  bool isPerspective = isPerspectiveMatrix( projectionMatrix );

  if ( isPerspective ) scale *= - mvPosition.z;

	vec2 alignedPosition = position.xy * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( 0.0 ) * alignedPosition.x - sin( 0.0 ) * alignedPosition.y;
	rotatedPosition.y = sin( 0.0 ) * alignedPosition.x + cos( 0.0 ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

}

`,E=`

uniform vec3 color;

void main() {
  gl_FragColor = vec4(color, 1.0);
}
`;let F=class extends i.ShaderMaterial{constructor(){super(),this.vertexShader=T,this.fragmentShader=E,this.uniforms={color:{value:new i.Color("white")}}}};class R extends i.LineSegments{constructor(e){super(),this.type="VisCSS2DPlaneHelper",this.geometry=new i.EdgesGeometry(new i.PlaneGeometry(1,1)),this.geometry.computeBoundingBox(),this.material=new F,this.scale.copy(e.matrixScale),this.position.set(e.position.x,e.position.y,e.position.z),this.target=e;const t=new MutationObserver(()=>{this.scale.copy(e.matrixScale)});t.observe(e.element,{attributeFilter:["style"]}),this.observer=t,this.onBeforeRender=()=>{this.position.set(this.target.position.x,this.target.position.y,this.target.position.z)},this.raycast=()=>{}}dispose(){this.observer.disconnect()}}class L extends i.LineSegments{constructor(e){super(),this.type="VisCSS3DPlaneHelper",this.geometry=new i.EdgesGeometry(new i.PlaneGeometry(e.width,e.height)),this.geometry.computeBoundingBox(),this.material=d(),this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.target=e;const t=new MutationObserver(()=>{this.geometry.dispose(),this.geometry=new i.EdgesGeometry(new i.PlaneGeometry(e.width,e.height)),this.geometry.computeBoundingBox()});t.observe(e.element,{attributeFilter:["style"]}),this.observer=t,this.raycast=()=>{},this.updateMatrixWorld=()=>{}}dispose(){this.observer.disconnect()}}const N=`
uniform float rotation2D;

#include <common>

void main() {
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

	vec2 alignedPosition = position.xy * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation2D ) * alignedPosition.x - sin( rotation2D ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation2D ) * alignedPosition.x + cos( rotation2D ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

}

`,$=`

uniform vec3 color;

void main() {
  gl_FragColor = vec4(color, 1.0);
}
`;class I extends i.ShaderMaterial{constructor(){super(),this.vertexShader=N,this.fragmentShader=$,this.uniforms={color:{value:new i.Color("white")},rotation2D:{value:0}}}}class _ extends i.LineSegments{constructor(e){super(),this.type="VisCSS3DSpriteHelper",this.geometry=new i.EdgesGeometry(new i.PlaneGeometry(1,1)),this.geometry.computeBoundingBox(),this.material=new I,this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.target=e;const t=new MutationObserver(()=>{this.geometry.dispose(),this.geometry=new i.EdgesGeometry(new i.PlaneGeometry(e.width,e.height)),this.geometry.computeBoundingBox()});t.observe(e.element,{attributeFilter:["style"]}),this.observer=t,this.onBeforeRender=()=>{this.material.uniforms.rotation2D.value=this.target.rotation2D},this.raycast=()=>{},this.updateMatrixWorld=()=>{}}dispose(){this.observer.disconnect()}}const w=class w extends i.Sprite{constructor(e){super(),this.type="VisGroupHelper",this.target=e,this.geometry.computeBoundingBox(),this.material=new i.SpriteMaterial({map:w.colorTexture}),this.material.depthTest=!1,this.material.depthWrite=!1,this.scale.set(5,5,5);const t=this.updateMatrixWorld.bind(this);this.updateMatrixWorld=s=>{const o=this.position,a=this.target.position;o.x=a.x,o.y=a.y,o.z=a.z,t(s)}}raycast(e,t){const s=this.matrixWorld,o=this.geometry.boundingBox.clone();if(o.applyMatrix4(s),e.ray.intersectsBox(o)){const a=this.target;t.push({distance:e.ray.origin.distanceTo(a.position),object:a,point:a.position})}}dispose(){this.geometry.dispose(),this.material.dispose()}};w.colorTexture=new i.CanvasTexture(new y.CanvasGenerator({width:512,height:512}).draw(e=>{e.beginPath(),e.fillStyle="rgba(0, 0, 0, 0)",e.fillRect(0,0,512,512),e.closePath(),e.translate(256,200),e.beginPath(),e.fillStyle="yellow",e.fillRect(-200,0,400,200),e.closePath(),e.beginPath(),e.fillStyle="yellow",e.fillRect(-200,-70,200,70),e.closePath()}).get());let M=w;const v=class v extends i.Points{constructor(e){super(),this.type="VisLineHelper",this.target=e,this.geometry.dispose(),this.geometry.copy(e.geometry),this.cachaGeometryUUid=e.geometry.uuid,this.material=new i.PointsMaterial({color:"rgb(255, 255, 255)",alphaMap:v.alphaTexture,transparent:!0,size:5,sizeAttenuation:!1}),this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.renderOrder=-1,this.raycast=()=>{},this.onBeforeRender=()=>{const t=this.target;t.geometry.uuid!==this.cachaGeometryUUid&&(this.geometry.dispose(),this.geometry=t.geometry.clone(),this.cachaGeometryUUid=t.geometry.uuid)}}dispose(){this.geometry.dispose(),this.material.dispose()}};v.alphaTexture=new i.CanvasTexture(new y.CanvasGenerator({width:512,height:512,bgColor:"rgb(0, 0, 0)"}).draw(e=>{e.beginPath(),e.fillStyle="rgb(255, 255, 255)",e.arc(256,256,200,0,Math.PI*2),e.fill(),e.closePath()}).getDom());let P=v;class q extends i.LineSegments{constructor(e){super(),this.type="VisMeshHelper";const t=1;this.target=e,this.geometry=new i.EdgesGeometry(e.geometry,t),this.cachaGeometryUUid=e.geometry.uuid,this.material=d(),this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.updateMatrixWorld=()=>{},this.raycast=()=>{},this.onBeforeRender=()=>{const s=this.target;s.geometry.uuid!==this.cachaGeometryUUid&&(this.geometry.dispose(),this.geometry=new i.EdgesGeometry(s.geometry,t),this.cachaGeometryUUid=s.geometry.uuid)}}dispose(){this.geometry.dispose(),this.material.dispose()}}const b=class b extends i.Points{constructor(e){super(),this.type="VisPointsHelper",this.target=e,this.geometry.dispose(),this.geometry.copy(e.geometry),this.material.dispose(),this.material=new i.PointsMaterial({color:"rgb(255, 255, 255)",alphaMap:b.alphaTexture,transparent:!0});const t=Array.isArray(e.material)?e.material[0]:e.material;t instanceof i.PointsMaterial&&(this.material.size=t.size,this.material.sizeAttenuation=t.sizeAttenuation),this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.raycast=()=>{}}dispose(){this.geometry.dispose(),this.material.dispose()}};b.alphaTexture=new i.CanvasTexture(new y.CanvasGenerator({width:512,height:512,bgColor:"rgb(0, 0, 0)"}).draw(e=>{e.beginPath(),e.strokeStyle="rgb(255, 255, 255)",e.lineWidth=4,e.strokeRect(0,0,512,512),e.closePath()}).get());let B=b;const k=`

uniform float rotation;
uniform vec2 center;
uniform bool sizeAttenuation;

#include <common>

void main() {
  vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

	if (!sizeAttenuation) {
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );

		if ( isPerspective ) scale *= - mvPosition.z;
  }

	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

}

`,Y=`

uniform vec3 color;

void main() {
  gl_FragColor = vec4(color, 1.0);
}
`;class J extends i.ShaderMaterial{constructor(){super(),this.vertexShader=k,this.fragmentShader=Y,this.uniforms={color:{value:new i.Color("white")},center:{value:new i.Vector2(.5,.5)},rotation:{value:0},sizeAttenuation:{value:!1}}}}class K extends i.LineSegments{constructor(e){super(),this.type="VisSpriteHelper",this.geometry=new i.EdgesGeometry(new i.PlaneGeometry(1,1)),this.geometry.computeBoundingBox(),this.material=new J,this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.target=e,this.onBeforeRender=()=>{this.material.uniforms.rotation.value=this.target.material.rotation,this.material.uniforms.sizeAttenuation.value=this.target.material.sizeAttenuation},this.raycast=()=>{}}dispose(){this.geometry.dispose(),this.material.dispose()}}const C=function(){return Object.assign(p.getBasicConfig(),{})},H=function(){return Object.assign(C(),{target:"",shape:!0,boundingBox:!1,geometricOrigin:!1,localAxes:!1})};class Q extends O.EventDispatcher{constructor(){super(),this.shapeMap={PointLight:D,SpotLight:j,DirectionalLight:U,RectAreaLight:G,PerspectiveCamera:A,OrthographicCamera:A,Mesh:q,Group:M,Sprite:K,Points:B,Line:P,CSS3DPlane:L,CSS3DSprite:_,CSS2DPlane:R}}generateShape(){if(this.target){if(!this.shapeMap[this.target.type]){console.warn(`object helper can not support ${this.target.type}`);return}const e=new this.shapeMap[this.target.type](this.target);this.shape=e}}generateBoundingBox(){if(this.target){const e=new z(this.target);this.boundingBox=e}}generateGeometricOrigin(){if(this.target){const e=new S(this.target);this.geometricOrigin=e}}generateLocalAxes(){if(this.target){const e=new V(this.target);this.localAxes=e}}dispose(e){if(e&&this[e]){this[e].removeFromParent(),this[e].dispose(),this[e]=void 0;return}this.target=void 0,["shape","boundingBox","geometricOrigin","localAxes"].forEach(t=>{this[t]&&(this[t].removeFromParent(),this[t].dispose(),this[t]=void 0)})}}const X=p.defineModel({type:"ObjectHelper",config:H,context(){return{helperEventMap:{}}},shared:{addHelper(r,e,t,s){const o={shape:e.generateShape,boundingBox:e.generateBoundingBox,geometricOrigin:e.generateGeometricOrigin,localAxes:e.generateLocalAxes};if(!o[r]){console.warn(`Object helper Model: can not found helper: ${r} in generator.`);return}const a=o[r]();s.toAsync(n=>{var c;const l=s.toObject(t.target);if(!l||!l.parent)return n&&console.warn(`object helper model can not fund object parent: ${l}`),!1;l.parent.add(a);const u=()=>{l.parent.add(a)};return(c=s.toModel(t.target))==null||c.on(`${p.MODEL_EVENT.COMPILED_ATTR}:parent`,u),s.helperEventMap[r]=u,!0})},removeHelper(r,e,t,s){var n;if(!s.toObject(t.target)){console.warn(`object helper model: can not fund object: ${t.target}`);return}const a=s.helperEventMap[r];a&&((n=s.toModel(t.target))==null||n.off(`${p.MODEL_EVENT.COMPILED_ATTR}:parent`,a)),e.dispose(r)}},commands:{set:{shape({model:r,config:e,target:t,value:s,engine:o}){s&&!t.shape?r.addHelper("shape",t,e,r):!s&&t.shape&&r.removeHelper("shape",t,e,r)},boundingBox({model:r,config:e,target:t,value:s,engine:o}){s&&!t.boundingBox?r.addHelper("boundingBox",t,e,r):!s&&t.boundingBox&&r.removeHelper("boundingBox",t,e,r)},geometricOrigin({model:r,config:e,target:t,value:s,engine:o}){s&&!t.geometricOrigin?r.addHelper("geometricOrigin",t,e,r):!s&&t.geometricOrigin&&r.removeHelper("geometricOrigin",t,e,r)},localAxes({model:r,config:e,target:t,value:s,engine:o}){s&&!t.localAxes?r.addHelper("localAxes",t,e,r):!s&&t.localAxes&&r.removeHelper("localAxes",t,e,r)}}},create({model:r,config:e,engine:t}){const s=new Q;if(e.target){const o=t.getObjectBySymbol(e.target),a=t.getConfigBySymbol(e.target);a.helper=e.vid,o?(s.target=o,e.shape&&r.addHelper("shape",s,e,r),e.boundingBox&&r.addHelper("boundingBox",s,e,r),e.geometricOrigin&&r.addHelper("geometricOrigin",s,e,r),e.localAxes&&r.addHelper("localAxes",s,e,r)):console.warn(`object helper processor can not found target in engine ${e.target}`)}return s},dispose({target:r}){r.dispose()},expand:[{models:new RegExp("Mesh|Light|Line|Points|Group|Object3D"),config:()=>({helper:""}),commands:{add:{helper(){}},set:{helper(){}}}}]}),Z=p.defineModule({type:"helper",models:[X],lifeOrder:p.SUPPORT_LIFE_CYCLE.FOUR});h.default=Z,h.getHelperConfig=C,h.getObjectHelperConfig=H,Object.defineProperties(h,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
