(function(l,h){typeof exports=="object"&&typeof module!="undefined"?h(exports,require("@vis-three/middleware"),require("uuid"),require("@vis-three/core"),require("three"),require("@vis-three/convenient")):typeof define=="function"&&define.amd?define(["exports","@vis-three/middleware","uuid","@vis-three/core","three","@vis-three/convenient"],h):(l=typeof globalThis!="undefined"?globalThis:l||self,h((l["vis-three"]=l["vis-three"]||{},l["vis-three"]["module-helper"]={}),l.middleware,l.uuid,l.core,l.three,l.convenient))})(this,function(l,h,y,R,t,b){"use strict";var he=Object.defineProperty;var pe=(l,h,y)=>h in l?he(l,h,{enumerable:!0,configurable:!0,writable:!0,value:y}):l[h]=y;var o=(l,h,y)=>(pe(l,typeof h!="symbol"?h+"":h,y),y);class H extends h.Compiler{constructor(){super()}}const F=function(a,n,e=y.validate){h.Rule(a,n,e)},D=function(){return Object.assign(h.getSymbolConfig(),{})},G=function(){return Object.assign(D(),{target:"",shape:!0,boundingBox:!1,geometricOrigin:!1,localAxes:!1})},g=()=>new t.LineBasicMaterial({color:"rgb(255, 255, 255)"});class O extends t.LineSegments{constructor(e){super();o(this,"shape");o(this,"target");o(this,"type","CameraHelper");o(this,"cachaData");const i=new t.BufferGeometry,r=[0,0,0,-1,1,-1,0,0,0,-1,1,1,0,0,0,-1,-1,-1,0,0,0,-1,-1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,1,1,-1,1,1,-1,-1,1,0,0,0,0,1,1,0,0,0,0,1,-1,0,0,0,0,-1,-1,0,0,0,0,-1,1,0,1,1,0,1,-1,0,1,-1,0,-1,-1,0,-1,-1,0,-1,1,0,-1,1,0,1,1,0,-1,1,2,-1,1,0,1,-1,2,1,-1,0,-1,-1,2,-1,-1,0,1,1,2,1,1,2,1,1,2,-1,1,2,-1,1,2,-1,-1,2,-1,-1,2,1,-1,2,1,-1,2,1,1];i.setAttribute("position",new t.Float32BufferAttribute(r,3)),i.rotateY(-90*Math.PI/180),i.computeBoundingBox();const s=new t.CameraHelper(e);s.matrix=new t.Matrix4,s.matrixAutoUpdate=!0,s.raycast=()=>{},this.add(s),this.shape=s,this.geometry=i,this.material=g(),this.target=e,this.matrixAutoUpdate=!1,this.matrix=e.matrix,e instanceof t.PerspectiveCamera?this.cachaData={fov:e.fov,aspect:e.aspect,near:e.near,far:e.far}:e instanceof t.OrthographicCamera?this.cachaData={left:e.left,right:e.right,top:e.top,bottom:e.bottom,near:e.near,far:e.far}:this.cachaData={},this.onBeforeRender=()=>{let c=!1;const p=this.cachaData;Object.keys(p).forEach(m=>{p[m]!==e[m]&&(p[m]=e[m],c=!0)}),c&&this.shape.update()}}raycast(e,i){const r=this.matrixWorld,s=this.geometry.boundingBox.clone();if(s.applyMatrix4(r),e.ray.intersectsBox(s)){const c=this.target;i.push({distance:e.ray.origin.distanceTo(c.position),object:c,point:c.position})}}dispose(){this.geometry.dispose(),this.material.dispose(),this.shape.dispose()}}class L extends t.LineSegments{constructor(e){super();o(this,"sphere");o(this,"target");o(this,"shape");o(this,"type","VisDirectionalLightHelper");o(this,"cacheColor");o(this,"cacheVector3");this.geometry=new t.BufferGeometry;const i=[-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1,0,0,1,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,0,0,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,-.707,0,-.707,.707,0,.707,.707,0,-.707,-.707,0,.707];this.geometry.setAttribute("position",new t.Float32BufferAttribute(i,3)),this.material=g(),this.geometry.boundingSphere;const r=new t.Color().copy(e.color).multiplyScalar(e.intensity),s=new t.PlaneBufferGeometry(20,20);s.dispose();const c=new t.LineSegments(new t.EdgesGeometry(s),new t.LineBasicMaterial({color:r}));c.raycast=()=>{},this.shape=c,this.target=e,this.sphere=new t.Sphere(new t.Vector3(0,0,0),1),this.cacheColor=e.color.getHex(),this.cacheVector3=new t.Vector3,this.add(this.shape),this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.onBeforeRender=()=>{const p=this.target,m=this.shape;p.color.getHex()!==this.cacheColor&&(m.material.color.copy(p.color).multiplyScalar(p.intensity),this.cacheColor=p.color.getHex()),m.lookAt(p.target.position)}}raycast(e,i){const r=this.target,s=r.matrixWorld,c=this.sphere;c.set(this.cacheVector3.set(0,0,0),1),c.applyMatrix4(s),e.ray.intersectsSphere(c)&&i.push({distance:e.ray.origin.distanceTo(r.position),object:r,point:r.position})}dispose(){this.shape.geometry.dispose(),this.shape.material.dispose(),this.geometry.dispose(),this.material.dispose()}}class N extends t.LineSegments{constructor(e){super();o(this,"sphere");o(this,"target");o(this,"shape");o(this,"type","VisPointLightHelper");o(this,"cacheColor");o(this,"cacheDistance");o(this,"cacheVector3");this.geometry=new t.BufferGeometry;const i=[-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1,0,0,1,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,0,0,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,-.707,0,-.707,.707,0,.707,.707,0,-.707,-.707,0,.707];this.geometry.setAttribute("position",new t.Float32BufferAttribute(i,3)),this.material=g(),this.geometry.boundingSphere;const r=new t.Color().copy(e.color).multiplyScalar(e.intensity),s=new t.Mesh(new t.OctahedronBufferGeometry(e.distance,0),new t.MeshBasicMaterial({color:r,wireframe:!0}));s.raycast=()=>{},s.matrixAutoUpdate=!1,this.shape=s,this.target=e,this.sphere=new t.Sphere(new t.Vector3(0,0,0),1),this.cacheColor=e.color.getHex(),this.cacheDistance=e.distance,this.cacheVector3=new t.Vector3,this.add(this.shape),this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.onBeforeRender=()=>{const c=this.target,p=this.shape;c.distance!==this.cacheDistance&&(p.geometry.dispose(),p.geometry=new t.OctahedronBufferGeometry(c.distance,0),this.cacheDistance=c.distance),c.color.getHex()!==this.cacheColor&&(p.material.color.copy(c.color).multiplyScalar(c.intensity),this.cacheColor=c.color.getHex())}}raycast(e,i){const r=this.target,s=r.matrixWorld,c=this.sphere;c.set(this.cacheVector3.set(0,0,0),1),c.applyMatrix4(s),e.ray.intersectsSphere(c)&&i.push({distance:e.ray.origin.distanceTo(r.position),object:r,point:r.position})}dispose(){this.shape.geometry.dispose(),this.shape.material.dispose(),this.geometry.dispose(),this.material.dispose()}}class I extends t.LineSegments{constructor(e){super();o(this,"target");o(this,"type","VisRectAreaLightHelper");o(this,"cacheBox",new t.Box3);o(this,"cacheVector3",new t.Vector3);o(this,"cacheColor");o(this,"cacheIntensity");this.target=e,this.generateShape();const i=g();i.color.copy(e.color).multiplyScalar(e.intensity),this.cacheColor=e.color.getHex(),this.cacheIntensity=e.intensity,this.material=i,this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.onBeforeRender=()=>{const r=this.target;(r.width!==this.geometry.parameters.width||r.height!==this.geometry.parameters.height)&&this.generateShape(),(r.color.getHex()!==this.cacheColor||this.cacheIntensity!==r.intensity)&&(this.material.color.copy(r.color).multiplyScalar(r.intensity),this.cacheColor=r.color.getHex())}}generateShape(){this.geometry.dispose(),this.geometry=new t.PlaneBufferGeometry(this.target.width,this.target.height,4,4),this.geometry.computeBoundingBox()}raycast(e,i){const r=this.target,s=this.cacheBox;s.copy(this.geometry.boundingBox),s.applyMatrix4(r.matrixWorld),e.ray.intersectBox(s,this.cacheVector3)&&i.push({distance:e.ray.origin.distanceTo(r.position),object:r,point:r.position})}dispose(){this.geometry.dispose(),this.material.dispose()}}class $ extends t.LineSegments{constructor(e){super();o(this,"sphere");o(this,"target");o(this,"shape");o(this,"type","VisSpotLightHelper");o(this,"cacheVector3");o(this,"cacheColor");o(this,"cacheAngle");o(this,"cacheDistance");this.geometry=new t.BufferGeometry;const i=[-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1,0,0,1,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,0,0,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,-.707,0,-.707,.707,0,.707,.707,0,-.707,-.707,0,.707];this.geometry.setAttribute("position",new t.Float32BufferAttribute(i,3)),this.material=g(),this.geometry.boundingSphere;const r=new t.BufferGeometry,s=[0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let d=0,x=1,f=32;d<f;d++,x++){const v=d/f*Math.PI*2,E=x/f*Math.PI*2;s.push(Math.cos(v),Math.sin(v),1,Math.cos(E),Math.sin(E),1)}r.setAttribute("position",new t.Float32BufferAttribute(s,3));const c=g(),p=new t.LineSegments(r,c);p.material.color.copy(e.color).multiplyScalar(e.intensity);const m=e.distance?e.distance:1e3,T=m*Math.tan(e.angle);p.scale.set(T,T,m),p.raycast=()=>{},this.add(p),this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.target=e,this.shape=p,this.sphere=new t.Sphere(new t.Vector3(0,0,0),1),this.cacheColor=e.color.getHex(),this.cacheDistance=e.distance,this.cacheAngle=e.angle,this.cacheVector3=new t.Vector3,this.onBeforeRender=()=>{const d=this.target,x=this.shape;let f=!1;if(d.distance!==this.cacheDistance&&(this.cacheDistance=d.distance,x.scale.z=d.distance,f=!0),d.angle!==this.cacheAngle&&(this.cacheAngle=d.angle,f=!0),f){const v=d.distance*Math.tan(d.angle);x.scale.set(v,v,d.distance)}d.color.getHex()!==this.cacheColor&&(x.material.color.copy(d.color).multiplyScalar(d.intensity),this.cacheColor=d.color.getHex()),x.lookAt(d.target.position)}}raycast(e,i){const r=this.target,s=r.matrixWorld,c=this.sphere;c.set(this.cacheVector3.set(0,0,0),1),c.applyMatrix4(s),e.ray.intersectsSphere(c)&&i.push({distance:e.ray.origin.distanceTo(r.position),object:r,point:r.position})}dispose(){this.shape.geometry.dispose(),this.shape.material.dispose(),this.geometry.dispose(),this.material.dispose()}}const A=class extends t.Points{constructor(e){super();o(this,"target");o(this,"type","GeometricOriginHelper");this.target=e,this.geometry=new t.BufferGeometry().setAttribute("position",new t.BufferAttribute(new Float32Array([0,0,0]),3)),this.material=new t.PointsMaterial({map:A.colorTexture,transparent:!0,alphaTest:.1,depthFunc:t.AlwaysDepth,size:10,sizeAttenuation:!1}),this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.renderOrder=100,this.raycast=()=>{}}dispose(){}};let w=A;o(w,"colorTexture",new t.CanvasTexture(new b.CanvasGenerator({width:32,height:32}).draw(e=>{e.beginPath(),e.fillStyle="rgba(0, 0, 0, 0)",e.fillRect(0,0,32,32),e.closePath(),e.beginPath(),e.fillStyle="rgb(255, 163, 0)",e.strokeStyle="black",e.lineWidth=1,e.arc(16,16,15,0,2*Math.PI),e.stroke(),e.fill(),e.closePath()}).get()));class _ extends t.LineSegments{constructor(e){const i=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),r=new Float32Array(8*3),s=new t.BufferGeometry;s.setIndex(new t.BufferAttribute(i,1)),s.setAttribute("position",new t.BufferAttribute(r,3));super(s,new t.LineBasicMaterial({color:15662848,toneMapped:!1}));o(this,"target");o(this,"type","BoundingBoxHelper");o(this,"cacheBox",new t.Box3);o(this,"compareBox",new t.Box3);this.matrixAutoUpdate=!1,this.raycast=()=>{},this.target=e,this.onBeforeRender=()=>{this.update()}}update(){if(this.cacheBox.setFromObject(this.target),this.cacheBox.isEmpty()||this.cacheBox.equals(this.compareBox))return;this.compareBox.copy(this.cacheBox);const e=this.cacheBox.min,i=this.cacheBox.max,r=this.geometry.attributes.position,s=r.array;s[0]=i.x,s[1]=i.y,s[2]=i.z,s[3]=e.x,s[4]=i.y,s[5]=i.z,s[6]=e.x,s[7]=e.y,s[8]=i.z,s[9]=i.x,s[10]=e.y,s[11]=i.z,s[12]=i.x,s[13]=i.y,s[14]=e.z,s[15]=e.x,s[16]=i.y,s[17]=e.z,s[18]=e.x,s[19]=e.y,s[20]=e.z,s[21]=i.x,s[22]=e.y,s[23]=e.z,r.needsUpdate=!0,this.geometry.computeBoundingSphere()}dispose(){}}class k extends t.LineSegments{constructor(e){let i=5;if(e.geometry){const m=e.geometry;!m.boundingSphere&&m.computeBoundingSphere(),i=m.boundingSphere.radius*.8}const r=[0,0,0,i,0,0,0,0,0,0,i,0,0,0,0,0,0,i],s=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],c=new t.BufferGeometry;c.setAttribute("position",new t.Float32BufferAttribute(r,3)),c.setAttribute("color",new t.Float32BufferAttribute(s,3));const p=new t.LineBasicMaterial({vertexColors:!0,toneMapped:!1,depthFunc:t.AlwaysDepth});super(c,p);o(this,"target");this.target=e,this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.renderOrder=100,this.raycast=()=>{}}dispose(){}}const q=`

#include <common>

void main() {
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

  bool isPerspective = isPerspectiveMatrix( projectionMatrix );

  if ( isPerspective ) scale *= - mvPosition.z;

	vec2 alignedPosition = position.xy * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( 0.0 ) * alignedPosition.x - sin( 0.0 ) * alignedPosition.y;
	rotatedPosition.y = sin( 0.0 ) * alignedPosition.x + cos( 0.0 ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

}

`,Y=`

uniform vec3 color;

void main() {
  gl_FragColor = vec4(color, 1.0);
}
`;class J extends t.ShaderMaterial{constructor(){super(),this.vertexShader=q,this.fragmentShader=Y,this.uniforms={color:{value:new t.Color("white")}}}}class K extends t.LineSegments{constructor(e){super();o(this,"target");o(this,"type","VisCSS2DPlaneHelper");o(this,"observer");this.geometry=new t.EdgesGeometry(new t.PlaneBufferGeometry(1,1)),this.geometry.computeBoundingBox(),this.material=new J,this.scale.copy(e.matrixScale),this.position.set(e.position.x,e.position.y,e.position.z),this.target=e;const i=new MutationObserver(()=>{this.scale.copy(e.matrixScale)});i.observe(e.element,{attributeFilter:["style"]}),this.observer=i,this.onBeforeRender=()=>{this.position.set(this.target.position.x,this.target.position.y,this.target.position.z)},this.raycast=()=>{}}dispose(){this.observer.disconnect()}}class Q extends t.LineSegments{constructor(e){super();o(this,"target");o(this,"type","VisCSS3DPlaneHelper");o(this,"observer");this.geometry=new t.EdgesGeometry(new t.PlaneBufferGeometry(e.width,e.height)),this.geometry.computeBoundingBox(),this.material=g(),this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.target=e;const i=new MutationObserver(()=>{this.geometry.dispose(),this.geometry=new t.EdgesGeometry(new t.PlaneBufferGeometry(e.width,e.height)),this.geometry.computeBoundingBox()});i.observe(e.element,{attributeFilter:["style"]}),this.observer=i,this.raycast=()=>{},this.updateMatrixWorld=()=>{}}dispose(){this.observer.disconnect()}}const X=`
uniform float rotation2D;

#include <common>

void main() {
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

	vec2 alignedPosition = position.xy * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation2D ) * alignedPosition.x - sin( rotation2D ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation2D ) * alignedPosition.x + cos( rotation2D ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

}

`,Z=`

uniform vec3 color;

void main() {
  gl_FragColor = vec4(color, 1.0);
}
`;class ee extends t.ShaderMaterial{constructor(){super(),this.vertexShader=X,this.fragmentShader=Z,this.uniforms={color:{value:new t.Color("white")},rotation2D:{value:0}}}}class te extends t.LineSegments{constructor(e){super();o(this,"target");o(this,"type","VisCSS3DSpriteHelper");o(this,"observer");this.geometry=new t.EdgesGeometry(new t.PlaneBufferGeometry(1,1)),this.geometry.computeBoundingBox(),this.material=new ee,this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.target=e;const i=new MutationObserver(()=>{this.geometry.dispose(),this.geometry=new t.EdgesGeometry(new t.PlaneBufferGeometry(e.width,e.height)),this.geometry.computeBoundingBox()});i.observe(e.element,{attributeFilter:["style"]}),this.observer=i,this.onBeforeRender=()=>{this.material.uniforms.rotation2D.value=this.target.rotation2D},this.raycast=()=>{},this.updateMatrixWorld=()=>{}}dispose(){this.observer.disconnect()}}const C=class extends t.Sprite{constructor(e){super();o(this,"target");o(this,"type","VisGroupHelper");this.target=e,this.geometry.computeBoundingBox(),this.material=new t.SpriteMaterial({map:C.colorTexture}),this.material.depthTest=!1,this.material.depthWrite=!1,this.scale.set(5,5,5);const i=this.updateMatrixWorld.bind(this);this.updateMatrixWorld=r=>{const s=this.position,c=this.target.position;s.x=c.x,s.y=c.y,s.z=c.z,i(r)}}raycast(e,i){const r=this.matrixWorld,s=this.geometry.boundingBox.clone();if(s.applyMatrix4(r),e.ray.intersectsBox(s)){const c=this.target;i.push({distance:e.ray.origin.distanceTo(c.position),object:c,point:c.position})}}dispose(){this.geometry.dispose(),this.material.dispose()}};let B=C;o(B,"colorTexture",new t.CanvasTexture(new b.CanvasGenerator({width:512,height:512}).draw(e=>{e.beginPath(),e.fillStyle="rgba(0, 0, 0, 0)",e.fillRect(0,0,512,512),e.closePath(),e.translate(256,200),e.beginPath(),e.fillStyle="yellow",e.fillRect(-200,0,400,200),e.closePath(),e.beginPath(),e.fillStyle="yellow",e.fillRect(-200,-70,200,70),e.closePath()}).get()));const W=class extends t.Points{constructor(e){super();o(this,"target");o(this,"cachaGeometryUUid");o(this,"type","VisLineHelper");this.target=e,this.geometry.dispose(),this.geometry.copy(e.geometry),this.cachaGeometryUUid=e.geometry.uuid,this.material=new t.PointsMaterial({color:"rgb(255, 255, 255)",alphaMap:W.alphaTexture,transparent:!0,size:5,sizeAttenuation:!1}),this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.renderOrder=-1,this.raycast=()=>{},this.onBeforeRender=()=>{const i=this.target;i.geometry.uuid!==this.cachaGeometryUUid&&(this.geometry.dispose(),this.geometry=i.geometry.clone(),this.cachaGeometryUUid=i.geometry.uuid)}}dispose(){this.geometry.dispose(),this.material.dispose()}};let S=W;o(S,"alphaTexture",new t.CanvasTexture(new b.CanvasGenerator({width:512,height:512,bgColor:"rgb(0, 0, 0)"}).draw(e=>{e.beginPath(),e.fillStyle="rgb(255, 255, 255)",e.arc(256,256,200,0,Math.PI*2),e.fill(),e.closePath()}).getDom()));class ie extends t.LineSegments{constructor(e){super();o(this,"target");o(this,"type","VisMeshHelper");o(this,"cachaGeometryUUid");const i=1;this.target=e,this.geometry=new t.EdgesGeometry(e.geometry,i),this.cachaGeometryUUid=e.geometry.uuid,this.material=g(),this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.updateMatrixWorld=()=>{},this.raycast=()=>{},this.onBeforeRender=()=>{const r=this.target;r.geometry.uuid!==this.cachaGeometryUUid&&(this.geometry.dispose(),this.geometry=new t.EdgesGeometry(r.geometry,i),this.cachaGeometryUUid=r.geometry.uuid)}}dispose(){this.geometry.dispose(),this.material.dispose()}}const U=class extends t.Points{constructor(e){super();o(this,"target");o(this,"type","VisPointsHelper");this.target=e,this.geometry.dispose(),this.geometry.copy(e.geometry),this.material.dispose(),this.material=new t.PointsMaterial({color:"rgb(255, 255, 255)",alphaMap:U.alphaTexture,transparent:!0});const i=Array.isArray(e.material)?e.material[0]:e.material;i instanceof t.PointsMaterial&&(this.material.size=i.size,this.material.sizeAttenuation=i.sizeAttenuation),this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.raycast=()=>{}}dispose(){this.geometry.dispose(),this.material.dispose()}};let P=U;o(P,"alphaTexture",new t.CanvasTexture(new b.CanvasGenerator({width:512,height:512,bgColor:"rgb(0, 0, 0)"}).draw(e=>{e.beginPath(),e.strokeStyle="rgb(255, 255, 255)",e.lineWidth=4,e.strokeRect(0,0,512,512),e.closePath()}).get()));const se=`

uniform float rotation;
uniform vec2 center;
uniform bool sizeAttenuation;

#include <common>

void main() {
  vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

	if (!sizeAttenuation) {
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );

		if ( isPerspective ) scale *= - mvPosition.z;
  }

	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

}

`,oe=`

uniform vec3 color;

void main() {
  gl_FragColor = vec4(color, 1.0);
}
`;class re extends t.ShaderMaterial{constructor(){super(),this.vertexShader=se,this.fragmentShader=oe,this.uniforms={color:{value:new t.Color("white")},center:{value:new t.Vector2(.5,.5)},rotation:{value:0},sizeAttenuation:{value:!1}}}}class ae extends t.LineSegments{constructor(e){super();o(this,"target");o(this,"type","VisSpriteHelper");this.geometry=new t.EdgesGeometry(new t.PlaneBufferGeometry(1,1)),this.geometry.computeBoundingBox(),this.material=new re,this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.target=e,this.onBeforeRender=()=>{this.material.uniforms.rotation.value=this.target.material.rotation,this.material.uniforms.sizeAttenuation.value=this.target.material.sizeAttenuation},this.raycast=()=>{}}dispose(){this.geometry.dispose(),this.material.dispose()}}const V=function(a){return a},z={add:{helper(){}},set:{helper(){}}};class ne extends R.EventDispatcher{constructor(){super();o(this,"target");o(this,"shape");o(this,"boundingBox");o(this,"geometricOrigin");o(this,"localAxes");o(this,"shapeMap",{PointLight:N,SpotLight:$,DirectionalLight:L,RectAreaLight:I,PerspectiveCamera:O,OrthographicCamera:O,Mesh:ie,Group:B,Sprite:ae,Points:P,Line:S,CSS3DPlane:Q,CSS3DSprite:te,CSS2DPlane:K})}generateShape(){if(this.target){if(!this.shapeMap[this.target.type]){console.warn(`object helper can not support ${this.target.type}`);return}const e=new this.shapeMap[this.target.type](this.target);this.shape=e}}generateBoundingBox(){if(this.target){const e=new _(this.target);this.boundingBox=e}}generateGeometricOrigin(){if(this.target){const e=new w(this.target);this.geometricOrigin=e}}generateLocalAxes(){if(this.target){const e=new k(this.target);this.localAxes=e}}dispose(e){if(e&&this[e]){this[e].dispose(),this[e]=void 0;return}this.target=void 0,this.shape&&(this.shape.dispose(),this.shape=void 0),this.boundingBox&&(this.boundingBox.dispose(),this.boundingBox=void 0),this.geometricOrigin&&(this.geometricOrigin.dispose(),this.geometricOrigin=void 0),this.localAxes&&(this.localAxes.dispose(),this.localAxes=void 0)}}const j=new WeakMap,u=function(a,n,e){h.globalAntiShake.exec(i=>{const r=e.getObjectBySymbol(n.target);if(!r||!r.parent)return i&&console.warn(`object helper processor can not fund object parent: ${r}`),!1;r.parent.add(a);const s=()=>{r.parent.add(a)};return h.Bus.compilerEvent.on(r,`${h.COMPILER_EVENT.UPDATE}:parent`,s),j.set(r,s),!0})},M=function(a,n,e,i){const r=i.getObjectBySymbol(n.target);if(!r){console.warn(`object helper processor can not fund object: ${n.target}`);return}e[a].removeFromParent();const s=j.get(r);s&&h.Bus.compilerEvent.off(r,`${h.COMPILER_EVENT.UPDATE}:parent`,s),e.dispose(a)};var ce=h.defineProcessor({type:"ObjectHelper",config:G,commands:{set:{shape({config:a,target:n,value:e,engine:i}){e&&!n.shape?(n.generateShape(),u(n.shape,a,i)):!e&&n.shape&&M("shape",a,n,i)},boundingBox({config:a,target:n,value:e,engine:i}){e&&!n.boundingBox?(n.generateBoundingBox(),u(n.boundingBox,a,i)):!e&&n.boundingBox&&M("boundingBox",a,n,i)},geometricOrigin({config:a,target:n,value:e,engine:i}){e&&!n.geometricOrigin?(n.generateGeometricOrigin(),u(n.geometricOrigin,a,i)):!e&&n.geometricOrigin&&M("geometricOrigin",a,n,i)},localAxes({config:a,target:n,value:e,engine:i}){e&&!n.localAxes?(n.generateLocalAxes(),u(n.localAxes,a,i)):!e&&n.localAxes&&M("localAxes",a,n,i)}}},create(a,n){const e=new ne;if(a.target){const i=n.getObjectBySymbol(a.target),r=V(n.getConfigBySymbol(a.target));r.helper=a.vid,i?(e.target=i,a.shape&&(e.generateShape(),u(e.shape,a,n)),a.boundingBox&&(e.generateBoundingBox(),u(e.boundingBox,a,n)),a.geometricOrigin&&(e.generateGeometricOrigin(),u(e.geometricOrigin,a,n)),a.localAxes&&(e.generateLocalAxes(),u(e.localAxes,a,n))):console.warn(`object helper processor can not found target in engine ${a.target}`)}return e},dispose(a){a.dispose()}}),le={type:"helper",compiler:H,rule:F,processors:[ce],lifeOrder:h.SUPPORT_LIFE_CYCLE.FOUR,expand:[{processors:new RegExp("Mesh|Light|Line|Points|Group|Object3D"),command:z}]};l.HelperCompiler=H,l.default=le,l.expandCommand=z,l.getHelperConfig=D,l.getHelperExpandConfig=V,l.getObjectHelperConfig=G,Object.defineProperties(l,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
