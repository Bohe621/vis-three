(function(n,p){typeof exports=="object"&&typeof module<"u"?p(exports,require("@vis-three/tdcm"),require("@vis-three/core"),require("three"),require("@vis-three/convenient")):typeof define=="function"&&define.amd?define(["exports","@vis-three/tdcm","@vis-three/core","three","@vis-three/convenient"],p):(n=typeof globalThis<"u"?globalThis:n||self,p((n["vis-three"]=n["vis-three"]||{},n["vis-three"]["module-helper"]={}),n.tdcm,n.core,n.three,n.convenient))})(this,function(n,p,L,i,x){"use strict";const d=()=>new i.LineBasicMaterial({color:"rgb(255, 255, 255)"});class A extends i.LineSegments{constructor(e){super(),this.type="CameraHelper";const t=new i.BufferGeometry,s=[0,0,0,-1,1,-1,0,0,0,-1,1,1,0,0,0,-1,-1,-1,0,0,0,-1,-1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,1,1,-1,1,1,-1,-1,1,0,0,0,0,1,1,0,0,0,0,1,-1,0,0,0,0,-1,-1,0,0,0,0,-1,1,0,1,1,0,1,-1,0,1,-1,0,-1,-1,0,-1,-1,0,-1,1,0,-1,1,0,1,1,0,-1,1,2,-1,1,0,1,-1,2,1,-1,0,-1,-1,2,-1,-1,0,1,1,2,1,1,2,1,1,2,-1,1,2,-1,1,2,-1,-1,2,-1,-1,2,1,-1,2,1,-1,2,1,1];t.setAttribute("position",new i.Float32BufferAttribute(s,3)),t.rotateY(-90*Math.PI/180),t.computeBoundingBox();const o=new i.CameraHelper(e);o.matrix=new i.Matrix4,o.matrixAutoUpdate=!0,o.raycast=()=>{},this.add(o),this.shape=o,this.geometry=t,this.material=d(),this.target=e,this.matrixAutoUpdate=!1,this.matrix=e.matrix,e instanceof i.PerspectiveCamera?this.cachaData={fov:e.fov,aspect:e.aspect,near:e.near,far:e.far}:e instanceof i.OrthographicCamera?this.cachaData={left:e.left,right:e.right,top:e.top,bottom:e.bottom,near:e.near,far:e.far}:this.cachaData={},this.onBeforeRender=()=>{let a=!1;const l=this.cachaData;Object.keys(l).forEach(c=>{l[c]!==e[c]&&(l[c]=e[c],a=!0)}),a&&this.shape.update()}}raycast(e,t){const s=this.matrixWorld,o=this.geometry.boundingBox.clone();if(o.applyMatrix4(s),e.ray.intersectsBox(o)){const a=this.target;t.push({distance:e.ray.origin.distanceTo(a.position),object:a,point:a.position})}}dispose(){this.geometry.dispose(),this.material.dispose(),this.shape.dispose()}}class H extends i.LineSegments{constructor(e){super(),this.type="VisDirectionalLightHelper",this.geometry=new i.BufferGeometry;const t=[-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1,0,0,1,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,0,0,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,-.707,0,-.707,.707,0,.707,.707,0,-.707,-.707,0,.707];this.geometry.setAttribute("position",new i.Float32BufferAttribute(t,3)),this.material=d(),this.geometry.boundingSphere;const s=new i.Color().copy(e.color).multiplyScalar(e.intensity),o=new i.PlaneGeometry(20,20);o.dispose();const a=new i.LineSegments(new i.EdgesGeometry(o),new i.LineBasicMaterial({color:s}));a.raycast=()=>{},this.shape=a,this.target=e,this.sphere=new i.Sphere(new i.Vector3(0,0,0),1),this.cacheColor=e.color.getHex(),this.cacheVector3=new i.Vector3,this.add(this.shape),this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.onBeforeRender=()=>{const l=this.target,c=this.shape;l.color.getHex()!==this.cacheColor&&(c.material.color.copy(l.color).multiplyScalar(l.intensity),this.cacheColor=l.color.getHex()),c.lookAt(l.target.position)}}raycast(e,t){const s=this.target,o=s.matrixWorld,a=this.sphere;a.set(this.cacheVector3.set(0,0,0),1),a.applyMatrix4(o),e.ray.intersectsSphere(a)&&t.push({distance:e.ray.origin.distanceTo(s.position),object:s,point:s.position})}dispose(){this.shape.geometry.dispose(),this.shape.material.dispose(),this.geometry.dispose(),this.material.dispose()}}class C extends i.LineSegments{constructor(e){super(),this.type="VisPointLightHelper",this.geometry=new i.BufferGeometry;const t=[-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1,0,0,1,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,0,0,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,-.707,0,-.707,.707,0,.707,.707,0,-.707,-.707,0,.707];this.geometry.setAttribute("position",new i.Float32BufferAttribute(t,3)),this.material=d(),this.geometry.boundingSphere;const s=new i.Color().copy(e.color).multiplyScalar(e.intensity),o=new i.Mesh(new i.OctahedronGeometry(e.distance,0),new i.MeshBasicMaterial({color:s,wireframe:!0}));o.raycast=()=>{},o.matrixAutoUpdate=!1,this.shape=o,this.target=e,this.sphere=new i.Sphere(new i.Vector3(0,0,0),1),this.cacheColor=e.color.getHex(),this.cacheDistance=e.distance,this.cacheVector3=new i.Vector3,this.add(this.shape),this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.onBeforeRender=()=>{const a=this.target,l=this.shape;a.distance!==this.cacheDistance&&(l.geometry.dispose(),l.geometry=new i.OctahedronGeometry(a.distance,0),this.cacheDistance=a.distance),a.color.getHex()!==this.cacheColor&&(l.material.color.copy(a.color).multiplyScalar(a.intensity),this.cacheColor=a.color.getHex())}}raycast(e,t){const s=this.target,o=s.matrixWorld,a=this.sphere;a.set(this.cacheVector3.set(0,0,0),1),a.applyMatrix4(o),e.ray.intersectsSphere(a)&&t.push({distance:e.ray.origin.distanceTo(s.position),object:s,point:s.position})}dispose(){this.shape.geometry.dispose(),this.shape.material.dispose(),this.geometry.dispose(),this.material.dispose()}}class W extends i.LineSegments{constructor(e){super(),this.type="VisRectAreaLightHelper",this.cacheBox=new i.Box3,this.cacheVector3=new i.Vector3,this.target=e,this.generateShape();const t=d();t.color.copy(e.color).multiplyScalar(e.intensity),this.cacheColor=e.color.getHex(),this.cacheIntensity=e.intensity,this.material=t,this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.onBeforeRender=()=>{const s=this.target;(s.width!==this.geometry.parameters.width||s.height!==this.geometry.parameters.height)&&this.generateShape(),(s.color.getHex()!==this.cacheColor||this.cacheIntensity!==s.intensity)&&(this.material.color.copy(s.color).multiplyScalar(s.intensity),this.cacheColor=s.color.getHex())}}generateShape(){this.geometry.dispose(),this.geometry=new i.PlaneGeometry(this.target.width,this.target.height,4,4),this.geometry.computeBoundingBox()}raycast(e,t){const s=this.target,o=this.cacheBox;o.copy(this.geometry.boundingBox),o.applyMatrix4(s.matrixWorld),e.ray.intersectBox(o,this.cacheVector3)&&t.push({distance:e.ray.origin.distanceTo(s.position),object:s,point:s.position})}dispose(){this.geometry.dispose(),this.material.dispose()}}class D extends i.LineSegments{constructor(e){super(),this.type="VisSpotLightHelper",this.geometry=new i.BufferGeometry;const t=[-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1,0,0,1,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,0,0,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,-.707,0,-.707,.707,0,.707,.707,0,-.707,-.707,0,.707];this.geometry.setAttribute("position",new i.Float32BufferAttribute(t,3)),this.material=d(),this.geometry.boundingSphere;const s=new i.BufferGeometry,o=[0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let h=0,m=1,g=32;h<g;h++,m++){const y=h/g*Math.PI*2,R=m/g*Math.PI*2;o.push(Math.cos(y),Math.sin(y),1,Math.cos(R),Math.sin(R),1)}s.setAttribute("position",new i.Float32BufferAttribute(o,3));const a=d(),l=new i.LineSegments(s,a);l.material.color.copy(e.color).multiplyScalar(e.intensity);const c=e.distance?e.distance:1e3,u=c*Math.tan(e.angle);l.scale.set(u,u,c),l.raycast=()=>{},this.add(l),this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.target=e,this.shape=l,this.sphere=new i.Sphere(new i.Vector3(0,0,0),1),this.cacheColor=e.color.getHex(),this.cacheDistance=e.distance,this.cacheAngle=e.angle,this.cacheVector3=new i.Vector3,this.onBeforeRender=()=>{const h=this.target,m=this.shape;let g=!1;if(h.distance!==this.cacheDistance&&(this.cacheDistance=h.distance,m.scale.z=h.distance,g=!0),h.angle!==this.cacheAngle&&(this.cacheAngle=h.angle,g=!0),g){const y=h.distance*Math.tan(h.angle);m.scale.set(y,y,h.distance)}h.color.getHex()!==this.cacheColor&&(m.material.color.copy(h.color).multiplyScalar(h.intensity),this.cacheColor=h.color.getHex()),m.lookAt(h.target.position)}}raycast(e,t){const s=this.target,o=s.matrixWorld,a=this.sphere;a.set(this.cacheVector3.set(0,0,0),1),a.applyMatrix4(o),e.ray.intersectsSphere(a)&&t.push({distance:e.ray.origin.distanceTo(s.position),object:s,point:s.position})}dispose(){this.shape.geometry.dispose(),this.shape.material.dispose(),this.geometry.dispose(),this.material.dispose()}}const S=class S extends i.Points{constructor(e){super(),this.type="GeometricOriginHelper",this.target=e,this.geometry=new i.BufferGeometry().setAttribute("position",new i.BufferAttribute(new Float32Array([0,0,0]),3)),this.material=new i.PointsMaterial({map:S.colorTexture,transparent:!0,alphaTest:.1,depthFunc:i.AlwaysDepth,size:10,sizeAttenuation:!1}),this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.renderOrder=100,this.raycast=()=>{}}dispose(){}};S.colorTexture=new i.CanvasTexture(new x.CanvasGenerator({width:32,height:32}).draw(e=>{e.beginPath(),e.fillStyle="rgba(0, 0, 0, 0)",e.fillRect(0,0,32,32),e.closePath(),e.beginPath(),e.fillStyle="rgb(255, 163, 0)",e.strokeStyle="black",e.lineWidth=1,e.arc(16,16,15,0,2*Math.PI),e.stroke(),e.fill(),e.closePath()}).get());let f=S;class O extends i.LineSegments{constructor(e){const t=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),s=new Float32Array(8*3),o=new i.BufferGeometry;o.setIndex(new i.BufferAttribute(t,1)),o.setAttribute("position",new i.BufferAttribute(s,3)),super(o,new i.LineBasicMaterial({color:15662848,toneMapped:!1})),this.type="BoundingBoxHelper",this.cacheBox=new i.Box3,this.compareBox=new i.Box3,this.matrixAutoUpdate=!1,this.raycast=()=>{},this.target=e,this.onBeforeRender=()=>{this.update()}}update(){if(this.cacheBox.setFromObject(this.target),this.cacheBox.isEmpty()||this.cacheBox.equals(this.compareBox))return;this.compareBox.copy(this.cacheBox);const e=this.cacheBox.min,t=this.cacheBox.max,s=this.geometry.attributes.position,o=s.array;o[0]=t.x,o[1]=t.y,o[2]=t.z,o[3]=e.x,o[4]=t.y,o[5]=t.z,o[6]=e.x,o[7]=e.y,o[8]=t.z,o[9]=t.x,o[10]=e.y,o[11]=t.z,o[12]=t.x,o[13]=t.y,o[14]=e.z,o[15]=e.x,o[16]=t.y,o[17]=e.z,o[18]=e.x,o[19]=e.y,o[20]=e.z,o[21]=t.x,o[22]=e.y,o[23]=e.z,s.needsUpdate=!0,this.geometry.computeBoundingSphere()}dispose(){}}class U extends i.LineSegments{constructor(e){let t=5;if(e.geometry){const c=e.geometry;!c.boundingSphere&&c.computeBoundingSphere(),t=c.boundingSphere.radius*.8}const s=[0,0,0,t,0,0,0,0,0,0,t,0,0,0,0,0,0,t],o=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],a=new i.BufferGeometry;a.setAttribute("position",new i.Float32BufferAttribute(s,3)),a.setAttribute("color",new i.Float32BufferAttribute(o,3));const l=new i.LineBasicMaterial({vertexColors:!0,toneMapped:!1,depthFunc:i.AlwaysDepth});super(a,l),this.target=e,this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.renderOrder=100,this.raycast=()=>{}}dispose(){}}const N=`

#include <common>

void main() {
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

  bool isPerspective = isPerspectiveMatrix( projectionMatrix );

  if ( isPerspective ) scale *= - mvPosition.z;

	vec2 alignedPosition = position.xy * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( 0.0 ) * alignedPosition.x - sin( 0.0 ) * alignedPosition.y;
	rotatedPosition.y = sin( 0.0 ) * alignedPosition.x + cos( 0.0 ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

}

`,$=`

uniform vec3 color;

void main() {
  gl_FragColor = vec4(color, 1.0);
}
`;let I=class extends i.ShaderMaterial{constructor(){super(),this.vertexShader=N,this.fragmentShader=$,this.uniforms={color:{value:new i.Color("white")}}}};class G extends i.LineSegments{constructor(e){super(),this.type="VisCSS2DPlaneHelper",this.geometry=new i.EdgesGeometry(new i.PlaneGeometry(1,1)),this.geometry.computeBoundingBox(),this.material=new I,this.scale.copy(e.matrixScale),this.position.set(e.position.x,e.position.y,e.position.z),this.target=e;const t=new MutationObserver(()=>{this.scale.copy(e.matrixScale)});t.observe(e.element,{attributeFilter:["style"]}),this.observer=t,this.onBeforeRender=()=>{this.position.set(this.target.position.x,this.target.position.y,this.target.position.z)},this.raycast=()=>{}}dispose(){this.observer.disconnect()}}class j extends i.LineSegments{constructor(e){super(),this.type="VisCSS3DPlaneHelper",this.geometry=new i.EdgesGeometry(new i.PlaneGeometry(e.width,e.height)),this.geometry.computeBoundingBox(),this.material=d(),this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.target=e;const t=new MutationObserver(()=>{this.geometry.dispose(),this.geometry=new i.EdgesGeometry(new i.PlaneGeometry(e.width,e.height)),this.geometry.computeBoundingBox()});t.observe(e.element,{attributeFilter:["style"]}),this.observer=t,this.raycast=()=>{},this.updateMatrixWorld=()=>{}}dispose(){this.observer.disconnect()}}const _=`
uniform float rotation2D;

#include <common>

void main() {
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

	vec2 alignedPosition = position.xy * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation2D ) * alignedPosition.x - sin( rotation2D ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation2D ) * alignedPosition.x + cos( rotation2D ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

}

`,q=`

uniform vec3 color;

void main() {
  gl_FragColor = vec4(color, 1.0);
}
`;class k extends i.ShaderMaterial{constructor(){super(),this.vertexShader=_,this.fragmentShader=q,this.uniforms={color:{value:new i.Color("white")},rotation2D:{value:0}}}}class z extends i.LineSegments{constructor(e){super(),this.type="VisCSS3DSpriteHelper",this.geometry=new i.EdgesGeometry(new i.PlaneGeometry(1,1)),this.geometry.computeBoundingBox(),this.material=new k,this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.target=e;const t=new MutationObserver(()=>{this.geometry.dispose(),this.geometry=new i.EdgesGeometry(new i.PlaneGeometry(e.width,e.height)),this.geometry.computeBoundingBox()});t.observe(e.element,{attributeFilter:["style"]}),this.observer=t,this.onBeforeRender=()=>{this.material.uniforms.rotation2D.value=this.target.rotation2D},this.raycast=()=>{},this.updateMatrixWorld=()=>{}}dispose(){this.observer.disconnect()}}const P=class P extends i.Sprite{constructor(e){super(),this.type="VisGroupHelper",this.target=e,this.geometry.computeBoundingBox(),this.material=new i.SpriteMaterial({map:P.colorTexture}),this.material.depthTest=!1,this.material.depthWrite=!1,this.scale.set(5,5,5);const t=this.updateMatrixWorld.bind(this);this.updateMatrixWorld=s=>{const o=this.position,a=this.target.position;o.x=a.x,o.y=a.y,o.z=a.z,t(s)}}raycast(e,t){const s=this.matrixWorld,o=this.geometry.boundingBox.clone();if(o.applyMatrix4(s),e.ray.intersectsBox(o)){const a=this.target;t.push({distance:e.ray.origin.distanceTo(a.position),object:a,point:a.position})}}dispose(){this.geometry.dispose(),this.material.dispose()}};P.colorTexture=new i.CanvasTexture(new x.CanvasGenerator({width:512,height:512}).draw(e=>{e.beginPath(),e.fillStyle="rgba(0, 0, 0, 0)",e.fillRect(0,0,512,512),e.closePath(),e.translate(256,200),e.beginPath(),e.fillStyle="yellow",e.fillRect(-200,0,400,200),e.closePath(),e.beginPath(),e.fillStyle="yellow",e.fillRect(-200,-70,200,70),e.closePath()}).get());let w=P;const M=class M extends i.Points{constructor(e){super(),this.type="VisLineHelper",this.target=e,this.geometry.dispose(),this.geometry.copy(e.geometry),this.cachaGeometryUUid=e.geometry.uuid,this.material=new i.PointsMaterial({color:"rgb(255, 255, 255)",alphaMap:M.alphaTexture,transparent:!0,size:5,sizeAttenuation:!1}),this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.renderOrder=-1,this.raycast=()=>{},this.onBeforeRender=()=>{const t=this.target;t.geometry.uuid!==this.cachaGeometryUUid&&(this.geometry.dispose(),this.geometry=t.geometry.clone(),this.cachaGeometryUUid=t.geometry.uuid)}}dispose(){this.geometry.dispose(),this.material.dispose()}};M.alphaTexture=new i.CanvasTexture(new x.CanvasGenerator({width:512,height:512,bgColor:"rgb(0, 0, 0)"}).draw(e=>{e.beginPath(),e.fillStyle="rgb(255, 255, 255)",e.arc(256,256,200,0,Math.PI*2),e.fill(),e.closePath()}).getDom());let b=M;class V extends i.LineSegments{constructor(e){super(),this.type="VisMeshHelper";const t=1;this.target=e,this.geometry=new i.EdgesGeometry(e.geometry,t),this.cachaGeometryUUid=e.geometry.uuid,this.material=d(),this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.updateMatrixWorld=()=>{},this.raycast=()=>{},this.onBeforeRender=()=>{const s=this.target;s.geometry.uuid!==this.cachaGeometryUUid&&(this.geometry.dispose(),this.geometry=new i.EdgesGeometry(s.geometry,t),this.cachaGeometryUUid=s.geometry.uuid)}}dispose(){this.geometry.dispose(),this.material.dispose()}}const B=class B extends i.Points{constructor(e){super(),this.type="VisPointsHelper",this.target=e,this.geometry.dispose(),this.geometry.copy(e.geometry),this.material.dispose(),this.material=new i.PointsMaterial({color:"rgb(255, 255, 255)",alphaMap:B.alphaTexture,transparent:!0});const t=Array.isArray(e.material)?e.material[0]:e.material;t instanceof i.PointsMaterial&&(this.material.size=t.size,this.material.sizeAttenuation=t.sizeAttenuation),this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.raycast=()=>{}}dispose(){this.geometry.dispose(),this.material.dispose()}};B.alphaTexture=new i.CanvasTexture(new x.CanvasGenerator({width:512,height:512,bgColor:"rgb(0, 0, 0)"}).draw(e=>{e.beginPath(),e.strokeStyle="rgb(255, 255, 255)",e.lineWidth=4,e.strokeRect(0,0,512,512),e.closePath()}).get());let v=B;const Y=`

uniform float rotation;
uniform vec2 center;
uniform bool sizeAttenuation;

#include <common>

void main() {
  vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

	if (!sizeAttenuation) {
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );

		if ( isPerspective ) scale *= - mvPosition.z;
  }

	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

}

`,J=`

uniform vec3 color;

void main() {
  gl_FragColor = vec4(color, 1.0);
}
`;class K extends i.ShaderMaterial{constructor(){super(),this.vertexShader=Y,this.fragmentShader=J,this.uniforms={color:{value:new i.Color("white")},center:{value:new i.Vector2(.5,.5)},rotation:{value:0},sizeAttenuation:{value:!1}}}}class T extends i.LineSegments{constructor(e){super(),this.type="VisSpriteHelper",this.geometry=new i.EdgesGeometry(new i.PlaneGeometry(1,1)),this.geometry.computeBoundingBox(),this.material=new K,this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.target=e,this.onBeforeRender=()=>{this.material.uniforms.rotation.value=this.target.material.rotation,this.material.uniforms.sizeAttenuation.value=this.target.material.sizeAttenuation},this.raycast=()=>{}}dispose(){this.geometry.dispose(),this.material.dispose()}}const E=function(){return Object.assign(p.getBasicConfig(),{})},F=function(){return Object.assign(E(),{target:"",shape:!0,boundingBox:!1,geometricOrigin:!1,localAxes:!1})};class Q extends L.EventDispatcher{constructor(){super(),this.shapeMap={PointLight:C,SpotLight:D,DirectionalLight:H,RectAreaLight:W,PerspectiveCamera:A,OrthographicCamera:A,Mesh:V,Group:w,Sprite:T,Points:v,Line:b,CSS3DPlane:j,CSS3DSprite:z,CSS2DPlane:G}}generateShape(){if(this.target){if(!this.shapeMap[this.target.type]){console.warn(`object helper can not support ${this.target.type}`);return}const e=new this.shapeMap[this.target.type](this.target);return this.shape=e,e}return null}generateBoundingBox(){if(this.target){const e=new O(this.target);return this.boundingBox=e,e}return null}generateGeometricOrigin(){if(this.target){const e=new f(this.target);return this.geometricOrigin=e,e}return null}generateLocalAxes(){if(this.target){const e=new U(this.target);return this.localAxes=e,e}return null}dispose(e){if(e&&this[e]){this[e].removeFromParent(),this[e].dispose(),this[e]=void 0;return}this.target=void 0,["shape","boundingBox","geometricOrigin","localAxes"].forEach(t=>{this[t]&&(this[t].removeFromParent(),this[t].dispose(),this[t]=void 0)})}}const X=p.defineModel({type:"ObjectHelper",config:F,context(){return{helperEventMap:{}}},shared:{addHelper(r,e,t,s){const o={shape:e.generateShape.bind(e),boundingBox:e.generateBoundingBox.bind(e),geometricOrigin:e.generateGeometricOrigin.bind(e),localAxes:e.generateLocalAxes.bind(e)};if(!o[r]){console.warn(`Object helper Model: can not found helper: ${r} in generator.`);return}const a=o[r]();s.toAsync(l=>{var h;const c=s.toObject(t.target);if(!c||!c.parent)return l&&console.warn(`object helper model can not fund object parent: ${c}`),!1;c.parent.add(a);const u=()=>{c.parent.add(a)};return(h=s.toModel(t.target))==null||h.on(`${p.MODEL_EVENT.COMPILED_ATTR}:parent`,u),s.helperEventMap[r]=u,!0})},removeHelper(r,e,t,s){var l;if(!s.toObject(t.target)){console.warn(`object helper model: can not fund object: ${t.target}`);return}const a=s.helperEventMap[r];a&&((l=s.toModel(t.target))==null||l.off(`${p.MODEL_EVENT.COMPILED_ATTR}:parent`,a)),e.dispose(r)}},commands:{set:{shape({model:r,config:e,target:t,value:s,engine:o}){s&&!t.shape?r.addHelper("shape",t,e,r):!s&&t.shape&&r.removeHelper("shape",t,e,r)},boundingBox({model:r,config:e,target:t,value:s,engine:o}){s&&!t.boundingBox?r.addHelper("boundingBox",t,e,r):!s&&t.boundingBox&&r.removeHelper("boundingBox",t,e,r)},geometricOrigin({model:r,config:e,target:t,value:s,engine:o}){s&&!t.geometricOrigin?r.addHelper("geometricOrigin",t,e,r):!s&&t.geometricOrigin&&r.removeHelper("geometricOrigin",t,e,r)},localAxes({model:r,config:e,target:t,value:s,engine:o}){s&&!t.localAxes?r.addHelper("localAxes",t,e,r):!s&&t.localAxes&&r.removeHelper("localAxes",t,e,r)}}},create({model:r,config:e,engine:t}){const s=new Q;if(e.target){const o=t.getObjectBySymbol(e.target),a=t.getConfigBySymbol(e.target);a.helper=e.vid,o?(s.target=o,e.shape&&r.addHelper("shape",s,e,r),e.boundingBox&&r.addHelper("boundingBox",s,e,r),e.geometricOrigin&&r.addHelper("geometricOrigin",s,e,r),e.localAxes&&r.addHelper("localAxes",s,e,r)):console.warn(`object helper processor can not found target in engine ${e.target}`)}return s},dispose({target:r}){r.dispose()},expand:[{models:new RegExp("Mesh|Light|Line|Points|Group|Object3D"),config:()=>({helper:""}),commands:{add:{helper(){}},set:{helper(){}}}}]}),Z=p.defineModule({type:"helper",models:[X],lifeOrder:p.SUPPORT_LIFE_CYCLE.FOUR});n.BoundingBoxHelper=O,n.CSS2DPlaneHelper=G,n.CSS3DPlaneHelper=j,n.CSS3DSpriteHelper=z,n.CameraHelper=A,n.DirectionalLightHelper=H,n.GeometricOriginHelper=f,n.GroupHelper=w,n.LineHelper=b,n.LocalAxesHelper=U,n.MeshHelper=V,n.PointLightHelper=C,n.PointsHelper=v,n.RectAreaLightHelper=W,n.SpotLightHelper=D,n.SpriteHelper=T,n.default=Z,n.getHelperConfig=E,n.getObjectHelperConfig=F,Object.defineProperties(n,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
