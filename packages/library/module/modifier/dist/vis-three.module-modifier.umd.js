(function(n,t){typeof exports=="object"&&typeof module<"u"?t(exports,require("@vis-three/tdcm"),require("@vis-three/library-modifier"),require("@vis-three/utils")):typeof define=="function"&&define.amd?define(["exports","@vis-three/tdcm","@vis-three/library-modifier","@vis-three/utils"],t):(n=typeof globalThis<"u"?globalThis:n||self,t((n["vis-three"]=n["vis-three"]||{},n["vis-three"]["module-modifier"]={}),n.tdcm,n.libraryModifier,n.utils))})(this,function(n,t,g,T){"use strict";class y extends t.Compiler{constructor(r){super(r),this.cacheRenderFun=new Map,this.sourceModifiers=new Map}integrateModifer(r){this.sourceModifiers.has(r.source)||this.sourceModifiers.set(r.source,[]);const o=this.sourceModifiers.get(r.source);o.includes(r)||o.push(r)}chainRender(r){if(!this.sourceModifiers.has(r.source)){console.error(`${this.MODULE} compiler can not found modifier list`,r);return}const o=this.sourceModifiers.get(r.source);o.includes(r)||console.error(`${this.MODULE} compiler: can not found this modifier in source list`,r);const c=o.slice(o.indexOf(r)+1,o.length);for(const s of c)s.render()}}const E=function(){return Object.assign(t.getBasicConfig(),{name:"",visible:!0,source:"",index:0})},h=function(){return Object.assign(E(),{target:"",mode:"subtract"})},l=t.defineModel({type:"BooleanModifier",config:h,shared:{modifyKey:["position.x","position.y","position.z","rotation.x","rotation.y","rotation.z","scale.x","scale.y","scale.z","parent"]},context(){return{renderFun:()=>{},cacheTarget:{}}},commands:{set:{source:()=>{},target:({model:e,target:r,config:o,engine:c})=>{e.toAsync(s=>{var d,a;if(o.target){const i=c.compilerManager.getObjectBySymbol(o.target);if(!i)return s&&console.warn(`Boolean modifier processor can not found object by vid: ${o.target}`),!1;r.target=i;const u=e.cacheTarget;if(u){const M=e.toModel(u);for(const O of e.modifyKey)M==null||M.off(`${t.MODEL_EVENT.COMPILED_ATTR}:${O}`,e.renderFun);(d=e.toModel(u.geometry))==null||d.off(t.MODEL_EVENT.COMPILED_UPDATE,e.renderFun)}const f=e.toModel(o.target);for(const M of e.modifyKey)f==null||f.off(`${t.MODEL_EVENT.COMPILED_ATTR}:${M}`,e.renderFun);return(a=e.toModel(i.geometry))==null||a.off(t.MODEL_EVENT.COMPILED_UPDATE,e.renderFun),e.cacheTarget=i,e.renderFun(),!0}return!0})},$reg:[{reg:new RegExp(".*"),handler({model:e,value:r,key:o,target:c}){c[o]=r,e.renderFun()}}]}},create({model:e,config:r,engine:o,compiler:c}){const s=new g.BooleanModifier({mode:r.mode});return e.renderFun=()=>{s.render(),c.chainRender(s)},e.toAsync(d=>{var a;if(r.source){const i=o.compilerManager.getObjectBySymbol(r.source);if(!i)return d&&console.warn(`Boolean modifier processor can not found object by vid: ${r.source}`),!1;const u=e.toModel(r.source);for(const f of e.modifyKey)u==null||u.on(`${t.MODEL_EVENT.COMPILED_ATTR}:${f}`,e.renderFun);return(a=e.toModel(i.geometry))==null||a.on(t.MODEL_EVENT.COMPILED_UPDATE,e.renderFun),s.source=i,c.integrateModifer(s),e.renderFun(),!0}return!0}),e.toAsync(d=>{var a;if(r.target){const i=o.compilerManager.getObjectBySymbol(r.target);if(!i)return d&&console.warn(`Boolean modifier processor can not found object by vid: ${r.target}`),!1;s.target=i;const u=e.toModel(r.target);for(const f of e.modifyKey)u==null||u.on(`${t.MODEL_EVENT.COMPILED_ATTR}:${f}`,e.renderFun);return(a=e.toModel(i.geometry))==null||a.on(t.MODEL_EVENT.COMPILED_UPDATE,e.renderFun),e.cacheTarget=i,e.renderFun(),!0}return!0}),T.syncObject(r,s,{target:!0,source:!0}),s},dispose({target:e}){e.dispose()}}),p=t.defineModule({type:"modifier",compiler:y,models:[l],lifeOrder:t.SUPPORT_LIFE_CYCLE.NINE});n.ModifierCompiler=y,n.default=p,n.getBooleanModifierConfig=h,n.getModifierConfig=E,Object.defineProperties(n,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
