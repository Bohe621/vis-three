(function(r,e){typeof exports=="object"&&typeof module!="undefined"?e(exports,require("@vis-three/middleware"),require("@vis-three/library-modifier"),require("@vis-three/utils")):typeof define=="function"&&define.amd?define(["exports","@vis-three/middleware","@vis-three/library-modifier","@vis-three/utils"],e):(r=typeof globalThis!="undefined"?globalThis:r||self,e((r["vis-three"]=r["vis-three"]||{},r["vis-three"]["module-modifier"]={}),r.middleware,r.libraryModifier,r.utils))})(this,function(r,e,f,d){"use strict";var b=Object.defineProperty;var C=(r,e,f)=>e in r?b(r,e,{enumerable:!0,configurable:!0,writable:!0,value:f}):r[e]=f;var g=(r,e,f)=>(C(r,typeof e!="symbol"?e+"":e,f),f);const p=function(){return Object.assign(e.getSymbolConfig(),{name:"",visible:!0,source:"",index:0})},h=function(){return Object.assign(p(),{target:"",mode:"subtract"})},l=["position.x","position.y","position.z","rotation.x","rotation.y","rotation.z","scale.x","scale.y","scale.z","parent"],E=new Map;var v=e.defineProcessor({type:"BooleanModifier",config:h,commands:{set:{source:()=>{},target:({target:n,config:c,engine:t,compiler:o})=>{e.globalAntiShake.exec(i=>{if(c.target){const u=t.compilerManager.getObjectBySymbol(c.target);if(!u)return i&&console.warn(`Boolean modifier processor can not found object by vid: ${c.target}`),!1;n.target=u;const s=o.cacheRenderFun.get(n);if(!s)return console.error(`can not found cache render fun in ${o.MODULE} compiler`),!0;const a=E.get(n);if(a){for(const M of l)e.Bus.compilerEvent.off(a,`${e.COMPILER_EVENT.COMPILE}:${M}`,s);e.Bus.compilerEvent.off(a.geometry,e.COMPILER_EVENT.UPDATE,s)}for(const M of l)e.Bus.compilerEvent.on(u,`${e.COMPILER_EVENT.COMPILE}:${M}`,s);return e.Bus.compilerEvent.on(u.geometry,e.COMPILER_EVENT.UPDATE,s),E.set(n,u),s(),!0}return!0})},$reg:[{reg:new RegExp(".*"),handler({value:n,key:c,target:t,compiler:o}){t[c]=n;const i=o.cacheRenderFun.get(t);if(!i){console.error(`can not found cache render fun in ${o.MODULE} compiler`);return}i()}}]}},create:function(n,c,t){const o=new f.BooleanModifier({mode:n.mode}),i=()=>{o.render(),t.chainRender(o)};return t.cacheRenderFun.set(o,i),e.globalAntiShake.exec(u=>{if(n.source){const s=c.compilerManager.getObjectBySymbol(n.source);if(!s)return u&&console.warn(`Boolean modifier processor can not found object by vid: ${n.source}`),!1;for(const a of l)e.Bus.compilerEvent.on(s,`${e.COMPILER_EVENT.COMPILE}:${a}`,i);return e.Bus.compilerEvent.check(s.geometry)&&e.Bus.compilerEvent.on(s.geometry,e.COMPILER_EVENT.UPDATE,i),o.source=s,t.integrateModifer(o),i(),!0}return!0}),e.globalAntiShake.exec(u=>{if(n.target){const s=c.compilerManager.getObjectBySymbol(n.target);if(!s)return u&&console.warn(`Boolean modifier processor can not found object by vid: ${n.target}`),!1;o.target=s;for(const a of l)e.Bus.compilerEvent.on(s,`${e.COMPILER_EVENT.COMPILE}:${a}`,i);return e.Bus.compilerEvent.on(s.geometry,e.COMPILER_EVENT.UPDATE,i),E.set(o,s),i(),!0}return!0}),d.syncObject(n,o,{target:!0,source:!0}),o},dispose:function(n,c,t){n.dispose()}});class y extends e.Compiler{constructor(){super();g(this,"cacheRenderFun",new Map);g(this,"sourceModifiers",new Map)}integrateModifer(t){this.sourceModifiers.has(t.source)||this.sourceModifiers.set(t.source,[]);const o=this.sourceModifiers.get(t.source);o.includes(t)||o.push(t)}chainRender(t){if(!this.sourceModifiers.has(t.source)){console.error(`${this.MODULE} compiler can not found modifier list`,t);return}const o=this.sourceModifiers.get(t.source);o.includes(t)||console.error(`${this.MODULE} compiler: can not found this modifier in source list`,t);const i=o.slice(o.indexOf(t)+1,o.length);for(const u of i)u.render()}}var O={type:"modifier",compiler:y,rule:function(n,c){e.Rule(n,c)},processors:[v],lifeOrder:e.SUPPORT_LIFE_CYCLE.NINE};r.ModifierCompiler=y,r.default=O,r.getBooleanModifierConfig=h,r.getModifierConfig=p,Object.defineProperties(r,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
