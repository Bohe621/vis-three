(function(e,i){typeof exports=="object"&&typeof module!="undefined"?module.exports=i(require("@vis-three/middleware"),require("@vis-three/library-modifier"),require("@vis-three/utils")):typeof define=="function"&&define.amd?define(["@vis-three/middleware","@vis-three/library-modifier","@vis-three/utils"],i):(e=typeof globalThis!="undefined"?globalThis:e||self,e["vis-three"]=e["vis-three"]||{},e["vis-three"]["module-modifier"]=i(e.middleware,e.libraryModifier,e.utils))})(this,function(e,i,f){"use strict";var v=Object.defineProperty;var C=(e,i,f)=>i in e?v(e,i,{enumerable:!0,configurable:!0,writable:!0,value:f}):e[i]=f;var l=(e,i,f)=>(C(e,typeof i!="symbol"?i+"":i,f),f);const h=function(){return Object.assign(e.getSymbolConfig(),{name:"",visible:!0,source:"",index:0})},g=function(){return Object.assign(h(),{target:"",mode:"subtract"})},E=["position.x","position.y","position.z","rotation.x","rotation.y","rotation.z","scale.x","scale.y","scale.z","parent"],p=new Map;var d=e.defineProcessor({type:"BooleanModifier",config:g,commands:{set:{source:()=>{},target:({target:o,config:c,engine:r,compiler:t})=>{e.globalAntiShake.exec(s=>{if(c.target){const u=r.compilerManager.getObjectBySymbol(c.target);if(!u)return s&&console.warn(`Boolean modifier processor can not found object by vid: ${c.target}`),!1;o.target=u;const n=t.cacheRenderFun.get(o);if(!n)return console.error(`can not found cache render fun in ${t.MODULE} compiler`),!0;const a=p.get(o);if(a){for(const M of E)e.Bus.compilerEvent.off(a,`${e.COMPILER_EVENT.COMPILE}:${M}`,n);e.Bus.compilerEvent.off(a.geometry,`${e.COMPILER_EVENT.COMPILE}:update`,n)}for(const M of E)e.Bus.compilerEvent.on(u,`${e.COMPILER_EVENT.COMPILE}:${M}`,n);return e.Bus.compilerEvent.on(u.geometry,`${e.COMPILER_EVENT.COMPILE}:update`,n),p.set(o,u),n(),!0}return!0})},$reg:[{reg:new RegExp(".*"),handler({value:o,key:c,target:r,compiler:t}){r[c]=o;const s=t.cacheRenderFun.get(r);if(!s){console.error(`can not found cache render fun in ${t.MODULE} compiler`);return}s()}}]}},create:function(o,c,r){const t=new i.BooleanModifier({mode:o.mode}),s=()=>{t.render(),r.chainRender(t)};return r.cacheRenderFun.set(t,s),e.globalAntiShake.exec(u=>{if(o.source){const n=c.compilerManager.getObjectBySymbol(o.source);if(!n)return u&&console.warn(`Boolean modifier processor can not found object by vid: ${o.source}`),!1;t.source=n;for(const a of E)e.Bus.compilerEvent.on(n,`${e.COMPILER_EVENT.COMPILE}:${a}`,s);return e.Bus.compilerEvent.on(n.geometry,`${e.COMPILER_EVENT.COMPILE}:update`,s),r.integrateModifer(t),s(),!0}return!0}),e.globalAntiShake.exec(u=>{if(o.target){const n=c.compilerManager.getObjectBySymbol(o.target);if(!n)return u&&console.warn(`Boolean modifier processor can not found object by vid: ${o.target}`),!1;t.target=n;for(const a of E)e.Bus.compilerEvent.on(n,`${e.COMPILER_EVENT.COMPILE}:${a}`,s);return e.Bus.compilerEvent.on(n.geometry,`${e.COMPILER_EVENT.COMPILE}:update`,s),p.set(t,n),s(),!0}return!0}),f.syncObject(o,t,{target:!0,source:!0}),t},dispose:function(o,c,r){o.dispose()}});class y extends e.Compiler{constructor(){super();l(this,"cacheRenderFun",new Map);l(this,"sourceModifiers",new Map)}integrateModifer(r){this.sourceModifiers.has(r.source)||this.sourceModifiers.set(r.source,[]);const t=this.sourceModifiers.get(r.source);t.includes(r)||t.push(r)}chainRender(r){if(!this.sourceModifiers.has(r.source)){console.error(`${this.MODULE} compiler can not found modifier list`,r);return}const t=this.sourceModifiers.get(r.source);t.includes(r)||console.error(`${this.MODULE} compiler: can not found this modifier in source list`,r);const s=t.slice(t.indexOf(r)+1,t.length);for(const u of s)u.render()}}var O={type:"modifier",compiler:y,rule:function(o,c){e.Rule(o,c)},processors:[d],lifeOrder:e.SUPPORT_LIFE_CYCLE.NINE};return O});
