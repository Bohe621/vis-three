(function(n,u){typeof exports=="object"&&typeof module!="undefined"?u(exports,require("@vis-three/middleware"),require("three"),require("three/examples/jsm/postprocessing/Pass"),require("three/examples/jsm/shaders/LuminosityHighPassShader"),require("three/examples/jsm/postprocessing/SMAAPass"),require("three/examples/jsm/postprocessing/SSRPass"),require("three/examples/jsm/objects/ReflectorForSSRPass"),require("three/examples/jsm/postprocessing/UnrealBloomPass")):typeof define=="function"&&define.amd?define(["exports","@vis-three/middleware","three","three/examples/jsm/postprocessing/Pass","three/examples/jsm/shaders/LuminosityHighPassShader","three/examples/jsm/postprocessing/SMAAPass","three/examples/jsm/postprocessing/SSRPass","three/examples/jsm/objects/ReflectorForSSRPass","three/examples/jsm/postprocessing/UnrealBloomPass"],u):(n=typeof globalThis!="undefined"?globalThis:n||self,u((n["vis-three"]=n["vis-three"]||{},n["vis-three"]["module-pass"]={}),n.middleware,n.three,n.Pass,n.LuminosityHighPassShader,n.SMAAPass,n.SSRPass,n.ReflectorForSSRPass,n.UnrealBloomPass))})(this,function(n,u,i,P,w,A,V,H,F){"use strict";var I=Object.defineProperty;var N=(n,u,i)=>u in n?I(n,u,{enumerable:!0,configurable:!0,writable:!0,value:i}):n[u]=i;var o=(n,u,i)=>(N(n,typeof u!="symbol"?u+"":u,i),i);class C extends u.Compiler{constructor(){super();o(this,"composer")}useEngine(e){return super.useEngine(e),e.effectComposer?(this.composer=e.effectComposer,this):(console.warn("engine need install effectComposer plugin that can use pass compiler."),this)}add(e){const r=super.add(e);return r&&this.composer.addPass(r),r}remove(e){if(!this.map.has(e.vid))return console.warn(`PassCompiler can not found this vid pass: ${e.vid}.`),this;const r=this.map.get(e.vid);return this.composer.removePass(r),super.remove(e),this}}const z=function(t,s){u.Rule(t,s)},b=class extends P.Pass{constructor(e=new i.Vector2(256,256),r=1,l=0,c=0,m=new i.Scene,S=new i.PerspectiveCamera,x){super();o(this,"resolution");o(this,"strength");o(this,"radius");o(this,"threshold");o(this,"selectedObjects",[]);o(this,"renderScene");o(this,"renderCamera");o(this,"clearColor",new i.Color(0,0,0));o(this,"renderTargetsHorizontal",[]);o(this,"renderTargetsVertical",[]);o(this,"nMips",5);o(this,"selectRenderTarget");o(this,"renderTargetBright");o(this,"highPassUniforms");o(this,"materialHighPassFilter");o(this,"separableBlurMaterials",[]);o(this,"compositeMaterial");o(this,"bloomTintColors");o(this,"mixMaterial");o(this,"enabled",!0);o(this,"needsSwap",!1);o(this,"_oldClearColor",new i.Color);o(this,"oldClearAlpha",1);o(this,"basic",new i.MeshBasicMaterial);o(this,"fsQuad",new P.FullScreenQuad);o(this,"materialCache",new Map);o(this,"sceneBackgroundCache",null);o(this,"overrideBackground",new i.Color("black"));o(this,"overrideMeshMaterial",new i.MeshBasicMaterial({color:"black"}));o(this,"overrideLineMaterial",new i.LineBasicMaterial({color:"black"}));o(this,"overridePointsMaterial",new i.PointsMaterial({color:"black"}));o(this,"overrideSpriteMaterial",new i.SpriteMaterial({color:"black"}));this.resolution=e,this.strength=r,this.radius=l,this.threshold=c,this.renderScene=m,this.renderCamera=S,this.selectedObjects=x;let d=Math.round(this.resolution.x/2),h=Math.round(this.resolution.y/2);this.selectRenderTarget=new i.WebGLRenderTarget(d,h),this.selectRenderTarget.texture.name="UnrealBloomPass.selected",this.selectRenderTarget.texture.generateMipmaps=!1,this.renderTargetBright=new i.WebGLRenderTarget(d,h),this.renderTargetBright.texture.name="UnrealBloomPass.bright",this.renderTargetBright.texture.generateMipmaps=!1;for(let f=0;f<this.nMips;f++){const M=new i.WebGLRenderTarget(d,h);M.texture.name="UnrealBloomPass.h"+f,M.texture.generateMipmaps=!1,this.renderTargetsHorizontal.push(M);const T=new i.WebGLRenderTarget(d,h);T.texture.name="UnrealBloomPass.v"+f,T.texture.generateMipmaps=!1,this.renderTargetsVertical.push(T),d=Math.round(d/2),h=Math.round(h/2)}w.LuminosityHighPassShader===void 0&&console.error("THREE.UnrealBloomPass relies on LuminosityHighPassShader");const a=w.LuminosityHighPassShader;this.highPassUniforms=i.UniformsUtils.clone(a.uniforms),this.highPassUniforms.luminosityThreshold.value=c,this.highPassUniforms.smoothWidth.value=.01,this.materialHighPassFilter=new i.ShaderMaterial({uniforms:this.highPassUniforms,vertexShader:a.vertexShader,fragmentShader:a.fragmentShader,defines:{}});const _=[3,5,7,9,11];d=Math.round(this.resolution.x/2),h=Math.round(this.resolution.y/2);for(let f=0;f<this.nMips;f++)this.separableBlurMaterials.push(this.getSeperableBlurMaterial(_[f])),this.separableBlurMaterials[f].uniforms.texSize.value=new i.Vector2(d,h),d=Math.round(d/2),h=Math.round(h/2);this.compositeMaterial=this.getCompositeMaterial(this.nMips),this.compositeMaterial.uniforms.blurTexture1.value=this.renderTargetsVertical[0].texture,this.compositeMaterial.uniforms.blurTexture2.value=this.renderTargetsVertical[1].texture,this.compositeMaterial.uniforms.blurTexture3.value=this.renderTargetsVertical[2].texture,this.compositeMaterial.uniforms.blurTexture4.value=this.renderTargetsVertical[3].texture,this.compositeMaterial.uniforms.blurTexture5.value=this.renderTargetsVertical[4].texture,this.compositeMaterial.uniforms.bloomStrength.value=r,this.compositeMaterial.uniforms.bloomRadius.value=.1,this.compositeMaterial.needsUpdate=!0;const q=[1,.8,.6,.4,.2];this.compositeMaterial.uniforms.bloomFactors.value=q,this.bloomTintColors=[new i.Vector3(1,1,1),new i.Vector3(1,1,1),new i.Vector3(1,1,1),new i.Vector3(1,1,1),new i.Vector3(1,1,1)],this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,this.mixMaterial=this.getMixMaterial()}dispose(){for(let e=0;e<this.renderTargetsHorizontal.length;e++)this.renderTargetsHorizontal[e].dispose();for(let e=0;e<this.renderTargetsVertical.length;e++)this.renderTargetsVertical[e].dispose();this.renderTargetBright.dispose()}setSize(e,r){let l=Math.round(e/2),c=Math.round(r/2);this.selectRenderTarget.setSize(l,c),this.renderTargetBright.setSize(l,c);for(let m=0;m<this.nMips;m++)this.renderTargetsHorizontal[m].setSize(l,c),this.renderTargetsVertical[m].setSize(l,c),this.separableBlurMaterials[m].uniforms.texSize.value=new i.Vector2(l,c),l=Math.round(l/2),c=Math.round(c/2)}render(e,r,l,c,m){if(!this.selectedObjects.length){this.renderToScreen&&(this.fsQuad.material=this.basic,this.basic.map=l.texture,e.setRenderTarget(null),e.clear(),this.fsQuad.render(e));return}e.getClearColor(this._oldClearColor),this.oldClearAlpha=e.getClearAlpha();const S=e.autoClear;e.autoClear=!1,e.setClearColor(this.clearColor,0),m&&e.state.buffers.stencil.setTest(!1);const x=new Map;for(const a of this.selectedObjects)x.set(a,!0);const d=this.materialCache;this.renderScene.background&&(this.sceneBackgroundCache=this.renderScene.background,this.renderScene.background=this.overrideBackground),this.renderScene.traverse(a=>{!x.has(a)&&!a.isLight&&a.visible&&(d.set(a,a.material),a instanceof i.Mesh?a.material=this.overrideMeshMaterial:a instanceof i.Line?a.material=this.overrideLineMaterial:a instanceof i.Points?a.material=this.overridePointsMaterial:a instanceof i.Sprite&&(a.material=this.overrideSpriteMaterial))}),e.setRenderTarget(this.selectRenderTarget),e.clear(),e.render(this.renderScene,this.renderCamera),this.renderToScreen&&(this.fsQuad.material=this.basic,this.basic.map=this.selectRenderTarget.texture,e.setRenderTarget(null),e.clear(),this.fsQuad.render(e)),this.highPassUniforms.tDiffuse.value=this.selectRenderTarget.texture,this.highPassUniforms.luminosityThreshold.value=this.threshold,this.fsQuad.material=this.materialHighPassFilter,e.setRenderTarget(this.renderTargetBright),e.clear(),this.fsQuad.render(e);let h=this.renderTargetBright;for(let a=0;a<this.nMips;a++)this.fsQuad.material=this.separableBlurMaterials[a],this.separableBlurMaterials[a].uniforms.colorTexture.value=h.texture,this.separableBlurMaterials[a].uniforms.direction.value=b.BlurDirectionX,e.setRenderTarget(this.renderTargetsHorizontal[a]),e.clear(),this.fsQuad.render(e),this.separableBlurMaterials[a].uniforms.colorTexture.value=this.renderTargetsHorizontal[a].texture,this.separableBlurMaterials[a].uniforms.direction.value=b.BlurDirectionY,e.setRenderTarget(this.renderTargetsVertical[a]),e.clear(),this.fsQuad.render(e),h=this.renderTargetsVertical[a];this.fsQuad.material=this.compositeMaterial,this.compositeMaterial.uniforms.bloomStrength.value=this.strength,this.compositeMaterial.uniforms.bloomRadius.value=this.radius,this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,e.setRenderTarget(this.renderTargetsHorizontal[0]),e.clear(),this.fsQuad.render(e),this.fsQuad.material=this.mixMaterial,this.mixMaterial.uniforms.bloom.value=this.renderTargetsHorizontal[0].texture,this.mixMaterial.uniforms.origin.value=l.texture,m&&e.state.buffers.stencil.setTest(!0),this.renderToScreen?(e.setRenderTarget(null),this.fsQuad.render(e)):(e.setRenderTarget(l),this.fsQuad.render(e)),e.setClearColor(this._oldClearColor,this.oldClearAlpha),e.autoClear=S;for(const a of d.entries())a[0].material=a[1];d.clear(),this.sceneBackgroundCache&&(this.renderScene.background=this.sceneBackgroundCache,this.sceneBackgroundCache=null)}getMixMaterial(){return new i.ShaderMaterial({blending:i.AdditiveBlending,depthTest:!1,depthWrite:!1,transparent:!0,uniforms:{bloom:{value:null},origin:{value:null}},vertexShader:`
    
        varying vec2 vUv;
    
        void main() {
    
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    
        }`,fragmentShader:`
        uniform sampler2D bloom;
        uniform sampler2D origin;
    
        varying vec2 vUv;
    
        void main() {
          vec3 bloomColor = texture2D(bloom, vUv).rgb;
          vec3 originColor = texture2D(origin, vUv).rgb;
          gl_FragColor = vec4(originColor + bloomColor, 1.0);
        }`})}getSeperableBlurMaterial(e){return new i.ShaderMaterial({defines:{KERNEL_RADIUS:e,SIGMA:e},uniforms:{colorTexture:{value:null},texSize:{value:new i.Vector2(.5,.5)},direction:{value:new i.Vector2(.5,.5)}},vertexShader:`varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,fragmentShader:`#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 texSize;
				uniform vec2 direction;

				float gaussianPdf(in float x, in float sigma) {
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
				}
				void main() {
					vec2 invSize = 1.0 / texSize;
					float fSigma = float(SIGMA);
					float weightSum = gaussianPdf(0.0, fSigma);
					vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
						float x = float(i);
						float w = gaussianPdf(x, fSigma);
						vec2 uvOffset = direction * invSize * x;
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;
						diffuseSum += (sample1 + sample2) * w;
						weightSum += 2.0 * w;
					}
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
				}`})}getCompositeMaterial(e){return new i.ShaderMaterial({defines:{NUM_MIPS:e},uniforms:{blurTexture1:{value:null},blurTexture2:{value:null},blurTexture3:{value:null},blurTexture4:{value:null},blurTexture5:{value:null},bloomStrength:{value:1},bloomFactors:{value:null},bloomTintColors:{value:null},bloomRadius:{value:0}},vertexShader:`varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,fragmentShader:`varying vec2 vUv;
				uniform sampler2D blurTexture1;
				uniform sampler2D blurTexture2;
				uniform sampler2D blurTexture3;
				uniform sampler2D blurTexture4;
				uniform sampler2D blurTexture5;
				uniform float bloomStrength;
				uniform float bloomRadius;
				uniform float bloomFactors[NUM_MIPS];
				uniform vec3 bloomTintColors[NUM_MIPS];

				float lerpBloomFactor(const in float factor) {
					float mirrorFactor = 1.2 - factor;
					return mix(factor, mirrorFactor, bloomRadius);
				}

				void main() {
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
						lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
						lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
						lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
						lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
				}`})}};let g=b;o(g,"BlurDirectionX",new i.Vector2(1,0)),o(g,"BlurDirectionY",new i.Vector2(0,1));const p=function(){return Object.assign(u.getSymbolConfig(),{vid:"",name:"",type:"Pass",index:0})},R=function(){return Object.assign(p(),{})},B=function(){return Object.assign(p(),{strength:1.5,threshold:0,radius:0})},y=function(){return Object.assign(p(),{strength:1,threshold:0,radius:0,renderScene:"",renderCamera:"",selectedObjects:[]})},k=function(){return Object.assign(p(),{camera:"",scene:"",kernelRadius:8,kernelSize:32,noiseTexture:"",output:0,minDistance:.005,maxDistance:.1})},O=function(){return Object.assign(p(),{renderer:"",scene:"",camera:"",width:0,height:0,ground:!0,groudOption:{geometry:"",color:"rgb(127, 127, 127)",textureWidth:0,textureHeight:0,clipBias:0,multisample:4},selects:[],opacity:.5,output:0,maxDistance:180,thickness:.018,bouncing:!0,distanceAttenuation:!0,fresnel:!0,infiniteThick:!0})};var W=u.defineProcessor({type:"SelectiveBloomPass",config:y,commands:{add:{selectedObjects({target:t,engine:s,value:e}){const r=s.getObject3D(e);r?t.selectedObjects.push(r):console.warn(`selectiveBloomPassProcessor: can not found vid in engine: ${e}`)}},set:{renderScene({target:t,engine:s,value:e}){const r=s.getObject3D(e);r instanceof i.Scene&&(t.renderScene=r)},renderCamera({target:t,engine:s,value:e}){const r=s.getObject3D(e);r instanceof i.Camera&&(t.renderCamera=r)},selectedObjects({target:t,config:s,engine:e}){const r=s.selectedObjects.map(l=>{const c=e.getObject3D(l);if(c)return c;console.warn(`selectiveBloomPassProcessor: can not found vid in engine: ${l}`)}).filter(l=>l);t.selectedObjects=r}},delete:{selectedObjects({target:t,engine:s,value:e}){const r=s.getObject3D(e);r?t.selectedObjects.includes(r)&&t.selectedObjects.splice(t.selectedObjects.indexOf(r),1):console.warn(`selectiveBloomPassProcessor: can not found vid in engine: ${e}`)}}},create(t,s){const e=[];for(const c of t.selectedObjects){const m=s.getObject3D(c);m&&e.push(m)}const r=window.devicePixelRatio;return new g(new i.Vector2(s.dom?s.dom.offsetWidth*r:window.innerWidth*r,s.dom?s.dom.offsetHeight*r:window.innerWidth*r),t.strength,t.radius,t.threshold,t.renderScene&&s.getObjectfromModule(u.MODULETYPE.SCENE,t.renderScene)||void 0,t.renderCamera&&s.getObjectfromModule(u.MODULETYPE.CAMERA,t.renderCamera)||void 0,e)},dispose(t){t.dispose()}}),L=u.defineProcessor({type:"SMAAPass",config:R,create(t,s){const e=window.devicePixelRatio;return new A.SMAAPass(s.dom?s.dom.offsetWidth*e:window.innerWidth*e,s.dom?s.dom.offsetHeight*e:window.innerWidth*e)},dispose(t){}});let v=new i.PlaneBufferGeometry(window.innerWidth,window.innerHeight);const j=function(t){const s=new i.PlaneBufferGeometry(t.width?t.width:window.innerWidth,t.height?t.height:window.innerHeight);return v.copy(s),s.dispose(),v},U=function(t,s){const e=new H.ReflectorForSSRPass(s.getObjectBySymbol(t.groudOption.geometry)||j(t),{color:t.groudOption.color,clipBias:t.groudOption.clipBias,textureHeight:t.groudOption.textureHeight||s.dom.offsetWidth*window.devicePixelRatio,textureWidth:t.groudOption.textureWidth||s.dom.offsetHeight*window.devicePixelRatio,multisample:t.groudOption.multisample,useDepthTexture:!0});return e.material.depthWrite=!1,e.raycast=()=>{},e.visible=!1,e.geometry===v&&(e.rotation.x=-Math.PI/2),s.getObjectBySymbol(t.scene).add(e),e},D=function(t){t.getRenderTarget().dispose(),t.material.dispose()};var Q=u.defineProcessor({type:"SSRPass",config:O,commands:{set:{ground({target:t,config:s,value:e,engine:r}){if(e&&!t.groundReflector){t.groundReflector=U(s,r);return}!e&&t.groundReflector&&(D(t.groundReflector),t.groundReflector=null)},groudOption:{geometry({target:t,config:s,value:e,engine:r}){if(s.ground)if(e){const l=r.getObjectBySymbol(e);if(!l){console.warn(`SSR pass processor: can not found geometry with: ${e}`);return}t.groundReflector.geometry=l}else t.groundReflector.geometry=j(s)}},opacity({target:t,value:s}){t.groundReflector&&(t.groundReflector.opacity=s),t.opacity=s},maxDistance({target:t,value:s}){t.groundReflector&&(t.groundReflector.maxDistance=s),t.maxDistance=s}}},create(t,s){const e=window.devicePixelRatio,r=new V.SSRPass({renderer:s.getObjectBySymbol(t.renderer),scene:s.getObjectBySymbol(t.scene),camera:s.getObjectBySymbol(t.camera),width:t.width?t.width:s.dom.offsetWidth*e,height:t.height?t.height:s.dom.offsetHeight*e,groundReflector:t.ground?U(t,s):void 0,selects:t.selects.map(l=>s.getObjectBySymbol(l)),bouncing:t.bouncing});if(r.infiniteThick=t.infiniteThick,r.opacity=t.opacity,r.output=t.output,r.maxDistance=t.maxDistance,r.thickness=t.thickness,r.groundReflector){const l=r.groundReflector;l.opacity=r.opacity,l.maxDistance=r.maxDistance}return r},dispose(t){D(t.groundReflector),t.groundReflector=null,t.dispose(),v.dispose(),v=void 0}}),E=u.defineProcessor({type:"UnrealBloomPass",config:B,create(t,s){const e=window.devicePixelRatio;return new F.UnrealBloomPass(new i.Vector2(s.dom?s.dom.offsetWidth*e:window.innerWidth*e,s.dom?s.dom.offsetHeight*e:window.innerWidth*e),t.strength,t.radius,t.threshold)},dispose(t){t.dispose()}}),G={type:"pass",compiler:C,rule:z,processors:[E,L,W,Q]};n.PassCompiler=C,n.default=G,n.getPassConfig=p,n.getSMAAPassConfig=R,n.getSSAOPassConfig=k,n.getSSRPassConfig=O,n.getSelectiveBloomPassConfig=y,n.getUnrealBloomPassConfig=B,Object.defineProperties(n,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
