(function(n,u){typeof exports=="object"&&typeof module<"u"?u(exports,require("@vis-three/tdcm"),require("three/examples/jsm/postprocessing/FilmPass.js"),require("three/examples/jsm/postprocessing/LUTPass.js"),require("three"),require("three/examples/jsm/postprocessing/Pass.js"),require("three/examples/jsm/shaders/LuminosityHighPassShader.js"),require("three/examples/jsm/postprocessing/SMAAPass.js"),require("three/examples/jsm/postprocessing/SSRPass.js"),require("three/examples/jsm/objects/ReflectorForSSRPass.js"),require("three/examples/jsm/postprocessing/UnrealBloomPass.js")):typeof define=="function"&&define.amd?define(["exports","@vis-three/tdcm","three/examples/jsm/postprocessing/FilmPass.js","three/examples/jsm/postprocessing/LUTPass.js","three","three/examples/jsm/postprocessing/Pass.js","three/examples/jsm/shaders/LuminosityHighPassShader.js","three/examples/jsm/postprocessing/SMAAPass.js","three/examples/jsm/postprocessing/SSRPass.js","three/examples/jsm/objects/ReflectorForSSRPass.js","three/examples/jsm/postprocessing/UnrealBloomPass.js"],u):(n=typeof globalThis<"u"?globalThis:n||self,u((n["vis-three"]=n["vis-three"]||{},n["vis-three"]["module-pass"]={}),n.tdcm,n.FilmPass_js,n.LUTPass_js,n.three,n.Pass_js,n.LuminosityHighPassShader_js,n.SMAAPass_js,n.SSRPass_js,n.ReflectorForSSRPass_js,n.UnrealBloomPass_js))})(this,function(n,u,B,U,i,S,M,O,D,F,G){"use strict";class T extends u.Compiler{constructor(e){super(e)}useEngine(e){return super.useEngine(e),e.effectComposer?(this.composer=e.effectComposer,this):(console.warn("engine need install effectComposer plugin that can use pass compiler."),this)}add(e){const s=super.add(e);return s&&(e.index<0?this.composer.addPass(s):this.composer.insertPass(s,e.index)),s}remove(e){if(!this.map.has(e.vid))return console.warn(`PassCompiler can not found this vid pass: ${e.vid}.`),this;const s=this.map.get(e.vid);return this.composer.removePass(s.puppet),super.remove(e),this}}const h=function(){return Object.assign(u.getBasicConfig(),{vid:"",name:"",type:"Pass",index:-1})},P=function(){return Object.assign(h(),{})},w=function(){return Object.assign(h(),{strength:1.5,threshold:0,radius:0})},C=function(){return Object.assign(h(),{strength:1,threshold:0,radius:0,renderScene:"",renderCamera:"",selectedObjects:[]})},A=function(){return Object.assign(h(),{camera:"",scene:"",kernelRadius:8,kernelSize:32,noiseTexture:"",output:0,minDistance:.005,maxDistance:.1})},y=function(){return Object.assign(h(),{renderer:"",scene:"",camera:"",width:0,height:0,ground:!0,groudOption:{geometry:"",color:"rgb(127, 127, 127)",textureWidth:0,textureHeight:0,clipBias:0,multisample:4},selects:[],opacity:.5,output:0,maxDistance:180,thickness:.018,bouncing:!0,distanceAttenuation:!0,fresnel:!0,infiniteThick:!0})},R=function(){return Object.assign(h(),{grayscale:!1,intensity:.5})},j=function(){return Object.assign(h(),{lut:"",intensity:1,use2D:!1})},V=u.defineModel({type:"FilmPass",config:R,commands:{set:{intensity({target:t,value:e}){t.uniforms.intensity.value=e},grayscale({target:t,value:e}){t.uniforms.grayscale.value=e?1:0}}},create({config:t,engine:e}){return new B.FilmPass(t.intensity,t.grayscale)},dispose(t){}}),H=u.defineModel({type:"LUTPass",config:j,shared:{getResource(t,e){if(t.lut){const s=e.resourceManager.resourceMap.get(t.lut);if(!s)console.warn(`LUT pass processor can not found resource: ${t.lut}`);else return t.use2D?s.texture:s.texture3D}}},commands:{set:{lut({model:t,target:e,config:s,engine:r}){e.lut=t.getResource(s,r)},use2D({model:t,target:e,config:s,engine:r}){e.lut=t.getResource(s,r)}}},create({model:t,config:e,engine:s}){return new U.LUTPass({intensity:e.intensity,lut:t.getResource(e,s)})},dispose({target:t}){t.lut=void 0}}),f=class f extends S.Pass{constructor(e=new i.Vector2(256,256),s=1,r=0,a=0,l=new i.Scene,p=new i.PerspectiveCamera,g){super(),this.selectedObjects=[],this.clearColor=new i.Color(0,0,0),this.renderTargetsHorizontal=[],this.renderTargetsVertical=[],this.nMips=5,this.separableBlurMaterials=[],this.enabled=!0,this.needsSwap=!1,this._oldClearColor=new i.Color,this.oldClearAlpha=1,this.basic=new i.MeshBasicMaterial,this.fsQuad=new S.FullScreenQuad,this.materialCache=new Map,this.sceneBackgroundCache=null,this.overrideBackground=new i.Color("black"),this.overrideMeshMaterial=new i.MeshBasicMaterial({color:"black"}),this.overrideLineMaterial=new i.LineBasicMaterial({color:"black"}),this.overridePointsMaterial=new i.PointsMaterial({color:"black"}),this.overrideSpriteMaterial=new i.SpriteMaterial({color:"black"}),this.resolution=e,this.strength=s,this.radius=r,this.threshold=a,this.renderScene=l,this.renderCamera=p,this.selectedObjects=g;let c=Math.round(this.resolution.x/2),d=Math.round(this.resolution.y/2);this.selectRenderTarget=new i.WebGLRenderTarget(c,d),this.selectRenderTarget.texture.name="UnrealBloomPass.selected",this.selectRenderTarget.texture.generateMipmaps=!1,this.renderTargetBright=new i.WebGLRenderTarget(c,d),this.renderTargetBright.texture.name="UnrealBloomPass.bright",this.renderTargetBright.texture.generateMipmaps=!1;for(let m=0;m<this.nMips;m++){const b=new i.WebGLRenderTarget(c,d);b.texture.name="UnrealBloomPass.h"+m,b.texture.generateMipmaps=!1,this.renderTargetsHorizontal.push(b);const x=new i.WebGLRenderTarget(c,d);x.texture.name="UnrealBloomPass.v"+m,x.texture.generateMipmaps=!1,this.renderTargetsVertical.push(x),c=Math.round(c/2),d=Math.round(d/2)}M.LuminosityHighPassShader===void 0&&console.error("THREE.UnrealBloomPass relies on LuminosityHighPassShader");const o=M.LuminosityHighPassShader;this.highPassUniforms=i.UniformsUtils.clone(o.uniforms),this.highPassUniforms.luminosityThreshold.value=a,this.highPassUniforms.smoothWidth.value=.01,this.materialHighPassFilter=new i.ShaderMaterial({uniforms:this.highPassUniforms,vertexShader:o.vertexShader,fragmentShader:o.fragmentShader,defines:{}});const Q=[3,5,7,9,11];c=Math.round(this.resolution.x/2),d=Math.round(this.resolution.y/2);for(let m=0;m<this.nMips;m++)this.separableBlurMaterials.push(this.getSeperableBlurMaterial(Q[m])),this.separableBlurMaterials[m].uniforms.texSize.value=new i.Vector2(c,d),c=Math.round(c/2),d=Math.round(d/2);this.compositeMaterial=this.getCompositeMaterial(this.nMips),this.compositeMaterial.uniforms.blurTexture1.value=this.renderTargetsVertical[0].texture,this.compositeMaterial.uniforms.blurTexture2.value=this.renderTargetsVertical[1].texture,this.compositeMaterial.uniforms.blurTexture3.value=this.renderTargetsVertical[2].texture,this.compositeMaterial.uniforms.blurTexture4.value=this.renderTargetsVertical[3].texture,this.compositeMaterial.uniforms.blurTexture5.value=this.renderTargetsVertical[4].texture,this.compositeMaterial.uniforms.bloomStrength.value=s,this.compositeMaterial.uniforms.bloomRadius.value=.1,this.compositeMaterial.needsUpdate=!0;const E=[1,.8,.6,.4,.2];this.compositeMaterial.uniforms.bloomFactors.value=E,this.bloomTintColors=[new i.Vector3(1,1,1),new i.Vector3(1,1,1),new i.Vector3(1,1,1),new i.Vector3(1,1,1),new i.Vector3(1,1,1)],this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,this.mixMaterial=this.getMixMaterial()}dispose(){for(let e=0;e<this.renderTargetsHorizontal.length;e++)this.renderTargetsHorizontal[e].dispose();for(let e=0;e<this.renderTargetsVertical.length;e++)this.renderTargetsVertical[e].dispose();this.renderTargetBright.dispose()}setSize(e,s){let r=Math.round(e/2),a=Math.round(s/2);this.selectRenderTarget.setSize(r,a),this.renderTargetBright.setSize(r,a);for(let l=0;l<this.nMips;l++)this.renderTargetsHorizontal[l].setSize(r,a),this.renderTargetsVertical[l].setSize(r,a),this.separableBlurMaterials[l].uniforms.texSize.value=new i.Vector2(r,a),r=Math.round(r/2),a=Math.round(a/2)}render(e,s,r,a,l){if(!this.selectedObjects.length){this.renderToScreen&&(this.fsQuad.material=this.basic,this.basic.map=r.texture,e.setRenderTarget(null),e.clear(),this.fsQuad.render(e));return}e.getClearColor(this._oldClearColor),this.oldClearAlpha=e.getClearAlpha();const p=e.autoClear;e.autoClear=!1,e.setClearColor(this.clearColor,0),l&&e.state.buffers.stencil.setTest(!1);const g=new Map;for(const o of this.selectedObjects)g.set(o,!0);const c=this.materialCache;this.renderScene.background&&(this.sceneBackgroundCache=this.renderScene.background,this.renderScene.background=this.overrideBackground),this.renderScene.traverse(o=>{!g.has(o)&&!o.isLight&&o.visible&&(c.set(o,o.material),o instanceof i.Mesh?o.material=this.overrideMeshMaterial:o instanceof i.Line?o.material=this.overrideLineMaterial:o instanceof i.Points?o.material=this.overridePointsMaterial:o instanceof i.Sprite&&(o.material=this.overrideSpriteMaterial))}),e.setRenderTarget(this.selectRenderTarget),e.clear(),e.render(this.renderScene,this.renderCamera),this.renderToScreen&&(this.fsQuad.material=this.basic,this.basic.map=this.selectRenderTarget.texture,e.setRenderTarget(null),e.clear(),this.fsQuad.render(e)),this.highPassUniforms.tDiffuse.value=this.selectRenderTarget.texture,this.highPassUniforms.luminosityThreshold.value=this.threshold,this.fsQuad.material=this.materialHighPassFilter,e.setRenderTarget(this.renderTargetBright),e.clear(),this.fsQuad.render(e);let d=this.renderTargetBright;for(let o=0;o<this.nMips;o++)this.fsQuad.material=this.separableBlurMaterials[o],this.separableBlurMaterials[o].uniforms.colorTexture.value=d.texture,this.separableBlurMaterials[o].uniforms.direction.value=f.BlurDirectionX,e.setRenderTarget(this.renderTargetsHorizontal[o]),e.clear(),this.fsQuad.render(e),this.separableBlurMaterials[o].uniforms.colorTexture.value=this.renderTargetsHorizontal[o].texture,this.separableBlurMaterials[o].uniforms.direction.value=f.BlurDirectionY,e.setRenderTarget(this.renderTargetsVertical[o]),e.clear(),this.fsQuad.render(e),d=this.renderTargetsVertical[o];this.fsQuad.material=this.compositeMaterial,this.compositeMaterial.uniforms.bloomStrength.value=this.strength,this.compositeMaterial.uniforms.bloomRadius.value=this.radius,this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,e.setRenderTarget(this.renderTargetsHorizontal[0]),e.clear(),this.fsQuad.render(e),this.fsQuad.material=this.mixMaterial,this.mixMaterial.uniforms.bloom.value=this.renderTargetsHorizontal[0].texture,this.mixMaterial.uniforms.origin.value=r.texture,l&&e.state.buffers.stencil.setTest(!0),this.renderToScreen?(e.setRenderTarget(null),this.fsQuad.render(e)):(e.setRenderTarget(r),this.fsQuad.render(e)),e.setClearColor(this._oldClearColor,this.oldClearAlpha),e.autoClear=p;for(const o of c.entries())o[0].material=o[1];c.clear(),this.sceneBackgroundCache&&(this.renderScene.background=this.sceneBackgroundCache,this.sceneBackgroundCache=null)}getMixMaterial(){return new i.ShaderMaterial({blending:i.AdditiveBlending,depthTest:!1,depthWrite:!1,transparent:!0,uniforms:{bloom:{value:null},origin:{value:null}},vertexShader:`
    
        varying vec2 vUv;
    
        void main() {
    
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    
        }`,fragmentShader:`
        uniform sampler2D bloom;
        uniform sampler2D origin;
    
        varying vec2 vUv;
    
        void main() {
          vec3 bloomColor = texture2D(bloom, vUv).rgb;
          vec3 originColor = texture2D(origin, vUv).rgb;
          gl_FragColor = vec4(originColor + bloomColor, 1.0);
        }`})}getSeperableBlurMaterial(e){return new i.ShaderMaterial({defines:{KERNEL_RADIUS:e,SIGMA:e},uniforms:{colorTexture:{value:null},texSize:{value:new i.Vector2(.5,.5)},direction:{value:new i.Vector2(.5,.5)}},vertexShader:`varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,fragmentShader:`#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 texSize;
				uniform vec2 direction;

				float gaussianPdf(in float x, in float sigma) {
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
				}
				void main() {
					vec2 invSize = 1.0 / texSize;
					float fSigma = float(SIGMA);
					float weightSum = gaussianPdf(0.0, fSigma);
					vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
						float x = float(i);
						float w = gaussianPdf(x, fSigma);
						vec2 uvOffset = direction * invSize * x;
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;
						diffuseSum += (sample1 + sample2) * w;
						weightSum += 2.0 * w;
					}
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
				}`})}getCompositeMaterial(e){return new i.ShaderMaterial({defines:{NUM_MIPS:e},uniforms:{blurTexture1:{value:null},blurTexture2:{value:null},blurTexture3:{value:null},blurTexture4:{value:null},blurTexture5:{value:null},bloomStrength:{value:1},bloomFactors:{value:null},bloomTintColors:{value:null},bloomRadius:{value:0}},vertexShader:`varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,fragmentShader:`varying vec2 vUv;
				uniform sampler2D blurTexture1;
				uniform sampler2D blurTexture2;
				uniform sampler2D blurTexture3;
				uniform sampler2D blurTexture4;
				uniform sampler2D blurTexture5;
				uniform float bloomStrength;
				uniform float bloomRadius;
				uniform float bloomFactors[NUM_MIPS];
				uniform vec3 bloomTintColors[NUM_MIPS];

				float lerpBloomFactor(const in float factor) {
					float mirrorFactor = 1.2 - factor;
					return mix(factor, mirrorFactor, bloomRadius);
				}

				void main() {
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
						lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
						lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
						lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
						lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
				}`})}};f.BlurDirectionX=new i.Vector2(1,0),f.BlurDirectionY=new i.Vector2(0,1);let v=f;const L=u.defineModel({type:"SelectiveBloomPass",config:C,commands:{add:{selectedObjects({target:t,engine:e,value:s}){const r=e.getObject3D(s);r?t.selectedObjects.push(r):console.warn(`selectiveBloomPassProcessor: can not found vid in engine: ${s}`)}},set:{renderScene({target:t,engine:e,value:s}){const r=e.getObject3D(s);r instanceof i.Scene&&(t.renderScene=r)},renderCamera({target:t,engine:e,value:s}){const r=e.getObject3D(s);r instanceof i.Camera&&(t.renderCamera=r)},selectedObjects({target:t,config:e,engine:s}){const r=e.selectedObjects.map(a=>{const l=s.getObject3D(a);if(l)return l;console.warn(`selectiveBloomPassProcessor: can not found vid in engine: ${a}`)}).filter(a=>a);t.selectedObjects=r}},delete:{selectedObjects({target:t,engine:e,value:s}){const r=e.getObject3D(s);r?t.selectedObjects.includes(r)&&t.selectedObjects.splice(t.selectedObjects.indexOf(r),1):console.warn(`selectiveBloomPassProcessor: can not found vid in engine: ${s}`)}}},create({config:t,engine:e}){const s=[];for(const l of t.selectedObjects){const p=e.getObject3D(l);p&&s.push(p)}const r=window.devicePixelRatio;return new v(new i.Vector2(e.dom?e.dom.offsetWidth*r:window.innerWidth*r,e.dom?e.dom.offsetHeight*r:window.innerWidth*r),t.strength,t.radius,t.threshold,t.renderScene&&e.getObjectFromModule(u.MODULE_TYPE.SCENE,t.renderScene)||void 0,t.renderCamera&&e.getObjectFromModule(u.MODULE_TYPE.CAMERA,t.renderCamera)||void 0,s)},dispose({target:t}){t.dispose()}}),z=u.defineModel({type:"SMAAPass",config:P,create({config:t,engine:e}){const s=window.devicePixelRatio;return new O.SMAAPass(e.dom?e.dom.offsetWidth*s:window.innerWidth*s,e.dom?e.dom.offsetHeight*s:window.innerWidth*s)},dispose(t){}}),k=u.defineModel({type:"SSRPass",config:y,shared:{defaultGroundGeometry:new i.PlaneGeometry(window.innerWidth,window.innerHeight),setDefaultGroundGeometry(t){const e=new i.PlaneGeometry(t.width?t.width:window.innerWidth,t.height?t.height:window.innerHeight);return this.defaultGroundGeometry.copy(e),e.dispose(),this.defaultGroundGeometry},generateGround(t,e){const s=new F.ReflectorForSSRPass(e.getObjectBySymbol(t.groudOption.geometry)||this.setDefaultGroundGeometry(t),{color:new i.Color(t.groudOption.color).getHex(),clipBias:t.groudOption.clipBias,textureHeight:t.groudOption.textureHeight||e.dom.offsetWidth*window.devicePixelRatio,textureWidth:t.groudOption.textureWidth||e.dom.offsetHeight*window.devicePixelRatio,useDepthTexture:!0});return s.material.depthWrite=!1,s.raycast=()=>{},s.visible=!1,s.geometry===this.defaultGroundGeometry&&(s.rotation.x=-Math.PI/2),(t.scene?e.getObjectBySymbol(t.scene):e.scene).add(s),s},disposeGround(t){t.getRenderTarget().dispose(),t.material.dispose()}},commands:{set:{ground({model:t,target:e,config:s,value:r,engine:a}){if(r&&!e.groundReflector){e.groundReflector=t.generateGround(s,a);return}!r&&e.groundReflector&&(t.disposeGround(e.groundReflector),e.groundReflector=null)},groudOption:{geometry({model:t,target:e,config:s,value:r,engine:a}){if(s.ground)if(r){const l=a.getObjectBySymbol(r);if(!l){console.warn(`SSR pass processor: can not found geometry with: ${r}`);return}e.groundReflector.geometry=l}else e.groundReflector.geometry=t.setDefaultGroundGeometry(s)}},opacity({target:t,value:e}){t.groundReflector&&(t.groundReflector.opacity=e),t.opacity=e},maxDistance({target:t,value:e}){t.groundReflector&&(t.groundReflector.maxDistance=e),t.maxDistance=e}}},create({model:t,config:e,engine:s}){const r=window.devicePixelRatio,a=new D.SSRPass({renderer:e.renderer?s.getObjectBySymbol(e.renderer):s.webGLRenderer,scene:e.scene?s.getObjectBySymbol(e.scene):s.scene,camera:e.camera?s.getObjectBySymbol(e.camera):s.camera,width:e.width?e.width:s.dom.offsetWidth*r,height:e.height?e.height:s.dom.offsetHeight*r,groundReflector:e.ground?t.generateGround(e,s):null,selects:e.selects.map(l=>s.getObjectBySymbol(l)),bouncing:e.bouncing});if(a.infiniteThick=e.infiniteThick,a.opacity=e.opacity,a.output=e.output,a.maxDistance=e.maxDistance,a.thickness=e.thickness,a.groundReflector){const l=a.groundReflector;l.opacity=a.opacity,l.maxDistance=a.maxDistance}return a},dispose({model:t,target:e}){e.groundReflector&&t.disposeGround(e.groundReflector),e.groundReflector=null,e.dispose(),t.defaultGroundGeometry.dispose(),defaultGroundGeometry=void 0}}),W=u.defineModel({type:"UnrealBloomPass",config:w,create({config:t,engine:e}){const s=window.devicePixelRatio;return new G.UnrealBloomPass(new i.Vector2(e.dom?e.dom.offsetWidth*s:window.innerWidth*s,e.dom?e.dom.offsetHeight*s:window.innerWidth*s),t.strength,t.radius,t.threshold)},dispose({target:t}){t.dispose()}}),_=u.defineModule({type:"pass",compiler:T,models:[V,H,L,z,k,W]});n.PassCompiler=T,n.default=_,n.getFilmPassConfig=R,n.getLUTPassConfig=j,n.getPassConfig=h,n.getSMAAPassConfig=P,n.getSSAOPassConfig=A,n.getSSRPassConfig=y,n.getSelectiveBloomPassConfig=C,n.getUnrealBloomPassConfig=w,Object.defineProperties(n,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
