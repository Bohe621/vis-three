(function(u,o){typeof exports=="object"&&typeof module!="undefined"?o(exports,require("@vis-three/middleware"),require("uuid"),require("three")):typeof define=="function"&&define.amd?define(["exports","@vis-three/middleware","uuid","three"],o):(u=typeof globalThis!="undefined"?globalThis:u||self,o((u["vis-three"]=u["vis-three"]||{},u["vis-three"]["module-path"]={}),u.middleware,u.uuid,u.three))})(this,function(u,o,p,c){"use strict";var N=Object.defineProperty;var j=(u,o,p)=>o in u?N(u,o,{enumerable:!0,configurable:!0,writable:!0,value:p}):u[o]=p;var v=(u,o,p)=>(j(u,typeof o!="symbol"?o+"":o,p),p);class y extends o.Compiler{constructor(){super()}compile(t,r){return super.compile(t,r),this}}const x=function(e,t,r=p.validate){o.Rule(e,t,r)},P=function(){return Object.assign(o.getSymbolConfig(),{curves:[],autoClose:!1})},b=function(){return Object.assign(o.getSymbolConfig(),{})};class g extends c.EllipseCurve{constructor(r,s,n,i,l,d){super(0,0,1,1,0,Math.PI*2,!1,0);v(this,"start",new c.Vector2);v(this,"end",new c.Vector2);v(this,"vertical",0);v(this,"center",new c.Vector2);v(this,"tempVector",new c.Vector2);this.start.set(r,s),this.end.set(l,d),this.vertical=n;const C=this.tempVector,S=this.start,V=this.end,O=new c.Vector2((l+r)/2,(d+s)/2),a=this.center.copy(this.end).sub(this.start);a.set(-a.y,a.x).negate().normalize().multiplyScalar(n).add(O),this.aX=a.x,this.aY=a.y,this.xRadius=C.copy(V).sub(a).length(),this.yRadius=this.xRadius,this.aStartAngle=C.copy(S).sub(a).angle(),this.aEndAngle=C.copy(V).sub(a).angle(),this.aClockwise=i}}const w={arc:(e,t,r,s,n,i)=>new g(e,t,r,s,n,i),line:(e,t,r,s)=>new c.LineCurve(new c.Vector2(e,t),new c.Vector2(r,s)),bezier:(e,t,r,s,n,i,l,d)=>new c.CubicBezierCurve(new c.Vector2(e,t),new c.Vector2(r,s),new c.Vector2(n,i),new c.Vector2(l,d)),quadratic:(e,t,r,s,n,i)=>new c.QuadraticBezierCurve(new c.Vector2(e,t),new c.Vector2(r,s),new c.Vector2(n,i))},h=function(e,t){return t==="start"?{x:e.params[0],y:e.params[1]}:{x:e.params[e.params.length-2],y:e.params[e.params.length-1]}},m=function(e){return w[e.curve]?w[e.curve](...e.params):(console.warn(`path processor can not support this curve: ${e.curve}`),null)},f=function(e,t,r){if(r==="start")e.params[0]!==t[0]&&(e.params[0]=t[0]),e.params[1]!==t[1]&&(e.params[1]=t[1]);else{const s=e.params.length-1;e.params[s-1]!==t[0]&&(e.params[s-1]=t[0]),e.params[s]!==t[1]&&(e.params[s]=t[1])}};var E=o.defineProcessor({type:"Path",config:P,commands:{add:{curves({target:e,config:t,value:r}){const s=m(r);s&&e.curves.push(s)}},set:{curves({target:e,config:t,path:r,key:s}){let n=Number(r[1]);if(!Number.isInteger(n)){if(Number.isInteger(Number(s)))return;console.warn("path processor: set curves path error:",r);return}const i=m(t.curves[n]);e.curves[n]=i;const l=h(t.curves[n],"start"),d=h(t.curves[n],"end");n-1>=0&&f(t.curves[n-1],[l.x,l.y],"end"),n+1<=e.curves.length-1&&f(t.curves[n+1],[d.x,d.y],"start")}},delete:{curves({target:e,config:t,key:r}){const s=Number(r);if(!(e.curves.length-1<s)&&(e.curves.splice(s,1),s<=e.curves.length-1&&s-1>=0)){const n=h(t.curves[s-1],"end");f(t.curves[s],[n.x,n.y],"start")}}}},create(e,t){const r=new c.Path;if(e.curves.length)for(const s of e.curves){const n=m(s);n&&r.curves.push(n)}return r.autoClose=e.autoClose,r},dispose(e){e.curves=[]}}),R={type:"path",compiler:y,rule:x,processors:[E],lifeOrder:o.SUPPORT_LIFE_CYCLE.ZERO};u.PathCompiler=y,u.default=R,u.getPath3Config=b,u.getPathConfig=P,Object.defineProperties(u,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
