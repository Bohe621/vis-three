(function(d,m){typeof exports=="object"&&typeof module<"u"?m(exports,require("@vis-three/tdcm"),require("three")):typeof define=="function"&&define.amd?define(["exports","@vis-three/tdcm","three"],m):(d=typeof globalThis<"u"?globalThis:d||self,m((d["vis-three"]=d["vis-three"]||{},d["vis-three"]["module-path"]={}),d.tdcm,d.three))})(this,function(d,m,c){"use strict";const E=function(){return Object.assign(m.getBasicConfig(),{curves:[],autoClose:!1})},g=function(){return Object.assign(m.getBasicConfig(),{curves:[],autoClose:!1})},p=class p extends c.EllipseCurve{constructor(t,r,s,a,n,o){super(0,0,1,1,0,Math.PI*2,!1,0),this.start=new c.Vector2,this.end=new c.Vector2,this.vertical=0,this.center=new c.Vector2,this.mid=new c.Vector2;const u=t,i=s,v=n,l=r,w=a,x=o,y=u-i,M=l-w,z=u-v,N=l-x,S=(u*u-i*i+(l*l-w*w))/2,q=(u*u-v*v+(l*l-x*x))/2,B=M*z-y*N,V=-(N*S-M*q)/B,P=-(y*q-z*S)/B,I=(v+u)/2,L=(x+l)/2,O=p.isLeft(p.tempVector1.set(u,l),p.tempVector2.set(v,x),p.tempVector3.set(V,P)),R=p.tempVector1.set(V,P).sub(p.tempVector2.set(I,L)).length()*(O?-1:1);this.start.set(t,r),this.end.set(n,o),this.vertical=R;const U=this.start,j=this.end,h=this.center.copy(this.end).sub(this.start),b=this.mid.set(I,L);h.set(-h.y,h.x).negate().normalize().multiplyScalar(R).add(b),this.aX=h.x,this.aY=h.y;const f=p.tempVector1;this.xRadius=f.copy(j).sub(h).length(),this.yRadius=this.xRadius,this.aStartAngle=f.copy(U).sub(h).angle(),this.aEndAngle=f.copy(j).sub(h).angle();const $=p.tempVector2.set(i,w).sub(b),k=p.tempVector3.set(V,P).sub(b);this.aClockwise=!((O?1:-1)*(p.isSameDirecton($,k)?1:-1)<0)}};p.isLeft=function(t,r,s){return(r.x-t.x)*(s.y-t.y)-(r.y-t.y)*(s.x-t.x)>0},p.isSameDirecton=function(t,r){const s=Math.sqrt(t.lengthSq()*r.lengthSq());if(s===0)return!1;const a=t.dot(r)/s;return Math.acos(c.MathUtils.clamp(a,-1,1))<Math.PI/2},p.tempVector1=new c.Vector2,p.tempVector2=new c.Vector2,p.tempVector3=new c.Vector2;let C=p;const T=m.defineModel({type:"Path",config:E,shared:{getCurveExtrPoint(e,t){return t==="start"?{x:e.params[0],y:e.params[1]}:{x:e.params[e.params.length-2],y:e.params[e.params.length-1]}},generateCurve(e){const t={arc:(r,s,a,n,o,u)=>new C(r,s,a,n,o,u),line:(r,s,a,n)=>new c.LineCurve(new c.Vector2(r,s),new c.Vector2(a,n)),bezier:(r,s,a,n,o,u,i,v)=>new c.CubicBezierCurve(new c.Vector2(r,s),new c.Vector2(a,n),new c.Vector2(o,u),new c.Vector2(i,v)),cubic:(r,s,a,n,o,u,i,v)=>new c.CubicBezierCurve(new c.Vector2(r,s),new c.Vector2(a,n),new c.Vector2(o,u),new c.Vector2(i,v)),quadratic:(r,s,a,n,o,u)=>new c.QuadraticBezierCurve(new c.Vector2(r,s),new c.Vector2(a,n),new c.Vector2(o,u))};return t[e.curve]?t[e.curve](...e.params):(console.warn(`path processor can not support this curve: ${e.curve}`),null)},syncExtrParams(e,t,r){if(r==="start")e.params[0]!==t[0]&&(e.params[0]=t[0]),e.params[1]!==t[1]&&(e.params[1]=t[1]);else{const s=e.params.length-1;e.params[s-1]!==t[0]&&(e.params[s-1]=t[0]),e.params[s]!==t[1]&&(e.params[s]=t[1])}}},commands:{add:{curves({model:e,target:t,config:r,value:s}){const a=e.generateCurve(s);a&&t.curves.push(a)}},set:{curves({model:e,target:t,config:r,path:s,key:a}){let n=Number(s[1]);if(!Number.isInteger(n)){if(Number.isInteger(Number(a)))return;console.warn("path processor: set curves path error:",s);return}const o=e.generateCurve(r.curves[n]);t.curves[n]=o;const u=e.getCurveExtrPoint(r.curves[n],"start"),i=e.getCurveExtrPoint(r.curves[n],"end");n-1>=0&&e.syncExtrParams(r.curves[n-1],[u.x,u.y],"end"),n+1<=r.curves.length-1&&e.syncExtrParams(r.curves[n+1],[i.x,i.y],"start")}},delete:{curves({model:e,target:t,config:r,key:s}){const a=Number(s);if(!(t.curves.length-1<a)&&(t.curves.splice(a,1),a<=r.curves.length-1&&a-1>=0)){const n=e.getCurveExtrPoint(r.curves[a-1],"end");e.syncExtrParams(r.curves[a],[n.x,n.y],"start")}}}},create({model:e,config:t,engine:r}){const s=new c.Path;if(t.curves.length)for(const a of t.curves){const n=e.generateCurve(a);n&&s.curves.push(n)}return s.autoClose=t.autoClose,s},dispose({target:e}){e.curves=[]}}),D=m.defineModel({type:"Path3",config:g,shared:{getCurveExtrPoint(e,t){return t==="start"?{x:e.params[0],y:e.params[1],z:e.params[2]}:{x:e.params[e.params.length-3],y:e.params[e.params.length-2],z:e.params[e.params.length-1]}},generateCurve(e){const t={line:(r,s,a,n,o,u)=>new c.LineCurve3(new c.Vector3(r,s,a),new c.Vector3(n,o,u)),cubic:(r,s,a,n,o,u,i,v,l,w,x,y)=>new c.CubicBezierCurve3(new c.Vector3(r,s,a),new c.Vector3(n,o,u),new c.Vector3(i,v,l),new c.Vector3(w,x,y)),quadratic:(r,s,a,n,o,u,i,v,l)=>new c.QuadraticBezierCurve3(new c.Vector3(r,s,a),new c.Vector3(n,o,u),new c.Vector3(i,v,l))};return t[e.curve]?t[e.curve](...e.params):(console.warn(`path processor can not support this curve: ${e.curve}`),null)},syncExtrParams(e,t,r){if(r==="start")e.params[0]!==t[0]&&(e.params[0]=t[0]),e.params[1]!==t[1]&&(e.params[1]=t[1]),e.params[2]!==t[2]&&(e.params[2]=t[2]);else{const s=e.params.length-1;e.params[s-2]!==t[0]&&(e.params[s-2]=t[0]),e.params[s-1]!==t[1]&&(e.params[s-1]=t[1]),e.params[s]!==t[2]&&(e.params[s]=t[2])}}},commands:{add:{curves({model:e,target:t,config:r,value:s}){const a=e.generateCurve(s);a&&t.curves.push(a)}},set:{curves({model:e,target:t,config:r,path:s,key:a}){let n=Number(s[1]);if(!Number.isInteger(n)){if(Number.isInteger(Number(a)))return;console.warn("path3 processor: set curves path error:",s);return}const o=e.generateCurve(r.curves[n]);t.curves[n]=o;const u=e.getCurveExtrPoint(r.curves[n],"start"),i=e.getCurveExtrPoint(r.curves[n],"end");n-1>=0&&e.syncExtrParams(r.curves[n-1],[u.x,u.y,u.z],"end"),n+1<=r.curves.length-1&&e.syncExtrParams(r.curves[n+1],[i.x,i.y,i.z],"start")}},delete:{curves({model:e,target:t,config:r,key:s}){const a=Number(s);if(!(t.curves.length-1<a)&&(t.curves.splice(a,1),a<=r.curves.length-1&&a-1>=0)){const n=e.getCurveExtrPoint(r.curves[a-1],"end");e.syncExtrParams(r.curves[a],[n.x,n.y,n.z],"start")}}}},create({model:e,config:t,engine:r}){const s=new c.CurvePath;if(t.curves.length)for(const a of t.curves){const n=e.generateCurve(a);n&&s.curves.push(n)}return s.autoClose=t.autoClose,s},dispose({target:e}){e.curves=[]}}),Q=m.defineModule({type:"path",models:[T,D],lifeOrder:m.SUPPORT_LIFE_CYCLE.ZERO});d.default=Q,d.getPath3Config=g,d.getPathConfig=E,Object.defineProperties(d,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
