(function(u,c){typeof exports=="object"&&typeof module!="undefined"?c(exports,require("@vis-three/middleware"),require("uuid"),require("three"),require("@vis-three/module-curve")):typeof define=="function"&&define.amd?define(["exports","@vis-three/middleware","uuid","three","@vis-three/module-curve"],c):(u=typeof globalThis!="undefined"?globalThis:u||self,c((u["vis-three"]=u["vis-three"]||{},u["vis-three"]["module-path"]={}),u.middleware,u.uuid,u.three,u.moduleCurve))})(this,function(u,c,C,o,P){"use strict";class h extends c.Compiler{constructor(){super()}compile(r,s){return super.compile(r,s),this}}const w=function(e,r,s=C.validate){c.Rule(e,r,s)},m=function(){return Object.assign(c.getSymbolConfig(),{curves:[],autoClose:!1})},y=function(){return Object.assign(c.getSymbolConfig(),{})},f={arc:(e,r,s,t,n,i)=>new P.ArcCurve(e,r,s,t,n,i),line:(e,r,s,t)=>new o.LineCurve(new o.Vector2(e,r),new o.Vector2(s,t)),bezier:(e,r,s,t,n,i,a,v)=>new o.CubicBezierCurve(new o.Vector2(e,r),new o.Vector2(s,t),new o.Vector2(n,i),new o.Vector2(a,v)),quadratic:(e,r,s,t,n,i)=>new o.QuadraticBezierCurve(new o.Vector2(e,r),new o.Vector2(s,t),new o.Vector2(n,i))},p=function(e,r){return r==="start"?{x:e.params[0],y:e.params[1]}:{x:e.params[e.params.length-2],y:e.params[e.params.length-1]}},d=function(e){return f[e.curve]?f[e.curve](...e.params):(console.warn(`path processor can not support this curve: ${e.curve}`),null)},l=function(e,r,s){if(s==="start")e.params[0]!==r[0]&&(e.params[0]=r[0]),e.params[1]!==r[1]&&(e.params[1]=r[1]);else{const t=e.params.length-1;e.params[t-1]!==r[0]&&(e.params[t-1]=r[0]),e.params[t]!==r[1]&&(e.params[t]=r[1])}};var x=c.defineProcessor({type:"Path",config:m,commands:{add:{curves({target:e,config:r,value:s}){const t=d(s);t&&e.curves.push(t)}},set:{curves({target:e,config:r,path:s,key:t}){let n=Number(s[1]);if(!Number.isInteger(n)){if(Number.isInteger(Number(t)))return;console.warn("path processor: set curves path error:",s);return}const i=d(r.curves[n]);e.curves[n]=i;const a=p(r.curves[n],"start"),v=p(r.curves[n],"end");n-1>=0&&l(r.curves[n-1],[a.x,a.y],"end"),n+1<=r.curves.length-1&&l(r.curves[n+1],[v.x,v.y],"start")}},delete:{curves({target:e,config:r,key:s}){const t=Number(s);if(!(e.curves.length-1<t)&&(e.curves.splice(t,1),t<=r.curves.length-1&&t-1>=0)){const n=p(r.curves[t-1],"end");l(r.curves[t],[n.x,n.y],"start")}}}},create(e,r){const s=new o.Path;if(e.curves.length)for(const t of e.curves){const n=d(t);n&&s.curves.push(n)}return s.autoClose=e.autoClose,s},dispose(e){e.curves=[]}}),V={type:"path",compiler:h,rule:w,processors:[x],lifeOrder:c.SUPPORT_LIFE_CYCLE.ZERO};u.PathCompiler=h,u.default=V,u.getPath3Config=y,u.getPathConfig=m,Object.defineProperties(u,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
