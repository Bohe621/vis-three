(function(n,c){typeof exports=="object"&&typeof module!="undefined"?c(exports,require("@vis-three/middleware"),require("uuid"),require("three")):typeof define=="function"&&define.amd?define(["exports","@vis-three/middleware","uuid","three"],c):(n=typeof globalThis!="undefined"?globalThis:n||self,c((n["vis-three"]=n["vis-three"]||{},n["vis-three"]["module-path"]={}),n.middleware,n.uuid,n.three))})(this,function(n,c,p,u){"use strict";var j=Object.defineProperty;var q=(n,c,p)=>c in n?j(n,c,{enumerable:!0,configurable:!0,writable:!0,value:p}):n[c]=p;var v=(n,c,p)=>(q(n,typeof c!="symbol"?c+"":c,p),p);class y extends c.Compiler{constructor(){super()}compile(s,r){return super.compile(s,r),this}}const x=function(e,s,r=p.validate){c.Rule(e,s,r)},P=function(){return Object.assign(c.getSymbolConfig(),{curves:[],autoClose:!1})},b=function(){return Object.assign(c.getSymbolConfig(),{})};class g extends u.EllipseCurve{constructor(r,t,o,i,l,m){super(0,0,1,1,0,Math.PI*2,!1,0);v(this,"start",new u.Vector2);v(this,"end",new u.Vector2);v(this,"vertical",0);v(this,"center",new u.Vector2);v(this,"tempVector",new u.Vector2);this.start.set(r,t),this.end.set(l,m),this.vertical=o;const C=this.tempVector,S=this.start,V=this.end,O=new u.Vector2((l+r)/2,(m+t)/2),a=this.center.copy(this.end).sub(this.start);a.set(-a.y,a.x).negate().normalize().multiplyScalar(o).add(O),this.aX=a.x,this.aY=a.y,this.xRadius=C.copy(V).sub(a).length(),this.yRadius=this.xRadius,this.aStartAngle=C.copy(S).sub(a).angle(),this.aEndAngle=C.copy(V).sub(a).angle(),this.aClockwise=i}}const w={arc:(e,s,r,t,o,i)=>new g(e,s,r,t,o,i),line:(e,s,r,t)=>new u.LineCurve(new u.Vector2(e,s),new u.Vector2(r,t)),bezier:(e,s,r,t,o,i,l,m)=>new u.CubicBezierCurve(new u.Vector2(e,s),new u.Vector2(r,t),new u.Vector2(o,i),new u.Vector2(l,m)),quadratic:(e,s,r,t,o,i)=>new u.QuadraticBezierCurve(new u.Vector2(e,s),new u.Vector2(r,t),new u.Vector2(o,i))},d=function(e,s){return s==="start"?{x:e.params[0],y:e.params[1]}:{x:e.params[e.params.length-2],y:e.params[e.params.length-1]}},f=function(e){return w[e.curve]?w[e.curve](...e.params):(console.warn(`path processor can not support this curve: ${e.curve}`),null)},h=function(e,s,r){if(r==="start")e.params[0]!==s[0]&&(e.params[0]=s[0]),e.params[1]!==s[1]&&(e.params[1]=s[1]);else{const t=e.params.length-1;e.params[t-1]!==s[0]&&(e.params[t-1]=s[0]),e.params[t]!==s[1]&&(e.params[t]=s[1])}};var E=c.defineProcessor({type:"Path",config:P,commands:{add:{curves({target:e,config:s,value:r}){const t=f(r);t&&e.curves.push(t)}},set:{curves({target:e,config:s,path:r}){const t=Number(r[1]);if(!Number.isInteger(t)){console.warn("path processor: set curves path error:",r);return}const o=f(s.curves[t]);e.curves[t]=o;const i=d(s.curves[t],"start"),l=d(s.curves[t],"end");t-1>=0&&h(s.curves[t-1],[i.x,i.y],"end"),t+1<=e.curves.length-1&&h(s.curves[t+1],[l.x,l.y],"start")}},delete:{curves({target:e,config:s,key:r}){const t=Number(r);if(e.curves.length-1<t)return;e.curves.splice(t,e.curves.length);const o=d(s.curves[t],"start"),i=d(s.curves[t],"end");t-1>=0&&h(s.curves[t-1],[o.x,o.y],"end"),t+1<=e.curves.length-1&&h(s.curves[t+1],[i.x,i.y],"start")}}},create(e,s){const r=new u.Path;if(e.curves.length)for(const t of e.curves){const o=f(t);o&&r.curves.push(o)}return r.autoClose=e.autoClose,r},dispose(e){e.curves=[]}}),R={type:"path",compiler:y,rule:x,processors:[E],lifeOrder:c.SUPPORT_LIFE_CYCLE.ZERO};n.PathCompiler=y,n.default=R,n.getPath3Config=b,n.getPathConfig=P,Object.defineProperties(n,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
