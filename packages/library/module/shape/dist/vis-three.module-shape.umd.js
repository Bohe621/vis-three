(function(a,s){typeof exports=="object"&&typeof module<"u"?s(exports,require("@vis-three/tdcm"),require("three")):typeof define=="function"&&define.amd?define(["exports","@vis-three/tdcm","three"],s):(a=typeof globalThis<"u"?globalThis:a||self,s((a["vis-three"]=a["vis-three"]||{},a["vis-three"]["module-shape"]={}),a.tdcm,a.three))})(this,function(a,s,u){"use strict";const M=function(){return Object.assign(s.getBasicConfig(),{shape:"",holes:[]})},c=s.defineModel({type:"Shape",config:M,context(){return{pathEventMap:new Map}},commands:{add:{holes({model:t,target:e,engine:h,config:o,value:n}){var E;const p=h.compilerManager.getObjectFromModule(s.MODULE_TYPE.PATH,n);if(!p){console.warn(`shape model: can not found path: ${n}`);return}e.holes.push(p);const r=o.holes.length-1,l=()=>{o.holes[r]=o.holes[r]};(E=t.toModel(n))==null||E.on(s.MODEL_EVENT.COMPILED_UPDATE,l),t.pathEventMap.set(p,l)}},set:{shape({model:t,target:e,engine:h,value:o}){const n=h.compilerManager.getObjectFromModule(s.MODULE_TYPE.PATH,o);n?e.curves=n.curves:console.warn(`shape model: can not found path: ${o}`)},holes({target:t,engine:e,path:h,value:o}){const n=Number(h[1]);if(!Number.isInteger(n)){console.warn("shape model: delete holes error:",h);return}const p=e.compilerManager.getObjectFromModule(s.MODULE_TYPE.PATH,o);if(!p){console.warn(`shape model: can not found path: ${o}`);return}t.holes[n]=p}},delete:{holes({model:t,target:e,path:h}){var n;const o=Number(h[1]);if(!Number.isInteger(o)){console.warn("shape processor: delete holes error:",h);return}(n=t.toModel(e.holes[o]))==null||n.off(s.MODEL_EVENT.COMPILED_UPDATE,t.pathEventMap.get(e.holes[o])),t.pathEventMap.delete(e.holes[o]),e.holes.splice(o,1)}}},create({model:t,config:e,engine:h}){var n,p;const o=new u.Shape;if(e.shape){const r=h.compilerManager.getObjectFromModule(s.MODULE_TYPE.PATH,e.shape);if(!r)console.warn(`shape processor can not found path: ${e.shape}`);else{o.curves=r.curves;const l=()=>{e.shape=e.shape};(n=t.toModel(e.shape))==null||n.on(s.MODEL_EVENT.COMPILED_UPDATE,l),t.pathEventMap.set(r,l)}}if(e.holes.length)for(let r=0;r<e.holes.length;r+=1){const l=e.holes[r],E=h.compilerManager.getObjectFromModule(s.MODULE_TYPE.PATH,l);if(!E)console.warn(`shape processor can not found path: ${l}`);else{o.holes.push(E);const i=()=>{e.holes[r]=e.holes[r]};(p=t.toModel(e.shape))==null||p.on(s.MODEL_EVENT.COMPILED_UPDATE,i),t.pathEventMap.set(E,i)}}return o},dispose({model:t,target:e}){var h;e.curves=[],e.holes=[];for(const[o,n]of t.pathEventMap.entries())(h=t.toModel(o))==null||h.off(s.MODEL_EVENT.COMPILED_UPDATE,n);t.pathEventMap.clear()}}),d=s.defineModule({type:"shape",models:[c],lifeOrder:s.SUPPORT_LIFE_CYCLE.ONE});a.default=d,a.getShapeConfig=M,Object.defineProperties(a,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
