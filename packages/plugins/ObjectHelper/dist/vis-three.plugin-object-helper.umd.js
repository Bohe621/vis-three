(function(d,u){typeof exports=="object"&&typeof module!="undefined"?u(exports,require("@vis-three/core"),require("three"),require("@vis-three/convenient"),require("@vis-three/utils")):typeof define=="function"&&define.amd?define(["exports","@vis-three/core","three","@vis-three/convenient","@vis-three/utils"],u):(d=typeof globalThis!="undefined"?globalThis:d||self,u((d["vis-three"]=d["vis-three"]||{},d["vis-three"]["plugin-object-helper"]={}),d.core,d.three,d.convenient,d.utils))})(this,function(d,u,t,w,U){"use strict";var se=Object.defineProperty;var oe=(d,u,t)=>u in d?se(d,u,{enumerable:!0,configurable:!0,writable:!0,value:t}):d[u]=t;var s=(d,u,t)=>(oe(d,typeof u!="symbol"?u+"":u,t),t);const y=()=>new t.LineBasicMaterial({color:"rgb(255, 255, 255)"});class W extends t.LineSegments{constructor(e){super();s(this,"shape");s(this,"target");s(this,"type","CameraHelper");s(this,"cachaData");const i=new t.BufferGeometry,o=[0,0,0,-1,1,-1,0,0,0,-1,1,1,0,0,0,-1,-1,-1,0,0,0,-1,-1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,1,1,-1,1,1,-1,-1,1,0,0,0,0,1,1,0,0,0,0,1,-1,0,0,0,0,-1,-1,0,0,0,0,-1,1,0,1,1,0,1,-1,0,1,-1,0,-1,-1,0,-1,-1,0,-1,1,0,-1,1,0,1,1,0,-1,1,2,-1,1,0,1,-1,2,1,-1,0,-1,-1,2,-1,-1,0,1,1,2,1,1,2,1,1,2,-1,1,2,-1,1,2,-1,-1,2,-1,-1,2,1,-1,2,1,-1,2,1,1];i.setAttribute("position",new t.Float32BufferAttribute(o,3)),i.rotateY(-90*Math.PI/180),i.computeBoundingBox();const r=new t.CameraHelper(e);r.matrix=new t.Matrix4,r.matrixAutoUpdate=!0,r.raycast=()=>{},this.add(r),this.shape=r,this.geometry=i,this.material=y(),this.target=e,this.matrixAutoUpdate=!1,this.matrix=e.matrix,e instanceof t.PerspectiveCamera?this.cachaData={fov:e.fov,aspect:e.aspect,near:e.near,far:e.far}:e instanceof t.OrthographicCamera?this.cachaData={left:e.left,right:e.right,top:e.top,bottom:e.bottom,near:e.near,far:e.far}:this.cachaData={},this.onBeforeRender=()=>{let a=!1;const m=this.cachaData;Object.keys(m).forEach(h=>{m[h]!==e[h]&&(m[h]=e[h],a=!0)}),a&&this.shape.update()}}raycast(e,i){const o=this.matrixWorld,r=this.geometry.boundingBox.clone();if(r.applyMatrix4(o),e.ray.intersectsBox(r)){const a=this.target;i.push({distance:e.ray.origin.distanceTo(a.position),object:a,point:a.position})}}}class V extends t.LineSegments{constructor(e){super();s(this,"sphere");s(this,"target");s(this,"shape");s(this,"type","VisDirectionalLightHelper");s(this,"cacheColor");s(this,"cacheVector3");this.geometry=new t.BufferGeometry;const i=[-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1,0,0,1,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,0,0,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,-.707,0,-.707,.707,0,.707,.707,0,-.707,-.707,0,.707];this.geometry.setAttribute("position",new t.Float32BufferAttribute(i,3)),this.material=y(),this.geometry.boundingSphere;const o=new t.Color().copy(e.color).multiplyScalar(e.intensity),r=new t.PlaneBufferGeometry(20,20);r.dispose();const a=new t.LineSegments(new t.EdgesGeometry(r),new t.LineBasicMaterial({color:o}));a.raycast=()=>{},this.shape=a,this.target=e,this.sphere=new t.Sphere(new t.Vector3(0,0,0),1),this.cacheColor=e.color.getHex(),this.cacheVector3=new t.Vector3,this.add(this.shape),this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.onBeforeRender=()=>{const m=this.target,h=this.shape;m.color.getHex()!==this.cacheColor&&(h.material.color.copy(m.color).multiplyScalar(m.intensity),this.cacheColor=m.color.getHex()),h.lookAt(m.target.position)}}raycast(e,i){const o=this.target,r=o.matrixWorld,a=this.sphere;a.set(this.cacheVector3.set(0,0,0),1),a.applyMatrix4(r),e.ray.intersectsSphere(a)&&i.push({distance:e.ray.origin.distanceTo(o.position),object:o,point:o.position})}}class F extends t.LineSegments{constructor(e){super();s(this,"sphere");s(this,"target");s(this,"shape");s(this,"type","VisPointLightHelper");s(this,"cacheColor");s(this,"cacheDistance");s(this,"cacheVector3");this.geometry=new t.BufferGeometry;const i=[-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1,0,0,1,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,0,0,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,-.707,0,-.707,.707,0,.707,.707,0,-.707,-.707,0,.707];this.geometry.setAttribute("position",new t.Float32BufferAttribute(i,3)),this.material=y(),this.geometry.boundingSphere;const o=new t.Color().copy(e.color).multiplyScalar(e.intensity),r=new t.Mesh(new t.OctahedronBufferGeometry(e.distance,0),new t.MeshBasicMaterial({color:o,wireframe:!0}));r.raycast=()=>{},r.matrixAutoUpdate=!1,this.shape=r,this.target=e,this.sphere=new t.Sphere(new t.Vector3(0,0,0),1),this.cacheColor=e.color.getHex(),this.cacheDistance=e.distance,this.cacheVector3=new t.Vector3,this.add(this.shape),this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.onBeforeRender=()=>{const a=this.target,m=this.shape;a.distance!==this.cacheDistance&&(m.geometry.dispose(),m.geometry=new t.OctahedronBufferGeometry(a.distance,0),this.cacheDistance=a.distance),a.color.getHex()!==this.cacheColor&&(m.material.color.copy(a.color).multiplyScalar(a.intensity),this.cacheColor=a.color.getHex())}}raycast(e,i){const o=this.target,r=o.matrixWorld,a=this.sphere;a.set(this.cacheVector3.set(0,0,0),1),a.applyMatrix4(r),e.ray.intersectsSphere(a)&&i.push({distance:e.ray.origin.distanceTo(o.position),object:o,point:o.position})}}class T extends t.LineSegments{constructor(e){super();s(this,"target");s(this,"type","VisRectAreaLightHelper");s(this,"cacheBox",new t.Box3);s(this,"cacheVector3",new t.Vector3);s(this,"cacheColor");s(this,"cacheIntensity");this.target=e,this.generateShape();const i=y();i.color.copy(e.color).multiplyScalar(e.intensity),this.cacheColor=e.color.getHex(),this.cacheIntensity=e.intensity,this.material=i,this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.onBeforeRender=()=>{const o=this.target;(o.width!==this.geometry.parameters.width||o.height!==this.geometry.parameters.height)&&this.generateShape(),(o.color.getHex()!==this.cacheColor||this.cacheIntensity!==o.intensity)&&(this.material.color.copy(o.color).multiplyScalar(o.intensity),this.cacheColor=o.color.getHex())}}generateShape(){this.geometry.dispose(),this.geometry=new t.PlaneBufferGeometry(this.target.width,this.target.height,4,4),this.geometry.computeBoundingBox()}raycast(e,i){const o=this.target,r=this.cacheBox;r.copy(this.geometry.boundingBox),r.applyMatrix4(o.matrixWorld),e.ray.intersectBox(r,this.cacheVector3)&&i.push({distance:e.ray.origin.distanceTo(o.position),object:o,point:o.position})}}class O extends t.LineSegments{constructor(e){super();s(this,"sphere");s(this,"target");s(this,"shape");s(this,"type","VisSpotLightHelper");s(this,"cacheVector3");s(this,"cacheColor");s(this,"cacheAngle");s(this,"cacheDistance");this.geometry=new t.BufferGeometry;const i=[-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1,0,0,1,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,0,0,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,-.707,0,-.707,.707,0,.707,.707,0,-.707,-.707,0,.707];this.geometry.setAttribute("position",new t.Float32BufferAttribute(i,3)),this.material=y(),this.geometry.boundingSphere;const o=new t.BufferGeometry,r=[0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let l=0,g=1,f=32;l<f;l++,g++){const b=l/f*Math.PI*2,G=g/f*Math.PI*2;r.push(Math.cos(b),Math.sin(b),1,Math.cos(G),Math.sin(G),1)}o.setAttribute("position",new t.Float32BufferAttribute(r,3));const a=y(),m=new t.LineSegments(o,a);m.material.color.copy(e.color).multiplyScalar(e.intensity);const h=e.distance?e.distance:1e3,p=h*Math.tan(e.angle);m.scale.set(p,p,h),m.raycast=()=>{},this.add(m),this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.target=e,this.shape=m,this.sphere=new t.Sphere(new t.Vector3(0,0,0),1),this.cacheColor=e.color.getHex(),this.cacheDistance=e.distance,this.cacheAngle=e.angle,this.cacheVector3=new t.Vector3,this.onBeforeRender=()=>{const l=this.target,g=this.shape;let f=!1;if(l.distance!==this.cacheDistance&&(this.cacheDistance=l.distance,g.scale.z=l.distance,f=!0),l.angle!==this.cacheAngle&&(this.cacheAngle=l.angle,f=!0),f){const b=l.distance*Math.tan(l.angle);g.scale.set(b,b,l.distance)}l.color.getHex()!==this.cacheColor&&(g.material.color.copy(l.color).multiplyScalar(l.intensity),this.cacheColor=l.color.getHex()),g.lookAt(l.target.position)}}raycast(e,i){const o=this.target,r=o.matrixWorld,a=this.sphere;a.set(this.cacheVector3.set(0,0,0),1),a.applyMatrix4(r),e.ray.intersectsSphere(a)&&i.push({distance:e.ray.origin.distanceTo(o.position),object:o,point:o.position})}}const B=class extends t.Points{constructor(e){super();s(this,"target");s(this,"type","GeometricOriginHelper");this.target=e,this.geometry=new t.BufferGeometry().setAttribute("position",new t.BufferAttribute(new Float32Array([0,0,0]),3)),this.material=new t.PointsMaterial({map:B.colorTexture,transparent:!0,alphaTest:.1,depthFunc:t.AlwaysDepth}),this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.renderOrder=100,this.raycast=()=>{}}};let H=B;s(H,"colorTexture",new t.CanvasTexture(new w.CanvasGenerator({width:32,height:32}).draw(e=>{e.beginPath(),e.fillStyle="rgba(0, 0, 0, 0)",e.fillRect(0,0,32,32),e.closePath(),e.beginPath(),e.fillStyle="rgb(255, 163, 0)",e.strokeStyle="black",e.lineWidth=1,e.arc(16,16,15,0,2*Math.PI),e.stroke(),e.fill(),e.closePath()}).get()));const R=`

#include <common>

void main() {
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

  bool isPerspective = isPerspectiveMatrix( projectionMatrix );

  if ( isPerspective ) scale *= - mvPosition.z;

	vec2 alignedPosition = position.xy * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( 0.0 ) * alignedPosition.x - sin( 0.0 ) * alignedPosition.y;
	rotatedPosition.y = sin( 0.0 ) * alignedPosition.x + cos( 0.0 ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

}

`,z=`

uniform vec3 color;

void main() {
  gl_FragColor = vec4(color, 1.0);
}
`;class N extends t.ShaderMaterial{constructor(){super(),this.vertexShader=R,this.fragmentShader=z,this.uniforms={color:{value:new t.Color("white")}}}}class L extends t.LineSegments{constructor(e){super();s(this,"target");s(this,"type","VisCSS2DPlaneHelper");s(this,"observer");this.geometry=new t.EdgesGeometry(new t.PlaneBufferGeometry(1,1)),this.geometry.computeBoundingBox(),this.material=new N,this.scale.copy(e.matrixScale),this.position.set(e.position.x,e.position.y,e.position.z),this.target=e;const i=new MutationObserver(()=>{this.scale.copy(e.matrixScale)});i.observe(e.element,{attributeFilter:["style"]}),this.observer=i,this.onBeforeRender=()=>{this.position.set(this.target.position.x,this.target.position.y,this.target.position.z)},this.raycast=()=>{}}dispose(){this.observer.disconnect()}}class I extends t.LineSegments{constructor(e){super();s(this,"target");s(this,"type","VisCSS3DPlaneHelper");s(this,"observer");this.geometry=new t.EdgesGeometry(new t.PlaneBufferGeometry(e.width,e.height)),this.geometry.computeBoundingBox(),this.material=y(),this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.target=e;const i=new MutationObserver(()=>{this.geometry.dispose(),this.geometry=new t.EdgesGeometry(new t.PlaneBufferGeometry(e.width,e.height)),this.geometry.computeBoundingBox()});i.observe(e.element,{attributeFilter:["style"]}),this.observer=i,this.raycast=()=>{},this.updateMatrixWorld=()=>{}}dispose(){this.observer.disconnect()}}const _=`
uniform float rotation2D;

#include <common>

void main() {
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

	vec2 alignedPosition = position.xy * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation2D ) * alignedPosition.x - sin( rotation2D ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation2D ) * alignedPosition.x + cos( rotation2D ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

}

`,k=`

uniform vec3 color;

void main() {
  gl_FragColor = vec4(color, 1.0);
}
`;class $ extends t.ShaderMaterial{constructor(){super(),this.vertexShader=_,this.fragmentShader=k,this.uniforms={color:{value:new t.Color("white")},rotation2D:{value:0}}}}class q extends t.LineSegments{constructor(e){super();s(this,"target");s(this,"type","VisCSS3DSpriteHelper");s(this,"observer");this.geometry=new t.EdgesGeometry(new t.PlaneBufferGeometry(1,1)),this.geometry.computeBoundingBox(),this.material=new $,this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.target=e;const i=new MutationObserver(()=>{this.geometry.dispose(),this.geometry=new t.EdgesGeometry(new t.PlaneBufferGeometry(e.width,e.height)),this.geometry.computeBoundingBox()});i.observe(e.element,{attributeFilter:["style"]}),this.observer=i,this.onBeforeRender=()=>{this.material.uniforms.rotation2D.value=this.target.rotation2D},this.raycast=()=>{},this.updateMatrixWorld=()=>{}}dispose(){this.observer.disconnect()}}const C=class extends t.Sprite{constructor(e){super();s(this,"target");s(this,"type","VisGroupHelper");this.target=e,this.geometry.computeBoundingBox(),this.material=new t.SpriteMaterial({map:C.colorTexture}),this.material.depthTest=!1,this.material.depthWrite=!1,this.scale.set(5,5,5);const i=this.updateMatrixWorld.bind(this);this.updateMatrixWorld=o=>{const r=this.position,a=this.target.position;r.x=a.x,r.y=a.y,r.z=a.z,i(o)}}raycast(e,i){const o=this.matrixWorld,r=this.geometry.boundingBox.clone();if(r.applyMatrix4(o),e.ray.intersectsBox(r)){const a=this.target;i.push({distance:e.ray.origin.distanceTo(a.position),object:a,point:a.position})}}};let S=C;s(S,"colorTexture",new t.CanvasTexture(new w.CanvasGenerator({width:512,height:512}).draw(e=>{e.beginPath(),e.fillStyle="rgba(0, 0, 0, 0)",e.fillRect(0,0,512,512),e.closePath(),e.translate(256,200),e.beginPath(),e.fillStyle="yellow",e.fillRect(-200,0,400,200),e.closePath(),e.beginPath(),e.fillStyle="yellow",e.fillRect(-200,-70,200,70),e.closePath()}).get()));const E=class extends t.Points{constructor(e){super();s(this,"target");s(this,"cachaGeometryUUid");s(this,"type","VisLineHelper");this.target=e,this.geometry.dispose(),this.geometry.copy(e.geometry),this.cachaGeometryUUid=e.geometry.uuid,this.material=new t.PointsMaterial({color:"rgb(255, 255, 255)",alphaMap:E.alphaTexture,transparent:!0,size:5,sizeAttenuation:!1}),this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.renderOrder=-1,this.raycast=()=>{},this.onBeforeRender=()=>{const i=this.target;i.geometry.uuid!==this.cachaGeometryUUid&&(this.geometry.dispose(),this.geometry=i.geometry.clone(),this.cachaGeometryUUid=i.geometry.uuid)}}};let M=E;s(M,"alphaTexture",new t.CanvasTexture(new w.CanvasGenerator({width:512,height:512,bgColor:"rgb(0, 0, 0)"}).draw(e=>{e.beginPath(),e.fillStyle="rgb(255, 255, 255)",e.arc(256,256,200,0,Math.PI*2),e.fill(),e.closePath()}).getDom()));class J extends t.LineSegments{constructor(e){super();s(this,"target");s(this,"type","VisMeshHelper");s(this,"cachaGeometryUUid");const i=1;this.target=e,this.geometry=new t.EdgesGeometry(e.geometry,i),this.cachaGeometryUUid=e.geometry.uuid,this.material=y(),this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.updateMatrixWorld=()=>{},this.raycast=()=>{},this.onBeforeRender=()=>{const o=this.target;o.geometry.uuid!==this.cachaGeometryUUid&&(this.geometry.dispose(),this.geometry=new t.EdgesGeometry(o.geometry,i),this.cachaGeometryUUid=o.geometry.uuid)}}}const j=class extends t.Points{constructor(e){super();s(this,"target");s(this,"type","VisPointsHelper");this.target=e,this.geometry.dispose(),this.geometry.copy(e.geometry),this.material.dispose(),this.material=new t.PointsMaterial({color:"rgb(255, 255, 255)",alphaMap:j.alphaTexture,transparent:!0});const i=Array.isArray(e.material)?e.material[0]:e.material;i instanceof t.PointsMaterial&&(this.material.size=i.size,this.material.sizeAttenuation=i.sizeAttenuation),this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.raycast=()=>{}}};let P=j;s(P,"alphaTexture",new t.CanvasTexture(new w.CanvasGenerator({width:512,height:512,bgColor:"rgb(0, 0, 0)"}).draw(e=>{e.beginPath(),e.strokeStyle="rgb(255, 255, 255)",e.lineWidth=4,e.strokeRect(0,0,512,512),e.closePath()}).get()));const Y=`

uniform float rotation;
uniform vec2 center;
uniform bool sizeAttenuation;

#include <common>

void main() {
  vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

	if (!sizeAttenuation) {
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );

		if ( isPerspective ) scale *= - mvPosition.z;
  }

	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

}

`,K=`

uniform vec3 color;

void main() {
  gl_FragColor = vec4(color, 1.0);
}
`;class Q extends t.ShaderMaterial{constructor(){super(),this.vertexShader=Y,this.fragmentShader=K,this.uniforms={color:{value:new t.Color("white")},center:{value:new t.Vector2(.5,.5)},rotation:{value:0},sizeAttenuation:{value:!1}}}}class X extends t.LineSegments{constructor(e){super();s(this,"target");s(this,"type","VisSpriteHelper");this.geometry=new t.EdgesGeometry(new t.PlaneBufferGeometry(1,1)),this.geometry.computeBoundingBox(),this.material=new Q,this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.target=e,this.onBeforeRender=()=>{this.material.uniforms.rotation.value=this.target.material.rotation,this.material.uniforms.sizeAttenuation.value=this.target.material.sizeAttenuation},this.raycast=()=>{}}}class A extends u.EventDispatcher{constructor(e={}){super();s(this,"helperGenerator",{PointLight:F,SpotLight:O,DirectionalLight:V,RectAreaLight:T,PerspectiveCamera:W,OrthographicCamera:W,Mesh:J,Group:S,Sprite:X,Points:P,Line:M,CSS3DPlane:I,CSS3DSprite:q,CSS2DPlane:L});s(this,"helperFilter",{AmbientLight:!0,HemisphereLight:!0,Object3D:!0,TransformControls:!0,Scene:!0});s(this,"objectFilter",new Set);s(this,"objectHelperMap",new Map);e.helperGenerator&&(this.helperGenerator=Object.assign(this.helperGenerator,e.helperGenerator)),e.helperFilter&&(this.helperFilter=Object.assign(this.helperFilter,e.helperFilter)),e.objectFilter&&(this.objectFilter=new Set(e.objectFilter.concat(Array.from(this.objectFilter))))}addFilteredObject(...e){for(const i of e)this.objectFilter.add(i);return this}addObjectHelper(e){if(this.objectFilter.has(e)||this.objectHelperMap.has(e)||this.helperFilter[e.type]||e.type.toLocaleLowerCase().includes("helper"))return null;if(!this.helperGenerator[e.type])return console.warn(`object helper can not support this type object: '${e.type}'`),null;const i=new this.helperGenerator[e.type](e);return this.objectHelperMap.set(e,i),i}disposeObjectHelper(e){if(this.objectFilter.has(e)||this.helperFilter[e.type]||e.type.toLocaleLowerCase().includes("helper"))return null;if(!this.objectHelperMap.has(e))return console.warn("object helper manager can not found this object`s helper: ",e),null;const i=this.objectHelperMap.get(e);return i.geometry&&i.geometry.dispose(),i.material&&(i.material instanceof t.Material?i.material.dispose():i.material.forEach(o=>{o.dispose()})),this.objectHelperMap.delete(e),i}dispose(){for(const e of this.objectHelperMap.keys())this.disposeObjectHelper(e);this.objectHelperMap.clear()}}const Z="@vis-three/plugin-object-helper",x="afterAdd",v="afterRemove";t.Scene.prototype.add=function(...c){if(!arguments.length)return this;if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}const n=c[0];if(n===this)return console.error("THREE.Object3D.add: object can't be added as a child of itself.",c),this;if(n&&n.isObject3D){if(n.parent!==null){const e=this.children.indexOf(n);e!==-1&&(n.parent=null,this.children.splice(e,1),n.dispatchEvent({type:"removed"}))}n.parent=this,this.children.push(n),n.dispatchEvent({type:"added"})}else console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",c);return this};const ee=t.Scene.prototype.add,te=t.Scene.prototype.remove;t.Scene.prototype.add=function(...c){return ee.call(this,...c),this.dispatchEvent({type:x,objects:c}),this},t.Scene.prototype.remove=function(...c){return te.call(this,...c),this.dispatchEvent({type:v,objects:c}),this};const D=U.transPkgName(Z),ie=function(){let c,n,e;const i=new WeakSet;return{name:D,install(o){const r=new A,a=r.objectHelperMap;o.objectHelperManager=r,o.setObjectHelper=function(h){if(h)this.scene.traverse(p=>{a.has(p)&&this.scene.add(a.get(p))});else for(let p=0;p<this.scene.children.length;p++){const l=this.scene.children[p];a.has(l)&&this.scene.remove(a.get(l))}return this};const m=h=>{i.has(h)||(h.traverse(p=>{const l=r.addObjectHelper(p);l&&h.add(l)}),i.add(h))};n=h=>{const p=h.objects;for(const l of p){const g=r.addObjectHelper(l);!g||o.scene.add(g)}},e=h=>{const p=h.objects;for(const l of p){const g=r.disposeObjectHelper(l);!g||o.scene.remove(g)}},o.scene.addEventListener(x,n),o.scene.addEventListener(v,e),c=h=>{const p=h.scene;!i.has(p)&&m(p),p.hasEventListener(x,n)||p.addEventListener(x,n),p.hasEventListener(v,e)||p.addEventListener(v,e)},o.addEventListener(u.ENGINE_EVENT.SETSCENE,c)},dispose(o){o.objectHelperManager.objectHelperMap.forEach(r=>{r.parent&&r.parent.remove(r)}),o.objectHelperManager.dispose(),delete o.objectHelperManager,delete o.setObjectHelper,o.removeEventListener(u.ENGINE_EVENT.SETSCENE,c)}}};d.AFTERADD=x,d.AFTERREMOVE=v,d.OBJECT_HELPER_PLUGIN=D,d.ObjectHelperManager=A,d.ObjectHelperPlugin=ie,Object.defineProperties(d,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
