(function(h,m){typeof exports=="object"&&typeof module!="undefined"?m(exports,require("@vis-three/core"),require("three"),require("@vis-three/convenient"),require("@vis-three/utils")):typeof define=="function"&&define.amd?define(["exports","@vis-three/core","three","@vis-three/convenient","@vis-three/utils"],m):(h=typeof globalThis!="undefined"?globalThis:h||self,m((h["vis-three"]=h["vis-three"]||{},h["vis-three"]["plugin-object-helper"]={}),h.core,h.three,h.convenient,h.utils))})(this,function(h,m,t,f,U){"use strict";var te=Object.defineProperty;var ie=(h,m,t)=>m in h?te(h,m,{enumerable:!0,configurable:!0,writable:!0,value:t}):h[m]=t;var s=(h,m,t)=>(ie(h,typeof m!="symbol"?m+"":m,t),t);const u=()=>new t.LineBasicMaterial({color:"rgb(255, 255, 255)"});class A extends t.LineSegments{constructor(e){super();s(this,"shape");s(this,"target");s(this,"type","CameraHelper");s(this,"cachaData");const i=new t.BufferGeometry,r=[0,0,0,-1,1,-1,0,0,0,-1,1,1,0,0,0,-1,-1,-1,0,0,0,-1,-1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,1,1,-1,1,1,-1,-1,1,0,0,0,0,1,1,0,0,0,0,1,-1,0,0,0,0,-1,-1,0,0,0,0,-1,1,0,1,1,0,1,-1,0,1,-1,0,-1,-1,0,-1,-1,0,-1,1,0,-1,1,0,1,1,0,-1,1,2,-1,1,0,1,-1,2,1,-1,0,-1,-1,2,-1,-1,0,1,1,2,1,1,2,1,1,2,-1,1,2,-1,1,2,-1,-1,2,-1,-1,2,1,-1,2,1,-1,2,1,1];i.setAttribute("position",new t.Float32BufferAttribute(r,3)),i.rotateY(-90*Math.PI/180),i.computeBoundingBox();const o=new t.CameraHelper(e);o.matrix=new t.Matrix4,o.matrixAutoUpdate=!0,o.raycast=()=>{},this.add(o),this.shape=o,this.geometry=i,this.material=u(),this.target=e,this.matrixAutoUpdate=!1,this.matrix=e.matrix,e instanceof t.PerspectiveCamera?this.cachaData={fov:e.fov,aspect:e.aspect,near:e.near,far:e.far}:e instanceof t.OrthographicCamera?this.cachaData={left:e.left,right:e.right,top:e.top,bottom:e.bottom,near:e.near,far:e.far}:this.cachaData={},this.onBeforeRender=()=>{let a=!1;const c=this.cachaData;Object.keys(c).forEach(d=>{c[d]!==e[d]&&(c[d]=e[d],a=!0)}),a&&this.shape.update()}}raycast(e,i){const r=this.matrixWorld,o=this.geometry.boundingBox.clone();if(o.applyMatrix4(r),e.ray.intersectsBox(o)){const a=this.target;i.push({distance:e.ray.origin.distanceTo(a.position),object:a,point:a.position})}}}class D extends t.LineSegments{constructor(e){super();s(this,"sphere");s(this,"target");s(this,"shape");s(this,"type","VisDirectionalLightHelper");s(this,"cacheColor");s(this,"cacheVector3");this.geometry=new t.BufferGeometry;const i=[-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1,0,0,1,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,0,0,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,-.707,0,-.707,.707,0,.707,.707,0,-.707,-.707,0,.707];this.geometry.setAttribute("position",new t.Float32BufferAttribute(i,3)),this.material=u(),this.geometry.boundingSphere;const r=new t.Color().copy(e.color).multiplyScalar(e.intensity),o=new t.PlaneBufferGeometry(20,20);o.dispose();const a=new t.LineSegments(new t.EdgesGeometry(o),new t.LineBasicMaterial({color:r}));a.raycast=()=>{},this.shape=a,this.target=e,this.sphere=new t.Sphere(new t.Vector3(0,0,0),1),this.cacheColor=e.color.getHex(),this.cacheVector3=new t.Vector3,this.add(this.shape),this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.onBeforeRender=()=>{const c=this.target,d=this.shape;c.color.getHex()!==this.cacheColor&&(d.material.color.copy(c.color).multiplyScalar(c.intensity),this.cacheColor=c.color.getHex()),d.lookAt(c.target.position)}}raycast(e,i){const r=this.target,o=r.matrixWorld,a=this.sphere;a.set(this.cacheVector3.set(0,0,0),1),a.applyMatrix4(o),e.ray.intersectsSphere(a)&&i.push({distance:e.ray.origin.distanceTo(r.position),object:r,point:r.position})}}class F extends t.LineSegments{constructor(e){super();s(this,"sphere");s(this,"target");s(this,"shape");s(this,"type","VisPointLightHelper");s(this,"cacheColor");s(this,"cacheDistance");s(this,"cacheVector3");this.geometry=new t.BufferGeometry;const i=[-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1,0,0,1,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,0,0,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,-.707,0,-.707,.707,0,.707,.707,0,-.707,-.707,0,.707];this.geometry.setAttribute("position",new t.Float32BufferAttribute(i,3)),this.material=u(),this.geometry.boundingSphere;const r=new t.Color().copy(e.color).multiplyScalar(e.intensity),o=new t.Mesh(new t.OctahedronBufferGeometry(e.distance,0),new t.MeshBasicMaterial({color:r,wireframe:!0}));o.raycast=()=>{},o.matrixAutoUpdate=!1,this.shape=o,this.target=e,this.sphere=new t.Sphere(new t.Vector3(0,0,0),1),this.cacheColor=e.color.getHex(),this.cacheDistance=e.distance,this.cacheVector3=new t.Vector3,this.add(this.shape),this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.onBeforeRender=()=>{const a=this.target,c=this.shape;a.distance!==this.cacheDistance&&(c.geometry.dispose(),c.geometry=new t.OctahedronBufferGeometry(a.distance,0),this.cacheDistance=a.distance),a.color.getHex()!==this.cacheColor&&(c.material.color.copy(a.color).multiplyScalar(a.intensity),this.cacheColor=a.color.getHex())}}raycast(e,i){const r=this.target,o=r.matrixWorld,a=this.sphere;a.set(this.cacheVector3.set(0,0,0),1),a.applyMatrix4(o),e.ray.intersectsSphere(a)&&i.push({distance:e.ray.origin.distanceTo(r.position),object:r,point:r.position})}}class V extends t.LineSegments{constructor(e){super();s(this,"target");s(this,"type","VisRectAreaLightHelper");s(this,"cacheBox",new t.Box3);s(this,"cacheVector3",new t.Vector3);s(this,"cacheColor");s(this,"cacheIntensity");this.target=e,this.generateShape();const i=u();i.color.copy(e.color).multiplyScalar(e.intensity),this.cacheColor=e.color.getHex(),this.cacheIntensity=e.intensity,this.material=i,this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.onBeforeRender=()=>{const r=this.target;(r.width!==this.geometry.parameters.width||r.height!==this.geometry.parameters.height)&&this.generateShape(),(r.color.getHex()!==this.cacheColor||this.cacheIntensity!==r.intensity)&&(this.material.color.copy(r.color).multiplyScalar(r.intensity),this.cacheColor=r.color.getHex())}}generateShape(){this.geometry.dispose(),this.geometry=new t.PlaneBufferGeometry(this.target.width,this.target.height,4,4),this.geometry.computeBoundingBox()}raycast(e,i){const r=this.target,o=this.cacheBox;o.copy(this.geometry.boundingBox),o.applyMatrix4(r.matrixWorld),e.ray.intersectBox(o,this.cacheVector3)&&i.push({distance:e.ray.origin.distanceTo(r.position),object:r,point:r.position})}}class z extends t.LineSegments{constructor(e){super();s(this,"sphere");s(this,"target");s(this,"shape");s(this,"type","VisSpotLightHelper");s(this,"cacheVector3");s(this,"cacheColor");s(this,"cacheAngle");s(this,"cacheDistance");this.geometry=new t.BufferGeometry;const i=[-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1,0,0,1,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,0,0,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,-.707,0,-.707,.707,0,.707,.707,0,-.707,-.707,0,.707];this.geometry.setAttribute("position",new t.Float32BufferAttribute(i,3)),this.material=u(),this.geometry.boundingSphere;const r=new t.BufferGeometry,o=[0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let p=0,g=1,y=32;p<y;p++,g++){const x=p/y*Math.PI*2,G=g/y*Math.PI*2;o.push(Math.cos(x),Math.sin(x),1,Math.cos(G),Math.sin(G),1)}r.setAttribute("position",new t.Float32BufferAttribute(o,3));const a=u(),c=new t.LineSegments(r,a);c.material.color.copy(e.color).multiplyScalar(e.intensity);const d=e.distance?e.distance:1e3,j=d*Math.tan(e.angle);c.scale.set(j,j,d),c.raycast=()=>{},this.add(c),this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.target=e,this.shape=c,this.sphere=new t.Sphere(new t.Vector3(0,0,0),1),this.cacheColor=e.color.getHex(),this.cacheDistance=e.distance,this.cacheAngle=e.angle,this.cacheVector3=new t.Vector3,this.onBeforeRender=()=>{const p=this.target,g=this.shape;let y=!1;if(p.distance!==this.cacheDistance&&(this.cacheDistance=p.distance,g.scale.z=p.distance,y=!0),p.angle!==this.cacheAngle&&(this.cacheAngle=p.angle,y=!0),y){const x=p.distance*Math.tan(p.angle);g.scale.set(x,x,p.distance)}p.color.getHex()!==this.cacheColor&&(g.material.color.copy(p.color).multiplyScalar(p.intensity),this.cacheColor=p.color.getHex()),g.lookAt(p.target.position)}}raycast(e,i){const r=this.target,o=r.matrixWorld,a=this.sphere;a.set(this.cacheVector3.set(0,0,0),1),a.applyMatrix4(o),e.ray.intersectsSphere(a)&&i.push({distance:e.ray.origin.distanceTo(r.position),object:r,point:r.position})}}const P=class extends t.Points{constructor(e){super();s(this,"target");s(this,"type","GeometricOriginHelper");this.target=e,this.geometry=new t.BufferGeometry().setAttribute("position",new t.BufferAttribute(new Float32Array([0,0,0]),3)),this.material=new t.PointsMaterial({map:P.colorTexture,transparent:!0,alphaTest:.1,depthFunc:t.AlwaysDepth}),this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.renderOrder=100,this.raycast=()=>{}}};let w=P;s(w,"colorTexture",new t.CanvasTexture(new f.CanvasGenerator({width:32,height:32}).draw(e=>{e.beginPath(),e.fillStyle="rgba(0, 0, 0, 0)",e.fillRect(0,0,32,32),e.closePath(),e.beginPath(),e.fillStyle="rgb(255, 163, 0)",e.strokeStyle="black",e.lineWidth=1,e.arc(16,16,15,0,2*Math.PI),e.stroke(),e.fill(),e.closePath()}).get()));class O extends t.LineSegments{constructor(e){const i=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),r=new Float32Array(8*3),o=new t.BufferGeometry;o.setIndex(new t.BufferAttribute(i,1)),o.setAttribute("position",new t.BufferAttribute(r,3));super(o,new t.LineBasicMaterial({color:15662848,toneMapped:!1}));s(this,"target");s(this,"type","BoundingBoxHelper");s(this,"cacheBox",new t.Box3);s(this,"compareBox",new t.Box3);this.matrixAutoUpdate=!1,this.raycast=()=>{},this.target=e,this.onBeforeRender=()=>{this.update()}}update(){if(this.cacheBox.setFromObject(this.target),this.cacheBox.isEmpty()||this.cacheBox.equals(this.compareBox))return;this.compareBox.copy(this.cacheBox);const e=this.cacheBox.min,i=this.cacheBox.max,r=this.geometry.attributes.position,o=r.array;o[0]=i.x,o[1]=i.y,o[2]=i.z,o[3]=e.x,o[4]=i.y,o[5]=i.z,o[6]=e.x,o[7]=e.y,o[8]=i.z,o[9]=i.x,o[10]=e.y,o[11]=i.z,o[12]=i.x,o[13]=i.y,o[14]=e.z,o[15]=e.x,o[16]=i.y,o[17]=e.z,o[18]=e.x,o[19]=e.y,o[20]=e.z,o[21]=i.x,o[22]=e.y,o[23]=e.z,r.needsUpdate=!0,this.geometry.computeBoundingSphere()}}class E extends t.LineSegments{constructor(e){let i=5;if(e.geometry){const d=e.geometry;!d.boundingSphere&&d.computeBoundingSphere(),i=d.boundingSphere.radius*.8}const r=[0,0,0,i,0,0,0,0,0,0,i,0,0,0,0,0,0,i],o=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],a=new t.BufferGeometry;a.setAttribute("position",new t.Float32BufferAttribute(r,3)),a.setAttribute("color",new t.Float32BufferAttribute(o,3));const c=new t.LineBasicMaterial({vertexColors:!0,toneMapped:!1,depthFunc:t.AlwaysDepth});super(a,c);s(this,"target");this.target=e,this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.renderOrder=100,this.raycast=()=>{}}}const R=`

#include <common>

void main() {
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

  bool isPerspective = isPerspectiveMatrix( projectionMatrix );

  if ( isPerspective ) scale *= - mvPosition.z;

	vec2 alignedPosition = position.xy * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( 0.0 ) * alignedPosition.x - sin( 0.0 ) * alignedPosition.y;
	rotatedPosition.y = sin( 0.0 ) * alignedPosition.x + cos( 0.0 ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

}

`,T=`

uniform vec3 color;

void main() {
  gl_FragColor = vec4(color, 1.0);
}
`;class N extends t.ShaderMaterial{constructor(){super(),this.vertexShader=R,this.fragmentShader=T,this.uniforms={color:{value:new t.Color("white")}}}}class L extends t.LineSegments{constructor(e){super();s(this,"target");s(this,"type","VisCSS2DPlaneHelper");s(this,"observer");this.geometry=new t.EdgesGeometry(new t.PlaneBufferGeometry(1,1)),this.geometry.computeBoundingBox(),this.material=new N,this.scale.copy(e.matrixScale),this.position.set(e.position.x,e.position.y,e.position.z),this.target=e;const i=new MutationObserver(()=>{this.scale.copy(e.matrixScale)});i.observe(e.element,{attributeFilter:["style"]}),this.observer=i,this.onBeforeRender=()=>{this.position.set(this.target.position.x,this.target.position.y,this.target.position.z)},this.raycast=()=>{}}dispose(){this.observer.disconnect()}}class I extends t.LineSegments{constructor(e){super();s(this,"target");s(this,"type","VisCSS3DPlaneHelper");s(this,"observer");this.geometry=new t.EdgesGeometry(new t.PlaneBufferGeometry(e.width,e.height)),this.geometry.computeBoundingBox(),this.material=u(),this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.target=e;const i=new MutationObserver(()=>{this.geometry.dispose(),this.geometry=new t.EdgesGeometry(new t.PlaneBufferGeometry(e.width,e.height)),this.geometry.computeBoundingBox()});i.observe(e.element,{attributeFilter:["style"]}),this.observer=i,this.raycast=()=>{},this.updateMatrixWorld=()=>{}}dispose(){this.observer.disconnect()}}const _=`
uniform float rotation2D;

#include <common>

void main() {
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

	vec2 alignedPosition = position.xy * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation2D ) * alignedPosition.x - sin( rotation2D ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation2D ) * alignedPosition.x + cos( rotation2D ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

}

`,$=`

uniform vec3 color;

void main() {
  gl_FragColor = vec4(color, 1.0);
}
`;class k extends t.ShaderMaterial{constructor(){super(),this.vertexShader=_,this.fragmentShader=$,this.uniforms={color:{value:new t.Color("white")},rotation2D:{value:0}}}}class q extends t.LineSegments{constructor(e){super();s(this,"target");s(this,"type","VisCSS3DSpriteHelper");s(this,"observer");this.geometry=new t.EdgesGeometry(new t.PlaneBufferGeometry(1,1)),this.geometry.computeBoundingBox(),this.material=new k,this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.target=e;const i=new MutationObserver(()=>{this.geometry.dispose(),this.geometry=new t.EdgesGeometry(new t.PlaneBufferGeometry(e.width,e.height)),this.geometry.computeBoundingBox()});i.observe(e.element,{attributeFilter:["style"]}),this.observer=i,this.onBeforeRender=()=>{this.material.uniforms.rotation2D.value=this.target.rotation2D},this.raycast=()=>{},this.updateMatrixWorld=()=>{}}dispose(){this.observer.disconnect()}}const S=class extends t.Sprite{constructor(e){super();s(this,"target");s(this,"type","VisGroupHelper");this.target=e,this.geometry.computeBoundingBox(),this.material=new t.SpriteMaterial({map:S.colorTexture}),this.material.depthTest=!1,this.material.depthWrite=!1,this.scale.set(5,5,5);const i=this.updateMatrixWorld.bind(this);this.updateMatrixWorld=r=>{const o=this.position,a=this.target.position;o.x=a.x,o.y=a.y,o.z=a.z,i(r)}}raycast(e,i){const r=this.matrixWorld,o=this.geometry.boundingBox.clone();if(o.applyMatrix4(r),e.ray.intersectsBox(o)){const a=this.target;i.push({distance:e.ray.origin.distanceTo(a.position),object:a,point:a.position})}}};let b=S;s(b,"colorTexture",new t.CanvasTexture(new f.CanvasGenerator({width:512,height:512}).draw(e=>{e.beginPath(),e.fillStyle="rgba(0, 0, 0, 0)",e.fillRect(0,0,512,512),e.closePath(),e.translate(256,200),e.beginPath(),e.fillStyle="yellow",e.fillRect(-200,0,400,200),e.closePath(),e.beginPath(),e.fillStyle="yellow",e.fillRect(-200,-70,200,70),e.closePath()}).get()));const B=class extends t.Points{constructor(e){super();s(this,"target");s(this,"cachaGeometryUUid");s(this,"type","VisLineHelper");this.target=e,this.geometry.dispose(),this.geometry.copy(e.geometry),this.cachaGeometryUUid=e.geometry.uuid,this.material=new t.PointsMaterial({color:"rgb(255, 255, 255)",alphaMap:B.alphaTexture,transparent:!0,size:5,sizeAttenuation:!1}),this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.renderOrder=-1,this.raycast=()=>{},this.onBeforeRender=()=>{const i=this.target;i.geometry.uuid!==this.cachaGeometryUUid&&(this.geometry.dispose(),this.geometry=i.geometry.clone(),this.cachaGeometryUUid=i.geometry.uuid)}}};let v=B;s(v,"alphaTexture",new t.CanvasTexture(new f.CanvasGenerator({width:512,height:512,bgColor:"rgb(0, 0, 0)"}).draw(e=>{e.beginPath(),e.fillStyle="rgb(255, 255, 255)",e.arc(256,256,200,0,Math.PI*2),e.fill(),e.closePath()}).getDom()));class J extends t.LineSegments{constructor(e){super();s(this,"target");s(this,"type","VisMeshHelper");s(this,"cachaGeometryUUid");const i=1;this.target=e,this.geometry=new t.EdgesGeometry(e.geometry,i),this.cachaGeometryUUid=e.geometry.uuid,this.material=u(),this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.updateMatrixWorld=()=>{},this.raycast=()=>{},this.onBeforeRender=()=>{const r=this.target;r.geometry.uuid!==this.cachaGeometryUUid&&(this.geometry.dispose(),this.geometry=new t.EdgesGeometry(r.geometry,i),this.cachaGeometryUUid=r.geometry.uuid)}}}const H=class extends t.Points{constructor(e){super();s(this,"target");s(this,"type","VisPointsHelper");this.target=e,this.geometry.dispose(),this.geometry.copy(e.geometry),this.material.dispose(),this.material=new t.PointsMaterial({color:"rgb(255, 255, 255)",alphaMap:H.alphaTexture,transparent:!0});const i=Array.isArray(e.material)?e.material[0]:e.material;i instanceof t.PointsMaterial&&(this.material.size=i.size,this.material.sizeAttenuation=i.sizeAttenuation),this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.raycast=()=>{}}};let M=H;s(M,"alphaTexture",new t.CanvasTexture(new f.CanvasGenerator({width:512,height:512,bgColor:"rgb(0, 0, 0)"}).draw(e=>{e.beginPath(),e.strokeStyle="rgb(255, 255, 255)",e.lineWidth=4,e.strokeRect(0,0,512,512),e.closePath()}).get()));const Y=`

uniform float rotation;
uniform vec2 center;
uniform bool sizeAttenuation;

#include <common>

void main() {
  vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

	if (!sizeAttenuation) {
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );

		if ( isPerspective ) scale *= - mvPosition.z;
  }

	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

}

`,K=`

uniform vec3 color;

void main() {
  gl_FragColor = vec4(color, 1.0);
}
`;class Q extends t.ShaderMaterial{constructor(){super(),this.vertexShader=Y,this.fragmentShader=K,this.uniforms={color:{value:new t.Color("white")},center:{value:new t.Vector2(.5,.5)},rotation:{value:0},sizeAttenuation:{value:!1}}}}class X extends t.LineSegments{constructor(e){super();s(this,"target");s(this,"type","VisSpriteHelper");this.geometry=new t.EdgesGeometry(new t.PlaneBufferGeometry(1,1)),this.geometry.computeBoundingBox(),this.material=new Q,this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.target=e,this.onBeforeRender=()=>{this.material.uniforms.rotation.value=this.target.material.rotation,this.material.uniforms.sizeAttenuation.value=this.target.material.sizeAttenuation},this.raycast=()=>{}}}class C extends m.EventDispatcher{constructor(e={}){super();s(this,"helperGenerator",{LocalAxes:E,BoundingBox:O,GeometricOrigin:w,PointLight:F,SpotLight:z,DirectionalLight:D,RectAreaLight:V,PerspectiveCamera:A,OrthographicCamera:A,Mesh:J,Group:b,Sprite:X,Points:M,Line:v,CSS3DPlane:I,CSS3DSprite:q,CSS2DPlane:L});s(this,"typeFilter",{AmbientLight:!0,HemisphereLight:!0,Object3D:!0,TransformControls:!0,Scene:!0});s(this,"objectFilter",new Set);s(this,"objectHelperMap",new Map);e.helperGenerator&&(this.helperGenerator=Object.assign(this.helperGenerator,e.helperGenerator)),e.typeFilter&&(this.typeFilter=Object.assign(this.typeFilter,e.typeFilter)),e.objectFilter&&(this.objectFilter=new Set(e.objectFilter.concat(Array.from(this.objectFilter))))}addFilteredObject(...e){for(const i of e)this.objectFilter.add(i);return this}addFilteredType(...e){for(const i of e)this.typeFilter[i]=!0;return this}addObjectHelper(e,i){if(this.objectFilter.has(e)||this.objectHelperMap.has(e)||this.typeFilter[e.type]||e.type.toLocaleLowerCase().includes("helper"))return null;if(!this.helperGenerator[e.type]||i&&!this.helperGenerator[i])return console.warn(`object helper can not support this type object: '${e.type}', ${i||""}`),null;const r=new this.helperGenerator[i||e.type](e);return this.objectHelperMap.has(e)||this.objectHelperMap.set(e,{}),this.objectHelperMap.get(e)[i||e.type]=r,r}disposeObjectHelper(e,i){if(!this.objectHelperMap.has(e)){console.warn("object helper manager can not found this object`s helpers: ",e);return}const r=function(a){a.geometry&&a.geometry.dispose(),a.material&&(a.material instanceof t.Material?a.material.dispose():a.material.forEach(c=>{c.dispose()}))},o=this.objectHelperMap.get(e);if(i){const a=o[i];if(!o[i]){console.warn(`object helper manager can not found this helper type with object: ${i}`,e);return}r(a),delete o[i];return}Object.values(o).forEach(a=>{r(a)}),this.objectHelperMap.delete(e)}dispose(){for(const e of this.objectHelperMap.keys())this.disposeObjectHelper(e);this.objectHelperMap.clear()}}const Z="@vis-three/plugin-object-helper",W=U.transPkgName(Z),ee=function(){return{name:W,install(n){const l=new C,e=l.objectHelperMap;n.objectHelperManager=l,n.setObjectHelper=function(i){if(i)this.scene.traverse(r=>{e.has(r)&&Object.values(e.get(r)).forEach(o=>{o.visible=!0})});else for(let r=0;r<this.scene.children.length;r++){const o=this.scene.children[r];e.has(o)&&Object.values(e.get(o)).forEach(a=>{a.visible=!1})}return this}},dispose(n){n.objectHelperManager.objectHelperMap.forEach(l=>{Object.values(l).forEach(e=>{e.removeFromParent()})}),n.objectHelperManager.dispose(),delete n.objectHelperManager,delete n.setObjectHelper}}};h.OBJECT_HELPER_PLUGIN=W,h.ObjectHelperManager=C,h.ObjectHelperPlugin=ee,Object.defineProperties(h,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
