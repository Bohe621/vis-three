(function(n,h){typeof exports=="object"&&typeof module!="undefined"?h(exports,require("@vis-three/core"),require("@vis-three/middleware"),require("@vis-three/utils"),require("three"),require("@vis-three/convenient")):typeof define=="function"&&define.amd?define(["exports","@vis-three/core","@vis-three/middleware","@vis-three/utils","three","@vis-three/convenient"],h):(n=typeof globalThis!="undefined"?globalThis:n||self,h((n["vis-three"]=n["vis-three"]||{},n["vis-three"]["plugin-path-support-controls"]={}),n.core,n.middleware,n.utils,n.three,n.convenient))})(this,function(n,h,v,y,r,P){"use strict";var A=Object.defineProperty;var S=(n,h,v)=>h in n?A(n,h,{enumerable:!0,configurable:!0,writable:!0,value:v}):n[h]=v;var s=(n,h,v)=>(S(n,typeof h!="symbol"?h+"":h,v),v);const z="@vis-three/plugin-path-support-controls",b=new r.CanvasTexture(new P.CanvasGenerator({width:32,height:32}).draw(e=>{e.beginPath(),e.fillStyle="rgba(0, 0, 0, 0)",e.fillRect(0,0,32,32),e.closePath(),e.beginPath(),e.fillStyle="rgb(0, 255, 238)",e.strokeStyle="black",e.lineWidth=1,e.arc(16,16,15,0,2*Math.PI),e.stroke(),e.fill(),e.closePath()}).getDom()),D=new r.CanvasTexture(new P.CanvasGenerator({width:32,height:32}).draw(e=>{e.beginPath(),e.fillStyle="rgba(0, 0, 0, 0)",e.fillRect(0,0,32,32),e.closePath(),e.beginPath(),e.fillStyle="rgb(255, 248, 0)",e.strokeStyle="black",e.lineWidth=1,e.arc(16,16,15,0,2*Math.PI),e.stroke(),e.fill(),e.closePath()}).getDom()),I=new r.CanvasTexture(new P.CanvasGenerator({width:32,height:32}).draw(e=>{e.beginPath(),e.fillStyle="rgba(0, 0, 0, 0)",e.fillRect(0,0,32,32),e.closePath(),e.beginPath(),e.fillStyle="rgb(255, 0, 0)",e.strokeStyle="black",e.lineWidth=1,e.moveTo(1,0),e.lineTo(31,16),e.lineTo(0,31),e.lineTo(1,0),e.stroke(),e.fill(),e.closePath()}).getDom()),f=class extends r.Object3D{constructor(t,i,o,m){super();s(this,"dragging",!1);s(this,"anchorGizmo",new r.Points(new r.BufferGeometry,f.anchorMaterial));s(this,"moveGizmo",new r.Points(new r.BufferGeometry,f.moveMaterial));s(this,"switchGizmo",new r.Points(new r.BufferGeometry,f.switchMaterial));s(this,"raycaster",new r.Raycaster);s(this,"plane",new r.Plane);s(this,"pointerManager");s(this,"cachePlaneVector3",new r.Vector3);s(this,"cacheQuaternion",new r.Quaternion);s(this,"cacheNormal",new r.Vector3);s(this,"cachePosition",new r.Vector3);s(this,"cacheVertical",0);s(this,"cacheMouseDownPoistion",new r.Vector3);s(this,"cacheMouseMoveDirection",new r.Vector3);s(this,"geometryIndexFunMap",{arcVertical:[],arcClockwise:[],bezierCP1:[],bezierCP2:[],quadraticCP1:[]});s(this,"anchorArcUpdateIndexs",[]);s(this,"arcVecticalDirectionsMap",{});s(this,"currentGuizmo");s(this,"currentIndex",0);s(this,"domElement");s(this,"camera");s(this,"config");s(this,"object");s(this,"_pointerHover",this.pointerHover.bind(this));s(this,"_pointerMove",this.pointerMove.bind(this));s(this,"_pointerDown",this.pointerDown.bind(this));s(this,"_pointerUp",this.pointerUp.bind(this));this.anchorGizmo.type="PathSupportControlsAnchorGizmo",this.moveGizmo.type="PathSupportControlsMoveGizmo",this.switchGizmo.type="PathSupportControlsSwitchGizmo",this.add(this.anchorGizmo,this.moveGizmo,this.switchGizmo),this.renderOrder=1/0,this.matrixAutoUpdate=!1,m&&this.setConfig(m),o&&this.setObject(o),this.setDom(i).setCamera(t).connect()}setDom(t){return this.domElement&&this.disconnect(),this.domElement=t,this.connect(),this}setCamera(t){return this.camera=t,this}setObject(t){return this.object=t,this.matrix=t.matrix,this.matrixWorld=t.matrixWorld,this}setConfig(t){this.geometryIndexFunMap={arcVertical:[],arcClockwise:[],bezierCP1:[],bezierCP2:[],quadraticCP1:[]},this.arcVecticalDirectionsMap={},this.anchorArcUpdateIndexs=[],this.config=t;const i=[],o=[],m=[],p=this.geometryIndexFunMap,M=this.arcVecticalDirectionsMap;this.config.curves.forEach((a,u,c)=>{if(u===c.length-1?i.push(a.params[0],a.params[1],0,a.params[a.params.length-2],a.params[a.params.length-1],0):i.push(a.params[0],a.params[1],0),a.curve==="arc"){this.anchorArcUpdateIndexs.push(u,u+1);const l=y.getArcDetail(...a.params);m.push(l.center.x,l.center.y,0),p.arcVertical.push(m.length/3-1),M[m.length/3-1]={segment:u,direction:new r.Vector3(l.verticalDirection.x,l.verticalDirection.y,0)};const T=l.mid.clone().sub(l.start).multiplyScalar(.5),G=l.start.clone().add(T);o.push(G.x,G.y,0),p.arcClockwise.push(u)}});const d=function(a,u){const c=a.geometry;c.setAttribute("position",new r.BufferAttribute(new Float32Array(u),3)),c.getAttribute("position").needsUpdate=!0,c.computeBoundingBox(),c.computeBoundingSphere()};return d(this.anchorGizmo,i),d(this.moveGizmo,m),d(this.switchGizmo,o),this}update(){this.setConfig(this.config)}use(t){this.pointerManager=t}connect(){return this.object&&this.config&&(this.domElement.addEventListener("pointermove",this._pointerHover),this.domElement.addEventListener("mousedown",this._pointerDown)),this}disconnect(){return this.domElement.removeEventListener("pointermove",this._pointerHover),this.domElement.removeEventListener("mousedown",this._pointerDown),this}dispose(){const t=i=>{i.geometry.dispose(),Array.isArray(i.material)?i.material.forEach(o=>{o.dispose()}):i.material.dispose()};t(this.anchorGizmo),t(this.moveGizmo),t(this.switchGizmo)}intersectPoint(t){this.raycaster.setFromCamera(this.pointerManager.mouse,this.camera);const i=this.raycaster.intersectObject(this,!0);return i.length?(this.currentGuizmo=i[0].object,this.currentIndex=i[0].index,{guizmo:this.currentGuizmo,index:this.currentIndex}):null}intersectPlane(t){return this.raycaster.setFromCamera(this.pointerManager.mouse,this.camera),this.raycaster.ray.intersectPlane(this.plane,this.cachePlaneVector3)}pointerHover(t){if(this.dragging||!this.visible)return;const i=this.intersectPoint(t);Number.isInteger(i==null?void 0:i.index)?this.domElement.style.cursor="move":this.domElement.style.cursor=""}pointerDown(t){if(!this.visible)return;if(this.cacheQuaternion.setFromRotationMatrix(this.object.matrixWorld),this.cacheNormal.set(0,0,1).applyQuaternion(this.cacheQuaternion),this.cachePosition.setFromMatrixPosition(this.object.matrixWorld),this.plane.set(this.cacheNormal,this.cachePosition.length()),this.intersectPoint(t)){if(this.currentGuizmo===this.switchGizmo){const o=this.config.curves[this.geometryIndexFunMap.arcClockwise[this.currentIndex]];o.params[3]=!o.params[3];return}if(this.dragging=!0,this.cacheMouseDownPoistion.copy(this.intersectPlane(t)).sub(this.cachePosition),this.currentGuizmo===this.moveGizmo&&this.geometryIndexFunMap.arcVertical.includes(this.currentIndex)){const o=this.arcVecticalDirectionsMap[this.currentIndex];this.cacheVertical=this.config.curves[o.segment].params[2]}this.domElement.addEventListener("mousemove",this._pointerMove),this.domElement.addEventListener("mouseup",this._pointerUp)}}pointerMove(t){if(!this.visible&&!this.dragging)return;const i=this.intersectPlane(t);if(!i)return;i.sub(this.cachePosition),this.cacheMouseMoveDirection.copy(i).sub(this.cacheMouseDownPoistion).normalize();const o=this.currentGuizmo,m=this.currentIndex,p=this.config,M=this.geometryIndexFunMap;if(o===this.anchorGizmo){const d=p.curves.length;if(m!==p.curves.length){const c=p.curves[m];c.params[0]=i.x,c.params[1]=i.y}else{const c=p.curves[d-1];c.params[c.params.length-2]=i.x,c.params[c.params.length-1]=i.y}const a=this.anchorGizmo.geometry.getAttribute("position"),u=a.array;u[m*3]=i.x,u[m*3+1]=i.y,a.needsUpdate=!0,this.anchorArcUpdateIndexs.includes(this.currentIndex)&&this.update()}else if(o===this.moveGizmo&&M.arcVertical.includes(m)){const d=this.arcVecticalDirectionsMap[m],a=this.cacheMouseMoveDirection.angleTo(d.direction);p.curves[d.segment].params[2]=this.cacheVertical+i.sub(this.cacheMouseDownPoistion).length()*Math.cos(a);const u=y.getArcDetail(...p.curves[d.segment].params),c=this.moveGizmo.geometry.getAttribute("position"),l=c.array;l[m*3]=u.center.x,l[m*3+1]=u.center.y,c.needsUpdate=!0}}pointerUp(t){this.dragging=!1,this.domElement.removeEventListener("mousemove",this._pointerMove),this.domElement.removeEventListener("mouseup",this._pointerUp),this.currentGuizmo&&(this.currentGuizmo.geometry.computeBoundingSphere(),this.currentGuizmo.geometry.computeBoundingBox())}};let g=f;s(g,"anchorMaterial",new r.PointsMaterial({map:b,transparent:!0,depthFunc:r.AlwaysDepth,alphaTest:.01,sizeAttenuation:!1,size:15})),s(g,"moveMaterial",new r.PointsMaterial({map:D,transparent:!0,depthFunc:r.AlwaysDepth,alphaTest:.01,sizeAttenuation:!1,size:15})),s(g,"switchMaterial",new r.PointsMaterial({map:I,transparent:!0,depthFunc:r.AlwaysDepth,alphaTest:.01,sizeAttenuation:!1,size:15}));const E=y.transPkgName(z),C=function(){let e,w;return{name:E,deps:[...v.PLUGINS,v.POINTER_MANAGER_PLUGIN],install(t){const i=new g(t.camera,t.dom);i.use(t.pointerManager),t.pathSupportControls=i,w=o=>{i.setDom(o.dom)},e=o=>{i.setCamera(o.camera)},t.addEventListener(h.ENGINE_EVENT.SETDOM,w),t.addEventListener(h.ENGINE_EVENT.SETCAMERA,e)},dispose(t){t.removeEventListener(h.ENGINE_EVENT.SETDOM,w),t.removeEventListener(h.ENGINE_EVENT.SETCAMERA,e),t.pathSupportControls.disconnect().dispose(),delete t.pathSupportControls}}};n.PATH_SUPPORT_CONTROLS_PLUGIN=E,n.PathSupportControlsPlugin=C,Object.defineProperties(n,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
